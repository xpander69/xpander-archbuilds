diff -Naur a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
--- a/dlls/ddraw/ddraw.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/ddraw/ddraw.c	2013-11-07 21:40:09.000000000 +0000
@@ -776,6 +776,13 @@
             restore_mode_on_normal);
     DDRAW_dump_cooperativelevel(cooplevel);
 
+    /* hack for WA/WWP/Diablo, wine bug 2082
+     *
+     * These programs use dialog boxes containing standard controls, which they
+     * draw over using directdraw. If we draw to the given window, the draw will
+     * be clipped by the dialog. Instead, draw to the desktop window. */
+    if (use_desktop_hack) window = GetDesktopWindow();
+
     wined3d_mutex_lock();
 
     if (ddraw->flags & DDRAW_SCL_RECURSIVE)
@@ -2962,7 +2969,7 @@
         }
     }
 
-    if (DDSD->ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
+    if (DDSD->ddsCaps.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE))
     {
         if (!(DDSD->ddsCaps.dwCaps & DDSCAPS_TEXTURE))
         {
@@ -3001,7 +3008,7 @@
     }
 
     if (!(desc2.ddsCaps.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY))
-            && !(desc2.ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
+            && !(desc2.ddsCaps.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)))
     {
         enum wined3d_format_id format = wined3dformat_from_ddrawformat(&desc2.u4.ddpfPixelFormat);
         enum wined3d_resource_type rtype;
@@ -5279,7 +5286,8 @@
     ddraw->numIfaces = 1;
     ddraw->ref7 = 1;
 
-    flags = WINED3D_LEGACY_DEPTH_BIAS | WINED3D_VIDMEM_ACCOUNTING;
+    flags = WINED3D_LEGACY_DEPTH_BIAS | WINED3D_VIDMEM_ACCOUNTING
+            | WINED3D_NO_CSMT;
     if (!(ddraw->wined3d = wined3d_create(7, flags)))
     {
         if (!(ddraw->wined3d = wined3d_create(7, flags | WINED3D_NO3D)))
diff -Naur a/dlls/ddraw/ddraw_private.h b/dlls/ddraw/ddraw_private.h
--- a/dlls/ddraw/ddraw_private.h	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/ddraw/ddraw_private.h	2013-11-07 21:40:09.000000000 +0000
@@ -128,6 +128,9 @@
 void DDRAW_Convert_DDDEVICEIDENTIFIER_2_To_1(const DDDEVICEIDENTIFIER2 *pIn, DDDEVICEIDENTIFIER *pOut) DECLSPEC_HIDDEN;
 struct wined3d_vertex_declaration *ddraw_find_decl(struct ddraw *ddraw, DWORD fvf) DECLSPEC_HIDDEN;
 
+/* hack for WA/WWP/Diablo */
+extern int use_desktop_hack;
+
 struct ddraw_surface
 {
     /* IUnknown fields */
diff -Naur a/dlls/ddraw/main.c b/dlls/ddraw/main.c
--- a/dlls/ddraw/main.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/ddraw/main.c	2013-11-07 21:40:09.000000000 +0000
@@ -36,6 +36,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(ddraw);
 
+/* hack for WA/WWP/Diablo */
+int use_desktop_hack = 0;
+
 static struct list global_ddraw_list = LIST_INIT(global_ddraw_list);
 
 static HINSTANCE instance;
@@ -799,6 +802,22 @@
 }
 
 /***********************************************************************
+ * get_config_key
+ *
+ * Reads a config key from the registry. Taken from WineD3D
+ *
+ ***********************************************************************/
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char* name, char* buffer, DWORD size)
+{
+    if (0 != appkey && !RegQueryValueExA( appkey, name, 0, NULL, (LPBYTE) buffer, &size )) return 0;
+    if (0 != defkey && !RegQueryValueExA( defkey, name, 0, NULL, (LPBYTE) buffer, &size )) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+/***********************************************************************
  * DllMain (DDRAW.0)
  *
  * Could be used to register DirectDraw drivers, if we have more than
@@ -813,8 +832,12 @@
     case DLL_PROCESS_ATTACH:
     {
         static HMODULE ddraw_self;
+        char buffer[MAX_PATH+10];
+        DWORD size = sizeof(buffer);
         HKEY hkey = 0;
+        HKEY appkey = 0;
         WNDCLASSA wc;
+        DWORD len;
 
         /* Register the window class. This is used to create a hidden window
          * for D3D rendering, if the application didn't pass one. It can also
@@ -835,6 +858,33 @@
             return FALSE;
         }
 
+       /* @@ Wine registry key: HKCU\Software\Wine\Direct3D */
+       if ( RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\Direct3D", &hkey ) ) hkey = 0;
+
+       len = GetModuleFileNameA( 0, buffer, MAX_PATH );
+       if (len && len < MAX_PATH)
+       {
+            HKEY tmpkey;
+            /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Direct3D */
+            if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey ))
+            {
+                char *p, *appname = buffer;
+                if ((p = strrchr( appname, '/' ))) appname = p + 1;
+                if ((p = strrchr( appname, '\\' ))) appname = p + 1;
+                strcat( appname, "\\Direct3D" );
+                TRACE("appname = [%s]\n", appname);
+                if (RegOpenKeyA( tmpkey, appname, &appkey )) appkey = 0;
+                RegCloseKey( tmpkey );
+            }
+       }
+
+       if ( 0 != hkey || 0 != appkey )
+       {
+            /* hack for WA/WWP/Diablo */
+            if ( !get_config_key( hkey, appkey, "DDrawDesktopHack", buffer, size) )
+                use_desktop_hack = IS_OPTION_TRUE( buffer[0] );
+        }
+
         /* On Windows one can force the refresh rate that DirectDraw uses by
          * setting an override value in dxdiag.  This is documented in KB315614
          * (main article), KB230002, and KB217348.  By comparing registry dumps
diff -Naur a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
--- a/dlls/ddraw/surface.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/ddraw/surface.c	2013-11-07 21:40:09.000000000 +0000
@@ -5608,7 +5608,7 @@
     else
         layers = 1;
 
-    if (desc->ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
+    if (desc->ddsCaps.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE))
     {
         wined3d_desc.usage = WINED3DUSAGE_TEXTURE;
         pool = WINED3D_POOL_MANAGED;
@@ -5623,7 +5623,7 @@
     }
     else
     {
-        wined3d_desc.usage = WINED3DUSAGE_TEXTURE;
+        wined3d_desc.usage = WINED3DUSAGE_TEXTURE | WINED3DUSAGE_DYNAMIC;
         pool = WINED3D_POOL_DEFAULT;
     }
 
@@ -5730,7 +5730,7 @@
 
     if (!(desc->ddsCaps.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY))
             && !((desc->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
-            && (desc->ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)))
+            && (desc->ddsCaps.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE))))
     {
         /* Tests show surfaces without memory flags get these flags added
          * right after creation. */
@@ -5760,7 +5760,7 @@
     {
         pool = WINED3D_POOL_SYSTEM_MEM;
     }
-    else if (desc->ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
+    else if (desc->ddsCaps.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE))
     {
         pool = WINED3D_POOL_MANAGED;
         /* Managed textures have the system memory flag set. */
@@ -5771,6 +5771,7 @@
         /* Videomemory adds localvidmem. This is mutually exclusive with
          * systemmemory and texturemanage. */
         desc->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
+        usage |= WINED3DUSAGE_DYNAMIC;
     }
 
     format = wined3dformat_from_ddrawformat(&desc->u4.ddpfPixelFormat);
@@ -5837,8 +5838,12 @@
     }
     else
     {
+        UINT row_pitch, slice_pitch;
+        struct wined3d_resource *resource = wined3d_surface_get_resource(surface->wined3d_surface);
+        wined3d_resource_get_pitch(resource, &row_pitch, &slice_pitch);
+
         surface->surface_desc.dwFlags |= DDSD_PITCH;
-        surface->surface_desc.u1.lPitch = wined3d_surface_get_pitch(surface->wined3d_surface);
+        surface->surface_desc.u1.lPitch = row_pitch;
     }
 
     if (desc->dwFlags & DDSD_CKDESTOVERLAY)
diff -Naur a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
--- a/dlls/wined3d/arb_program_shader.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/arb_program_shader.c	2013-11-07 21:40:10.000000000 +0000
@@ -170,6 +170,7 @@
     } no;
     struct wined3d_shader_loop_control loop_control;
     BOOL                            had_else;
+    char                            src_param[256]; /* For the broken ARA quirk */
 };
 
 struct arb_ps_np2fixup_info
@@ -185,8 +186,7 @@
 struct arb_ps_compile_args
 {
     struct ps_compile_args          super;
-    WORD                            bools;
-    WORD                            clip;  /* only a boolean, use a WORD for alignment */
+    DWORD                           bools;
     unsigned char                   loop_ctrl[MAX_CONST_I][3];
 };
 
@@ -706,7 +706,7 @@
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
-        UINT rt_height = state->fb->render_targets[0]->resource.height;
+        UINT rt_height = state->fb.render_targets[0]->resource.height;
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constantsF(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -2506,7 +2506,9 @@
         case WINED3DSIH_RSQ:  instruction = "RSQ"; break;
         case WINED3DSIH_RCP:  instruction = "RCP"; break;
         case WINED3DSIH_EXP:  instruction = "EX2"; break;
-        case WINED3DSIH_EXPP: instruction = "EXP"; break;
+        /* Use EX2, not EXP, otherwise fog breaks in Guild
+         * Wars 2. */
+        case WINED3DSIH_EXPP: instruction = "EX2"; break;
         default: instruction = "";
             FIXME("Unhandled opcode %#x\n", ins->handler_idx);
             break;
@@ -2803,8 +2805,12 @@
             return;
     }
 
-    /* LOG and LOGP operate on the absolute value of the input */
-    src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
+    /* LOG and LOGP operate on the absolute value of the input. */
+    /* CrossOver hack: This was added for a DCT test, and it breaks Half Life
+     * 2 Episode two because the TA blasts the 32 register limit on gf7 cards.
+     * Allow disabling it for HL2. */
+    if (!cxgames_hacks.no_pow_abs)
+        src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
 
     shader_arb_get_dst_param(ins, &ins->dst[0], dst);
     shader_arb_get_src_param(ins, &src0_copy, 0, src0);
@@ -2829,8 +2835,12 @@
     struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
     const char *one = arb_get_helper_value(ins->ctx->reg_maps->shader_version.type, ARB_ONE);
 
-    /* POW operates on the absolute value of the input */
-    src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
+    /* POW operates on the absolute value of the input. */
+    /* CrossOver hack: This was added for a DCT test, and it breaks Half Life
+     * 2 Episode two because the TA blasts the 32 register limit on gf7 cards.
+     * Allow disabling it for HL2. */
+    if (!cxgames_hacks.no_pow_abs)
+        src0_copy.modifiers = abs_modifier(src0_copy.modifiers, &need_abs);
 
     shader_arb_get_dst_param(ins, &ins->dst[0], dst);
     shader_arb_get_src_param(ins, &src0_copy, 0, src0);
@@ -2862,11 +2872,33 @@
     }
 }
 
+static void loop_helper_component(unsigned int depth, char *counter, char *aL)
+{
+    if(depth == 0)
+    {
+        *counter = 'x';
+        *aL = 'y';
+        return;
+    }
+    if(depth == 1)
+    {
+        *counter = 'z';
+        *aL = 'w';
+        return;
+    }
+
+    FIXME("Unsupported loop depth for broken ARA quirk: %u\n", depth);
+    *counter = '?';
+    *aL = '?';
+}
+
 static void shader_hw_loop(const struct wined3d_shader_instruction *ins)
 {
     struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
     char src_name[50];
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     /* src0 is aL */
     shader_arb_get_src_param(ins, &ins->src[1], 0, src_name);
@@ -2876,12 +2908,30 @@
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char counter, aL;
 
         if(priv->loop_depth > 1) shader_addline(buffer, "PUSHA aL;\n");
-        /* The constant loader makes sure to load -1 into iX.w */
-        shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
-        shader_addline(buffer, "BRA loop_%u_end (LE.x);\n", control_frame->no.loop);
+
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            loop_helper_component(priv->loop_depth, &counter, &aL);
+            shader_addline(buffer, "MOVC loop_helper.%c%c, %s.xyxy;\n", counter, aL, src_name);
+            strcpy(control_frame->src_param, src_name);
+        }
+        else
+        {
+            /* The constant loader makes sure to load -1 into iX.w */
+            shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
+            counter = 'x';
+            aL = 'y';
+        }
+        shader_addline(buffer, "BRA loop_%u_end (LE.%c);\n", control_frame->no.loop, counter);
         shader_addline(buffer, "loop_%u_start:\n", control_frame->no.loop);
+
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            shader_addline(buffer, "ARL aL.y, loop_helper.%c;\n", aL);
+        }
     }
     else
     {
@@ -2889,11 +2939,24 @@
     }
 }
 
+static char rep_helper_component(unsigned int depth)
+{
+    if(depth == 0) return 'x';
+    if(depth == 1) return 'y';
+    if(depth == 2) return 'z';
+    if(depth == 3) return 'w';
+
+    FIXME("Unsupported rep depth for broken ARA quirk: %u\n", depth);
+        return 'w';
+}
+
 static void shader_hw_rep(const struct wined3d_shader_instruction *ins)
 {
     struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
     char src_name[50];
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     shader_arb_get_src_param(ins, &ins->src[0], 0, src_name);
 
@@ -2903,11 +2966,21 @@
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char component;
 
-        if(priv->loop_depth > 1) shader_addline(buffer, "PUSHA aL;\n");
-
-        shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
-        shader_addline(buffer, "BRA loop_%u_end (LE.x);\n", control_frame->no.loop);
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            component = rep_helper_component(priv->loop_depth);
+            shader_addline(buffer, "MOVC rep_helper.%c, %s.x;\n", component, src_name);
+            strcpy(control_frame->src_param, src_name);
+        }
+        else
+        {
+            component = 'x';
+            if(priv->loop_depth > 1) shader_addline(buffer, "PUSHA aL;\n");
+            shader_addline(buffer, "ARLC aL, %s.xywz;\n", src_name);
+        }
+        shader_addline(buffer, "BRA loop_%u_end (LE.%c);\n", control_frame->no.loop, component);
         shader_addline(buffer, "loop_%u_start:\n", control_frame->no.loop);
     }
     else
@@ -2920,15 +2993,29 @@
 {
     struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     if(vshader)
     {
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char counter, aL;
 
-        shader_addline(buffer, "ARAC aL.xy, aL;\n");
-        shader_addline(buffer, "BRA loop_%u_start (GT.x);\n", control_frame->no.loop);
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            loop_helper_component(priv->loop_depth, &counter, &aL);
+            shader_addline(buffer, "ADDC loop_helper.%c%c, loop_helper.%c%c%c%c, %s.wzwz;\n",
+                          counter, aL, counter, aL, counter, aL, control_frame->src_param);
+        }
+        else
+        {
+            shader_addline(buffer, "ARAC aL.xy, aL;\n");
+            counter = 'x';
+            aL = 'y';
+        }
+        shader_addline(buffer, "BRA loop_%u_start (GT.%c);\n", control_frame->no.loop, counter);
         shader_addline(buffer, "loop_%u_end:\n", control_frame->no.loop);
 
         if(priv->loop_depth > 1) shader_addline(buffer, "POPA aL;\n");
@@ -2943,18 +3030,34 @@
 {
     struct wined3d_shader_buffer *buffer = ins->ctx->buffer;
     BOOL vshader = shader_is_vshader_version(ins->ctx->reg_maps->shader_version.type);
+    const struct wined3d_device *device = ins->ctx->shader->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
     if(vshader)
     {
         struct shader_arb_ctx_priv *priv = ins->ctx->backend_data;
         struct list *e = list_head(&priv->control_frames);
         struct control_frame *control_frame = LIST_ENTRY(e, struct control_frame, entry);
+        char component;
 
-        shader_addline(buffer, "ARAC aL.xy, aL;\n");
-        shader_addline(buffer, "BRA loop_%u_start (GT.x);\n", control_frame->no.loop);
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            component = rep_helper_component(priv->loop_depth);
+            shader_addline(buffer, "ADDC rep_helper.%c, rep_helper.%c, %s.w;\n", component,
+                           component, control_frame->src_param);
+        }
+        else
+        {
+            component = 'x';
+            shader_addline(buffer, "ARAC aL.xy, aL;\n");
+        }
+        shader_addline(buffer, "BRA loop_%u_start (GT.%c);\n", control_frame->no.loop, component);
         shader_addline(buffer, "loop_%u_end:\n", control_frame->no.loop);
 
-        if(priv->loop_depth > 1) shader_addline(buffer, "POPA aL;\n");
+        if (!(gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA))
+        {
+            if(priv->loop_depth > 1) shader_addline(buffer, "POPA aL;\n");
+        }
     }
     else
     {
@@ -3601,9 +3704,11 @@
     BOOL dcl_td = FALSE;
     BOOL want_nv_prog = FALSE;
     struct arb_pshader_private *shader_priv = shader->backend_data;
+    BOOL varying_limit_ok = TRUE;
     GLint errPos;
     DWORD map;
     BOOL custom_linear_fog = FALSE;
+    WORD old_fpu_cw = wined3d_get_fpu_cw();
 
     char srgbtmp[4][4];
     char ftoa_tmp[16];
@@ -3698,7 +3803,22 @@
         shader_addline(buffer, "OPTION ARB_draw_buffers;\n");
     }
 
-    if (reg_maps->shader_version.major < 3)
+    if (gl_info->quirks & WINED3D_CX_QUIRK_TEXCOORD_FOG)
+    {
+        unsigned int cnt = 0;
+        for(i = 0; i < MAX_REG_TEXCRD; i++)
+        {
+            if (reg_maps->texcoord & (1 << i)) ++cnt;
+        }
+        if(shader_priv->clipplane_emulation) cnt++;
+        if(cnt >= 8)
+        {
+            WARN("Disabling fog because 8 texcoords are used\n");
+            varying_limit_ok = FALSE;
+        }
+    }
+
+    if (reg_maps->shader_version.major < 3 && varying_limit_ok)
     {
         switch (args->super.fog)
         {
@@ -3882,7 +4002,7 @@
         }
     }
 
-    if (shader_priv->clipplane_emulation != ~0U && args->clip)
+    if (shader_priv->clipplane_emulation != ~0U && args->super.clip)
     {
         shader_addline(buffer, "KIL fragment.texcoord[%u];\n", shader_priv->clipplane_emulation);
     }
@@ -3911,10 +4031,17 @@
 
     TRACE("Created hw pixel shader, prg=%d\n", retval);
     /* Create the program and check for errors */
+
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(WINED3D_DEFAULT_FPU_CW);
+
     GL_EXTCALL(glProgramStringARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB,
                buffer->content_size, buffer->buffer));
     checkGLcall("glProgramStringARB()");
 
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(old_fpu_cw);
+
     gl_info->gl_ops.gl.p_glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &errPos);
     if (errPos != -1)
     {
@@ -4189,6 +4316,7 @@
     struct shader_arb_ctx_priv priv_ctx;
     unsigned int i;
     GLint errPos;
+    WORD old_fpu_cw = wined3d_get_fpu_cw();
 
     memset(&priv_ctx, 0, sizeof(priv_ctx));
     priv_ctx.cur_vs_args = args;
@@ -4206,6 +4334,11 @@
         shader_addline(buffer, "OPTION NV_vertex_program3;\n");
         priv_ctx.target_version = NV3;
         shader_addline(buffer, "ADDRESS aL;\n");
+        if (gl_info->quirks & WINED3D_CX_QUIRK_BROKEN_ARA)
+        {
+            shader_addline(buffer, "TEMP rep_helper;\n");
+            shader_addline(buffer, "TEMP loop_helper;\n");
+        }
     }
     else if (gl_info->supported[NV_VERTEX_PROGRAM2_OPTION])
     {
@@ -4309,10 +4442,17 @@
 
     TRACE("Created hw vertex shader, prg=%d\n", ret);
     /* Create the program and check for errors */
+
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(WINED3D_DEFAULT_FPU_CW);
+
     GL_EXTCALL(glProgramStringARB(GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB,
                buffer->content_size, buffer->buffer));
     checkGLcall("glProgramStringARB()");
 
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(old_fpu_cw);
+
     gl_info->gl_ops.gl.p_glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &errPos);
     if (errPos != -1)
     {
@@ -4521,7 +4661,6 @@
         struct arb_ps_compile_args *args)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_d3d_info *d3d_info = context->d3d_info;
     int i;
     WORD int_skip;
 
@@ -4536,17 +4675,6 @@
             args->bools |= ( 1 << i);
     }
 
-    /* Only enable the clip plane emulation KIL if at least one clipplane is enabled. The KIL instruction
-     * is quite expensive because it forces the driver to disable early Z discards. It is cheaper to
-     * duplicate the shader than have a no-op KIL instruction in every shader
-     */
-    if (!d3d_info->vs_clipping && use_vs(state)
-            && state->render_states[WINED3D_RS_CLIPPING]
-            && state->render_states[WINED3D_RS_CLIPPLANEENABLE])
-        args->clip = 1;
-    else
-        args->clip = 0;
-
     /* Skip if unused or local, or supported natively */
     int_skip = ~shader->reg_maps.integer_constants | shader->reg_maps.local_int_consts;
     if (int_skip == 0xffff || gl_info->supported[NV_FRAGMENT_PROGRAM_OPTION])
@@ -4699,7 +4827,7 @@
         }
         else
         {
-            UINT rt_height = state->fb->render_targets[0]->resource.height;
+            UINT rt_height = state->fb.render_targets[0]->resource.height;
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
@@ -5093,6 +5221,11 @@
         }
         caps->vs_version = min(wined3d_settings.max_sm_vs, vs_version);
         caps->vs_uniform_count = vs_consts;
+        if (cxgames_hacks.safe_vs_consts)
+        {
+            /* One for the posFixup, one for the helper const, and the clipplanes. */
+            caps->vs_uniform_count -= 2 + gl_info->limits.clipplanes;
+        }
     }
     else
     {
@@ -7460,7 +7593,8 @@
 
     /* Now load the surface */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
-            && (src_surface->flags & (SFLAG_INTEXTURE | SFLAG_INDRAWABLE)) == SFLAG_INDRAWABLE
+            && (src_surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_DRAWABLE))
+            == WINED3D_LOCATION_DRAWABLE
             && !surface_is_offscreen(src_surface))
     {
         /* Without FBO blits transferring from the drawable to the texture is
@@ -7489,14 +7623,16 @@
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
+    if (wined3d_use_csmt(device))
+        context->gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
             || (dst_surface->swapchain && (dst_surface->swapchain->front_buffer == dst_surface)))
         context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
 
-    surface_validate_location(dst_surface, dst_surface->draw_binding);
-    surface_invalidate_location(dst_surface, ~dst_surface->draw_binding);
+    wined3d_resource_validate_location(&dst_surface->resource, dst_surface->draw_binding);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->draw_binding);
 
     return WINED3D_OK;
 }
diff -Naur a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
--- a/dlls/wined3d/buffer.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/buffer.c	2013-11-07 21:40:10.000000000 +0000
@@ -32,17 +32,16 @@
 #define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
 #define WINED3D_BUFFER_CREATEBO     0x02    /* Create a buffer object for this buffer. */
 #define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
-#define WINED3D_BUFFER_FLUSH        0x08    /* Manual unmap flushing. */
-#define WINED3D_BUFFER_DISCARD      0x10    /* A DISCARD lock has occurred since the last preload. */
-#define WINED3D_BUFFER_NOSYNC       0x20    /* All locks since the last preload had NOOVERWRITE set. */
-#define WINED3D_BUFFER_APPLESYNC    0x40    /* Using sync as in GL_APPLE_flush_buffer_range. */
+#define WINED3D_BUFFER_DISCARD      0x08    /* A DISCARD lock has occurred since the last preload. */
+#define WINED3D_BUFFER_NOSYNC       0x10    /* All locks since the last preload had NOOVERWRITE set. */
+#define WINED3D_BUFFER_APPLESYNC    0x20    /* Using sync as in GL_APPLE_flush_buffer_range. */
 
 #define VB_MAXDECLCHANGES     100     /* After that number of decl changes we stop converting */
 #define VB_RESETDECLCHANGE    1000    /* Reset the decl changecount after that number of draws */
 #define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
-static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
 {
     if (!offset && !size)
         goto invalidate_all;
@@ -118,7 +117,7 @@
 }
 
 /* Context activation is done by the caller. */
-static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
 {
     GLenum gl_usage = GL_STATIC_DRAW_ARB;
     GLenum error;
@@ -163,18 +162,25 @@
         TRACE("Buffer has WINED3DUSAGE_DYNAMIC set.\n");
         gl_usage = GL_STREAM_DRAW_ARB;
 
-        if(gl_info->supported[APPLE_FLUSH_BUFFER_RANGE])
+        if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_NEVER
+                || cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_STATIC)
+        {
+            This->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+        }
+        else if (gl_info->supported[APPLE_FLUSH_BUFFER_RANGE] && !wined3d_use_csmt(This->resource.device))
         {
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE)");
-            This->flags |= WINED3D_BUFFER_FLUSH;
-
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE)");
             This->flags |= WINED3D_BUFFER_APPLESYNC;
         }
         /* No setup is needed here for GL_ARB_map_buffer_range */
     }
+    else if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_NEVER)
+    {
+        This->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+    }
 
     /* Reserve memory for the buffer. The amount of data won't change
      * so we are safe with calling glBufferData once and
@@ -200,6 +206,7 @@
     {
         wined3d_resource_free_sysmem(&This->resource);
         This->resource.allocatedMemory = NULL;
+        This->map_mem = NULL;
     }
 
     return;
@@ -429,7 +436,7 @@
 {
     DWORD src_color = *dst_color;
 
-    /* Color conversion like in drawStridedSlow. watch out for little endianity
+    /* Color conversion like in draw_strided_slow. watch out for little endianity
      * If we want that stuff to work on big endian machines too we have to consider more things
      *
      * 0xff000000: Alpha mask
@@ -463,7 +470,8 @@
     data->buffer_object = buffer->buffer_object;
     if (!buffer->buffer_object)
     {
-        if ((buffer->flags & WINED3D_BUFFER_CREATEBO) && !buffer->resource.map_count)
+        if ((!buffer->resource.map_count || buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
+                && buffer->flags & WINED3D_BUFFER_CREATEBO)
         {
             buffer_create_buffer_object(buffer, context);
             buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
@@ -501,7 +509,9 @@
 
     if (!wined3d_resource_allocate_sysmem(&This->resource))
         ERR("Failed to allocate system memory.\n");
+    This->resource.heap_memory = This->resource.map_heap_memory;
     This->resource.allocatedMemory = This->resource.heap_memory;
+    This->map_mem = This->resource.allocatedMemory;
 
     if (This->buffer_type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
         context_invalidate_state(context, STATE_INDEXBUFFER);
@@ -549,28 +559,38 @@
     resource_unload(resource);
 }
 
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer)
+{
+    struct wined3d_context *context;
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        delete_gl_buffer(buffer, context->gl_info);
+        context_release(context);
+
+        HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
+    }
+
+    HeapFree(GetProcessHeap(), 0, buffer->maps);
+    HeapFree(GetProcessHeap(), 0, buffer);
+}
+
 ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
 {
     ULONG refcount = InterlockedDecrement(&buffer->resource.ref);
-    struct wined3d_context *context;
 
     TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
 
     if (!refcount)
     {
-        if (buffer->buffer_object)
-        {
-            context = context_acquire(buffer->resource.device, NULL);
-            delete_gl_buffer(buffer, context->gl_info);
-            context_release(context);
-
-            HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
-        }
+        struct wined3d_device *device = buffer->resource.device;
 
         resource_cleanup(&buffer->resource);
+
         buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
-        HeapFree(GetProcessHeap(), 0, buffer->maps);
-        HeapFree(GetProcessHeap(), 0, buffer);
+        wined3d_cs_emit_buffer_cleanup(device->cs, buffer);
     }
 
     return refcount;
@@ -665,43 +685,17 @@
 /* The caller provides a GL context */
 static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined3d_gl_info *gl_info, DWORD flags)
 {
-    BYTE *map;
     UINT start = 0, len = 0;
 
     /* This potentially invalidates the element array buffer binding, but the
      * caller always takes care of this. */
     GL_EXTCALL(glBindBufferARB(This->buffer_type_hint, This->buffer_object));
     checkGLcall("glBindBufferARB");
-    if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-    {
-        GLbitfield mapflags;
-        mapflags = GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT;
-        if (flags & WINED3D_BUFFER_DISCARD)
-            mapflags |= GL_MAP_INVALIDATE_BUFFER_BIT;
-        if (flags & WINED3D_BUFFER_NOSYNC)
-            mapflags |= GL_MAP_UNSYNCHRONIZED_BIT;
-        map = GL_EXTCALL(glMapBufferRange(This->buffer_type_hint, 0,
-                    This->resource.size, mapflags));
-        checkGLcall("glMapBufferRange");
-    }
-    else
-    {
-        if (This->flags & WINED3D_BUFFER_APPLESYNC)
-        {
-            DWORD syncflags = 0;
-            if (flags & WINED3D_BUFFER_DISCARD)
-                syncflags |= WINED3D_MAP_DISCARD;
-            if (flags & WINED3D_BUFFER_NOSYNC)
-                syncflags |= WINED3D_MAP_NOOVERWRITE;
-            buffer_sync_apple(This, syncflags, gl_info);
-        }
-        map = GL_EXTCALL(glMapBufferARB(This->buffer_type_hint, GL_WRITE_ONLY_ARB));
-        checkGLcall("glMapBufferARB");
-    }
-    if (!map)
+
+    if (flags & WINED3D_BUFFER_DISCARD)
     {
-        ERR("Failed to map opengl buffer\n");
-        return;
+        GL_EXTCALL(glBufferDataARB(This->buffer_type_hint, This->resource.size, NULL, GL_STREAM_DRAW_ARB));
+        checkGLcall("glBufferDataARB");
     }
 
     while (This->modified_areas)
@@ -710,21 +704,9 @@
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
-        memcpy(map + start, This->resource.allocatedMemory + start, len);
-
-        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-        {
-            GL_EXTCALL(glFlushMappedBufferRange(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRange");
-        }
-        else if (This->flags & WINED3D_BUFFER_FLUSH)
-        {
-            GL_EXTCALL(glFlushMappedBufferRangeAPPLE(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRangeAPPLE");
-        }
+        GL_EXTCALL(glBufferSubDataARB(This->buffer_type_hint, start, len, This->resource.allocatedMemory + start));
+        checkGLcall("glBufferSubDataARB");
     }
-    GL_EXTCALL(glUnmapBufferARB(This->buffer_type_hint));
-    checkGLcall("glUnmapBufferARB");
 }
 
 /* Context activation is done by the caller. */
@@ -741,12 +723,6 @@
 
     TRACE("buffer %p.\n", buffer);
 
-    if (buffer->resource.map_count)
-    {
-        WARN("Buffer is mapped, skipping preload.\n");
-        return;
-    }
-
     buffer->flags &= ~(WINED3D_BUFFER_NOSYNC | WINED3D_BUFFER_DISCARD);
 
     if (!buffer->buffer_object)
@@ -935,10 +911,15 @@
 
 void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
 {
-    struct wined3d_context *context;
-    context = context_acquire(buffer->resource.device, NULL);
-    buffer_internal_preload(buffer, context, NULL);
-    context_release(context);
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->resource.map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
+    wined3d_cs_emit_buffer_preload(device->cs, buffer);
 }
 
 struct wined3d_resource * CDECL wined3d_buffer_get_resource(struct wined3d_buffer *buffer)
@@ -952,9 +933,31 @@
 {
     BOOL dirty = buffer_is_dirty(buffer);
     LONG count;
+    struct wined3d_device *device = buffer->resource.device;
+    struct wined3d_context *context;
 
     TRACE("buffer %p, offset %u, size %u, data %p, flags %#x\n", buffer, offset, size, data, flags);
 
+    /* FIXME: There is a race condition with the same code in
+     * buffer_internal_preload and buffer_get_memory.
+     *
+     * This deals with a race condition concering buffer creation and buffer maps.
+     * If a VBO is created by the worker thread while the buffer is mapped, outdated
+     * data may be uploaded, and the BO range is not properly invaliated. Keep in
+     * mind that a broken application might draw from a buffer before mapping it.
+     *
+     * Don't try to solve this by going back to always invalidating changed areas.
+     * This won't work if we ever want to support glMapBufferRange mapping with
+     * GL_ARB_buffer_storage in the CS.
+     *
+     * Also keep in mind that UnLoad can destroy the VBO, so simply creating it
+     * on buffer creation won't work either. */
+    if (buffer->flags & WINED3D_BUFFER_CREATEBO)
+    {
+        wined3d_cs_emit_create_vbo(device->cs, buffer);
+        buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
+    }
+
     flags = wined3d_resource_sanitize_map_flags(&buffer->resource, flags);
     count = ++buffer->resource.map_count;
 
@@ -965,18 +968,24 @@
          * being uploaded in that case. Two such applications are Port Royale
          * and Darkstar One. */
         if (flags & WINED3D_MAP_DISCARD)
-            buffer_invalidate_bo_range(buffer, 0, 0);
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, 0, 0);
         else if (!(flags & WINED3D_MAP_READONLY))
-            buffer_invalidate_bo_range(buffer, offset, size);
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, offset, size);
 
         if (!(buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER))
         {
             if (count == 1)
             {
                 struct wined3d_device *device = buffer->resource.device;
-                struct wined3d_context *context;
                 const struct wined3d_gl_info *gl_info;
 
+                if (wined3d_use_csmt(buffer->resource.device))
+                {
+                    FIXME("waiting for cs\n");
+                    wined3d_cs_emit_glfinish(device->cs);
+                    device->cs->ops->finish(device->cs);
+                }
+
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
 
@@ -1027,10 +1036,11 @@
                     }
                     TRACE("New pointer is %p.\n", buffer->resource.allocatedMemory);
                 }
+                buffer->map_mem = buffer->resource.allocatedMemory;
                 context_release(context);
             }
         }
-        else
+        else if(!wined3d_use_csmt(buffer->resource.device))
         {
             if (dirty)
             {
@@ -1051,9 +1061,23 @@
         }
     }
 
-    *data = buffer->resource.allocatedMemory + offset;
+    if (wined3d_use_csmt(buffer->resource.device) && count == 1)
+    {
+        BOOL swvp = device->create_parms.flags & WINED3DCREATE_SOFTWARE_VERTEXPROCESSING;
+        if (flags & WINED3D_MAP_DISCARD && !swvp)
+        {
+            buffer->map_mem = wined3d_resource_allocate_sysmem2(&buffer->resource);
+            wined3d_cs_emit_swap_mem(device->cs, buffer, buffer->map_mem);
+        }
+        else if(!(flags & (WINED3D_MAP_NOOVERWRITE | WINED3D_MAP_READONLY)))
+        {
+            wined3d_resource_wait_fence((struct wined3d_resource *)buffer);
+        }
+    }
+
+    *data = buffer->map_mem + offset;
 
-    TRACE("Returning memory at %p (base %p, offset %u).\n", *data, buffer->resource.allocatedMemory, offset);
+    TRACE("Returning memory at %p (base %p, offset %u).\n", *data, buffer->map_mem, offset);
     /* TODO: check Flags compatibility with buffer->currentDesc.Usage (see MSDN) */
 
     return WINED3D_OK;
@@ -1104,7 +1128,7 @@
                 checkGLcall("glFlushMappedBufferRange");
             }
         }
-        else if (buffer->flags & WINED3D_BUFFER_FLUSH)
+        else if (buffer->flags & WINED3D_BUFFER_APPLESYNC)
         {
             for (i = 0; i < buffer->modified_areas; ++i)
             {
@@ -1115,22 +1139,35 @@
         }
 
         GL_EXTCALL(glUnmapBufferARB(buffer->buffer_type_hint));
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_use_csmt(buffer->resource.device))
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
         context_release(context);
 
         buffer->resource.allocatedMemory = NULL;
+        buffer->map_mem = NULL;
         buffer_clear_dirty_areas(buffer);
     }
-    else if (buffer->flags & WINED3D_BUFFER_HASDESC)
-    {
-        wined3d_buffer_preload(buffer);
-    }
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_buffer_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Not yet implemented.\n");
+}
+
+static void wined3d_buffer_changed(struct wined3d_resource *resource)
+{
+    ERR("Not yet implemented.\n");
 }
 
 static const struct wined3d_resource_ops buffer_resource_ops =
 {
     buffer_unload,
+    wined3d_buffer_load_location,
+    wined3d_buffer_changed,
 };
 
 static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device *device,
@@ -1157,6 +1194,7 @@
         return hr;
     }
     buffer->buffer_type_hint = bind_hint;
+    buffer->map_mem = buffer->resource.allocatedMemory;
 
     TRACE("size %#x, usage %#x, format %s, memory @ %p, iface @ %p.\n", buffer->resource.size, buffer->resource.usage,
             debug_d3dformat(buffer->resource.format->id), buffer->resource.allocatedMemory, buffer);
@@ -1172,11 +1210,11 @@
 
     dynamic_buffer_ok = gl_info->supported[APPLE_FLUSH_BUFFER_RANGE] || gl_info->supported[ARB_MAP_BUFFER_RANGE];
 
-    /* Observations show that drawStridedSlow is faster on dynamic VBs than converting +
+    /* Observations show that draw_strided_slow is faster on dynamic VBs than converting +
      * drawStridedFast (half-life 2 and others).
      *
      * Basically converting the vertices in the buffer is quite expensive, and observations
-     * show that drawStridedSlow is faster than converting + uploading + drawStridedFast.
+     * show that draw_strided_slow is faster than converting + uploading + drawStridedFast.
      * Therefore do not create a VBO for WINED3DUSAGE_DYNAMIC buffers.
      */
     if (!gl_info->supported[ARB_VERTEX_BUFFER_OBJECT])
@@ -1224,6 +1262,9 @@
     }
     buffer->maps_size = 1;
 
+    if (wined3d_use_csmt(buffer->resource.device))
+        buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+
     return WINED3D_OK;
 }
 
@@ -1329,3 +1370,11 @@
 
     return WINED3D_OK;
 }
+
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
+{
+    wined3d_resource_free_sysmem(&buffer->resource);
+    buffer->resource.heap_memory = mem;
+    buffer->resource.allocatedMemory = mem;
+    buffer->flags |= WINED3D_BUFFER_DISCARD;
+}
diff -Naur a/dlls/wined3d/context.c b/dlls/wined3d/context.c
--- a/dlls/wined3d/context.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/context.c	2013-11-07 21:40:10.000000000 +0000
@@ -139,8 +139,8 @@
         {
             switch (location)
             {
-                case SFLAG_INTEXTURE:
-                case SFLAG_INSRGBTEX:
+                case WINED3D_LOCATION_TEXTURE_RGB:
+                case WINED3D_LOCATION_TEXTURE_SRGB:
                     surface_prepare_texture(depth_stencil, context, FALSE);
 
                     if (format_flags & WINED3DFMT_FLAG_DEPTH)
@@ -160,20 +160,20 @@
                     }
                     break;
 
-                case SFLAG_INRB_MULTISAMPLE:
+                case WINED3D_LOCATION_RB_MULTISAMPLE:
                     surface_prepare_rb(depth_stencil, gl_info, TRUE);
                     context_attach_depth_stencil_rb(gl_info, fbo_target,
                             format_flags, depth_stencil->rb_multisample);
                     break;
 
-                case SFLAG_INRB_RESOLVED:
+                case WINED3D_LOCATION_RB_RESOLVED:
                     surface_prepare_rb(depth_stencil, gl_info, FALSE);
                     context_attach_depth_stencil_rb(gl_info, fbo_target,
                             format_flags, depth_stencil->rb_resolved);
                     break;
 
                 default:
-                    ERR("Unsupported location %s (%#x).\n", debug_surflocation(location), location);
+                    ERR("Unsupported location %s (%#x).\n", wined3d_debug_location(location), location);
                     break;
             }
         }
@@ -214,9 +214,9 @@
 
         switch (location)
         {
-            case SFLAG_INTEXTURE:
-            case SFLAG_INSRGBTEX:
-                srgb = location == SFLAG_INSRGBTEX;
+            case WINED3D_LOCATION_TEXTURE_RGB:
+            case WINED3D_LOCATION_TEXTURE_SRGB:
+                srgb = location == WINED3D_LOCATION_TEXTURE_SRGB;
                 surface_prepare_texture(surface, context, srgb);
                 gl_info->fbo_ops.glFramebufferTexture2D(fbo_target, GL_COLOR_ATTACHMENT0 + idx,
                         surface->texture_target, surface_get_texture_name(surface, gl_info, srgb),
@@ -224,14 +224,14 @@
                 checkGLcall("glFramebufferTexture2D()");
                 break;
 
-            case SFLAG_INRB_MULTISAMPLE:
+            case WINED3D_LOCATION_RB_MULTISAMPLE:
                 surface_prepare_rb(surface, gl_info, TRUE);
                 gl_info->fbo_ops.glFramebufferRenderbuffer(fbo_target, GL_COLOR_ATTACHMENT0 + idx,
                         GL_RENDERBUFFER, surface->rb_multisample);
                 checkGLcall("glFramebufferRenderbuffer()");
                 break;
 
-            case SFLAG_INRB_RESOLVED:
+            case WINED3D_LOCATION_RB_RESOLVED:
                 surface_prepare_rb(surface, gl_info, FALSE);
                 gl_info->fbo_ops.glFramebufferRenderbuffer(fbo_target, GL_COLOR_ATTACHMENT0 + idx,
                         GL_RENDERBUFFER, surface->rb_resolved);
@@ -239,7 +239,7 @@
                 break;
 
             default:
-                ERR("Unsupported location %s (%#x).\n", debug_surflocation(location), location);
+                ERR("Unsupported location %s (%#x).\n", wined3d_debug_location(location), location);
                 break;
         }
     }
@@ -276,7 +276,7 @@
             return;
         }
 
-        FIXME("\tLocation %s (%#x).\n", debug_surflocation(context->current_fbo->location),
+        FIXME("\tLocation %s (%#x).\n", wined3d_debug_location(context->current_fbo->location),
                 context->current_fbo->location);
 
         /* Dump the FBO attachments */
@@ -467,7 +467,7 @@
         context->rebind_fbo = FALSE;
     }
 
-    if (location == SFLAG_INDRAWABLE)
+    if (location == WINED3D_LOCATION_DRAWABLE)
     {
         context->current_fbo = NULL;
         context_bind_fbo(context, target, 0);
@@ -814,6 +814,8 @@
             context_set_current(NULL);
             return FALSE;
         }
+
+        ctx->valid = 1;
     }
     return TRUE;
 }
@@ -844,25 +846,9 @@
             context, context->win_handle, context->swapchain->win_handle);
 
     if (context->valid)
-    {
-        /* You'd figure ReleaseDC() would fail if the DC doesn't match the
-         * window. However, that's not what actually happens, and there are
-         * user32 tests that confirm ReleaseDC() with the wrong window is
-         * supposed to succeed. So explicitly check that the DC belongs to
-         * the window, since we want to avoid releasing a DC that belongs to
-         * some other window if the original window was already destroyed. */
-        if (WindowFromDC(context->hdc) != context->win_handle)
-        {
-            WARN("DC %p does not belong to window %p.\n",
-                    context->hdc, context->win_handle);
-        }
-        else if (!ReleaseDC(context->win_handle, context->hdc))
-        {
-            ERR("Failed to release device context %p, last error %#x.\n",
-                    context->hdc, GetLastError());
-        }
-    }
-    else context->valid = 1;
+        wined3d_release_dc(context->win_handle, context->hdc);
+    else
+        context->valid = 1;
 
     context->win_handle = context->swapchain->win_handle;
 
@@ -987,7 +973,7 @@
         ERR("Failed to disable GL context.\n");
     }
 
-    ReleaseDC(context->win_handle, context->hdc);
+    wined3d_release_dc(context->win_handle, context->hdc);
 
     if (!wglDeleteContext(context->glCtx))
     {
@@ -1120,15 +1106,17 @@
 }
 
 /* This function takes care of wined3d pixel format selection. */
-static int context_choose_pixel_format(const struct wined3d_device *device, HDC hdc,
-        const struct wined3d_format *color_format, const struct wined3d_format *ds_format,
+static int context_choose_pixel_format(const struct wined3d_device *device, const struct wined3d_swapchain *swapchain,
+        HDC hdc, const struct wined3d_format *color_format, const struct wined3d_format *ds_format,
         BOOL auxBuffers, BOOL findCompatible)
 {
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     int iPixelFormat=0;
     BYTE redBits, greenBits, blueBits, alphaBits, colorBits;
     BYTE depthBits=0, stencilBits=0;
     unsigned int current_value;
     unsigned int cfg_count = device->adapter->cfg_count;
+    BOOL double_buffer = TRUE;
     unsigned int i;
 
     TRACE("device %p, dc %p, color_format %s, ds_format %s, aux_buffers %#x, find_compatible %#x.\n",
@@ -1142,6 +1130,12 @@
         return 0;
     }
 
+    /* CrossOver hack for bug 9330. */
+    if ((gl_info->quirks & WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER)
+            && wined3d_settings.offscreen_rendering_mode == ORM_FBO
+            && !swapchain->desc.backbuffer_count)
+        double_buffer = FALSE;
+
     getDepthStencilBits(ds_format, &depthBits, &stencilBits);
 
     current_value = 0;
@@ -1155,7 +1149,7 @@
         if (cfg->iPixelType != WGL_TYPE_RGBA_ARB)
             continue;
         /* In window mode we need a window drawable format and double buffering. */
-        if (!(cfg->windowDrawable && cfg->doubleBuffer))
+        if (!cfg->windowDrawable || (double_buffer && !cfg->doubleBuffer))
             continue;
         if (cfg->redSize < redBits)
             continue;
@@ -1178,17 +1172,19 @@
          * depth it is no problem to emulate 16-bit using e.g. 24-bit, so accept that. */
         if (cfg->depthSize == depthBits)
             value += 1;
-        if (cfg->stencilSize == stencilBits)
+        if (!cfg->doubleBuffer == !double_buffer)
             value += 2;
-        if (cfg->alphaSize == alphaBits)
+        if (cfg->stencilSize == stencilBits)
             value += 4;
+        if (cfg->alphaSize == alphaBits)
+            value += 8;
         /* We like to have aux buffers in backbuffer mode */
         if (auxBuffers && cfg->auxBuffers)
-            value += 8;
+            value += 16;
         if (cfg->redSize == redBits
                 && cfg->greenSize == greenBits
                 && cfg->blueSize == blueBits)
-            value += 16;
+            value += 32;
 
         if (value > current_value)
         {
@@ -1209,7 +1205,9 @@
         ZeroMemory(&pfd, sizeof(pfd));
         pfd.nSize      = sizeof(pfd);
         pfd.nVersion   = 1;
-        pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER | PFD_DRAW_TO_WINDOW;/*PFD_GENERIC_ACCELERATED*/
+        pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;/*PFD_GENERIC_ACCELERATED*/
+        if (double_buffer)
+            pfd.dwFlags |= PFD_DOUBLEBUFFER;
         pfd.iPixelType = PFD_TYPE_RGBA;
         pfd.cAlphaBits = alphaBits;
         pfd.cColorBits = colorBits;
@@ -1350,6 +1348,14 @@
         goto out;
     }
 
+    ret->current_fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*ret->current_fb.render_targets) * gl_info->limits.buffers);
+    ret->current_fb.rt_size = gl_info->limits.buffers;
+    if (!ret->current_fb.render_targets)
+        goto out;
+    if (device->context_count)
+        ret->offscreenBuffer = device->contexts[0]->offscreenBuffer;
+
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -1400,13 +1406,13 @@
         color_format = wined3d_get_format(gl_info, WINED3DFMT_B8G8R8A8_UNORM);
 
     /* Try to find a pixel format which matches our requirements. */
-    pixel_format = context_choose_pixel_format(device, hdc, color_format, ds_format, auxBuffers, FALSE);
+    pixel_format = context_choose_pixel_format(device, swapchain, hdc, color_format, ds_format, auxBuffers, FALSE);
 
     /* Try to locate a compatible format if we weren't able to find anything. */
     if (!pixel_format)
     {
         TRACE("Trying to locate a compatible pixel format because an exact match failed.\n");
-        pixel_format = context_choose_pixel_format(device, hdc, color_format, ds_format, auxBuffers, TRUE);
+        pixel_format = context_choose_pixel_format(device, swapchain, hdc, color_format, ds_format, auxBuffers, TRUE);
     }
 
     /* If we still don't have a pixel format, something is very wrong as ChoosePixelFormat barely fails */
@@ -1660,6 +1666,7 @@
 
 out:
     device->shader_backend->shader_free_context_data(ret);
+    HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->draw_buffers);
@@ -1692,6 +1699,7 @@
     }
 
     device->shader_backend->shader_free_context_data(context);
+    HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2110,20 +2118,20 @@
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
-    surface_load_location(context->current_rt, SFLAG_INTEXTURE, NULL);
+    wined3d_resource_load_location(&context->current_rt->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
     context_set_render_offscreen(context, TRUE);
 }
 
-static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_device *device, const struct wined3d_surface *rt)
+static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_context *context, const struct wined3d_surface *rt)
 {
     if (!rt || rt->resource.format->id == WINED3DFMT_NULL)
         return 0;
     else if (rt->swapchain)
         return context_generate_rt_mask_from_surface(rt);
     else
-        return context_generate_rt_mask(device->offscreenBuffer);
+        return context_generate_rt_mask(context->offscreenBuffer);
 }
 
 /* Context activation is done by the caller. */
@@ -2155,7 +2163,7 @@
     }
     else
     {
-        rt_mask = context_generate_rt_mask_no_fbo(device, rt);
+        rt_mask = context_generate_rt_mask_no_fbo(context, rt);
     }
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
@@ -2201,7 +2209,7 @@
     UINT i;
     struct wined3d_surface **rts = fb->render_targets;
 
-    if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != &device->fb
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || !wined3d_fb_equal(fb, &context->current_fb)
             || rt_count != context->gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, fb->depth_stencil))
@@ -2225,11 +2233,11 @@
                     ++i;
                 }
                 context_apply_fbo_state(context, GL_FRAMEBUFFER, context->blit_targets, fb->depth_stencil,
-                        rt_count ? rts[0]->draw_binding : SFLAG_INTEXTURE);
+                        rt_count ? rts[0]->draw_binding : WINED3D_LOCATION_TEXTURE_RGB);
             }
             else
             {
-                context_apply_fbo_state(context, GL_FRAMEBUFFER, NULL, NULL, SFLAG_INDRAWABLE);
+                context_apply_fbo_state(context, GL_FRAMEBUFFER, NULL, NULL, WINED3D_LOCATION_DRAWABLE);
                 rt_mask = context_generate_rt_mask_from_surface(rts[0]);
             }
 
@@ -2240,8 +2248,10 @@
         }
         else
         {
-            rt_mask = context_generate_rt_mask_no_fbo(device, rt_count ? rts[0] : NULL);
+            rt_mask = context_generate_rt_mask_no_fbo(context, rt_count ? rts[0] : NULL);
         }
+
+        wined3d_fb_copy(&context->current_fb, fb);
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || surface_is_offscreen(rts[0])))
@@ -2253,7 +2263,7 @@
     }
     else
     {
-        rt_mask = context_generate_rt_mask_no_fbo(device, rt_count ? rts[0] : NULL);
+        rt_mask = context_generate_rt_mask_no_fbo(context, rt_count ? rts[0] : NULL);
     }
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
@@ -2287,16 +2297,17 @@
     return TRUE;
 }
 
-static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_device *device)
+static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
 {
-    const struct wined3d_state *state = &device->state;
-    struct wined3d_surface **rts = state->fb->render_targets;
+    struct wined3d_surface **rts = state->fb.render_targets;
     struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
 
-    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO) return context_generate_rt_mask_no_fbo(device, rts[0]);
-    else if (!context->render_offscreen) return context_generate_rt_mask_from_surface(rts[0]);
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
+        return context_generate_rt_mask_no_fbo(context, rts[0]);
+    else if (!context->render_offscreen)
+        return context_generate_rt_mask_from_surface(rts[0]);
 
     rt_mask = ps ? ps->reg_maps.rt_mask : 1;
     rt_mask &= context->d3d_info->valid_rt_mask;
@@ -2317,16 +2328,15 @@
 /* Context activation is done by the caller. */
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_device *device = context->swapchain->device;
-    const struct wined3d_fb_state *fb = state->fb;
-    DWORD rt_mask = find_draw_buffers_mask(context, device);
+    const struct wined3d_fb_state *fb = &state->fb;
+    DWORD rt_mask = find_draw_buffers_mask(context, state);
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
         if (!context->render_offscreen)
         {
-            context_apply_fbo_state(context, GL_FRAMEBUFFER, NULL, NULL, SFLAG_INDRAWABLE);
+            context_apply_fbo_state(context, GL_FRAMEBUFFER, NULL, NULL, WINED3D_LOCATION_DRAWABLE);
         }
         else
         {
@@ -2341,6 +2351,8 @@
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+
+    wined3d_fb_copy(&context->current_fb, &state->fb);
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -2578,13 +2590,12 @@
 /* Context activation is done by the caller. */
 void context_state_drawbuf(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_device *device = context->swapchain->device;
     DWORD rt_mask, *cur_mask;
 
     if (isStateDirty(context, STATE_FRAMEBUFFER)) return;
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
-    rt_mask = find_draw_buffers_mask(context, device);
+    rt_mask = find_draw_buffers_mask(context, state);
     if (rt_mask != *cur_mask)
     {
         context_apply_draw_buffers(context, rt_mask);
@@ -2660,7 +2671,7 @@
          * (or rather offsets bigger than the vbo, because the pointer is unsigned), so use system memory
          * sources. In most sane cases the pointer - offset will still be > 0, otherwise it will wrap
          * around to some big value. Hope that with the indices, the driver wraps it back internally. If
-         * not, drawStridedSlow is needed, including a vertex buffer path. */
+         * not, draw_strided_slow is needed, including a vertex buffer path. */
         if (state->load_base_vertex_index < 0)
         {
             WARN_(d3d_perf)("load_base_vertex_index is < 0 (%d), not using VBOs.\n",
@@ -2775,7 +2786,7 @@
     {
         if (state->vertex_declaration->half_float_conv_needed && !stream_info->all_vbo)
         {
-            TRACE("Using drawStridedSlow with vertex shaders for FLOAT16 conversion.\n");
+            TRACE("Using draw_strided_slow with vertex shaders for FLOAT16 conversion.\n");
             context->use_immediate_mode_draw = TRUE;
         }
         else
@@ -2849,11 +2860,11 @@
 }
 
 /* Context activation is done by the caller. */
-BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device)
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state)
 {
-    const struct wined3d_state *state = &device->state;
     const struct StateEntry *state_table = context->state_table;
-    const struct wined3d_fb_state *fb = state->fb;
+    const struct wined3d_fb_state *fb = &state->fb;
     unsigned int i;
 
     if (!context_validate_rt_config(context->gl_info->limits.buffers,
@@ -2872,6 +2883,15 @@
     context_preload_textures(context, state);
     if (isStateDirty(context, STATE_VDECL) || isStateDirty(context, STATE_STREAMSRC))
         context_update_stream_info(context, state);
+    else
+    {
+        for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        {
+            if (state->streams[i].buffer)
+                buffer_internal_preload(state->streams[i].buffer, context, state);
+        }
+    }
+
     if (state->index_buffer)
     {
         if (context->stream_info.all_vbo)
@@ -2944,8 +2964,8 @@
 
         /* When switching away from an offscreen render target, and we're not
          * using FBOs, we have to read the drawable into the texture. This is
-         * done via PreLoad (and SFLAG_INDRAWABLE set on the surface). There
-         * are some things that need care though. PreLoad needs a GL context,
+         * done via PreLoad (and WINED3D_LOCATION_DRAWABLE set on the surface).
+         * There are some things that need care though. PreLoad needs a GL context,
          * and FindContext is called before the context is activated. It also
          * has to be called with the old rendertarget active, otherwise a
          * wrong drawable is read. */
@@ -2956,7 +2976,7 @@
             if (context->current_rt->texture_name_srgb)
                 surface_internal_preload(context->current_rt, context, SRGB_SRGB);
             surface_internal_preload(context->current_rt, context, SRGB_RGB);
-            surface_invalidate_location(context->current_rt, SFLAG_INDRAWABLE);
+            wined3d_resource_invalidate_location(&context->current_rt->resource, WINED3D_LOCATION_DRAWABLE);
         }
     }
 
diff -Naur a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/cs.c	2013-11-07 21:40:10.000000000 +0000
@@ -22,10 +22,11 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
-#define WINED3D_INITIAL_CS_SIZE 4096
-
 enum wined3d_cs_op
 {
+    WINED3D_CS_OP_NOP,
+    WINED3D_CS_OP_SKIP,
+    WINED3D_CS_OP_FENCE,
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -48,28 +49,83 @@
     WINED3D_CS_OP_SET_TRANSFORM,
     WINED3D_CS_OP_SET_CLIP_PLANE,
     WINED3D_CS_OP_SET_MATERIAL,
+    WINED3D_CS_OP_SET_VS_CONSTS_F,
+    WINED3D_CS_OP_SET_VS_CONSTS_B,
+    WINED3D_CS_OP_SET_VS_CONSTS_I,
+    WINED3D_CS_OP_SET_PS_CONSTS_F,
+    WINED3D_CS_OP_SET_PS_CONSTS_B,
+    WINED3D_CS_OP_SET_PS_CONSTS_I,
+    WINED3D_CS_OP_RESET_STATE,
+    WINED3D_CS_OP_GLFINISH,
+    WINED3D_CS_OP_SET_BASE_VERTEX_INDEX,
+    WINED3D_CS_OP_SET_PRIMITIVE_TYPE,
+    WINED3D_CS_OP_SET_LIGHT,
+    WINED3D_CS_OP_SET_LIGHT_ENABLE,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_COLOR_FILL,
+    WINED3D_CS_OP_RESOURCE_MAP,
+    WINED3D_CS_OP_RESOURCE_UNMAP,
+    WINED3D_CS_OP_RESOURCE_CHANGED,
+    WINED3D_CS_OP_SWAP_MEM,
+    WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE,
+    WINED3D_CS_OP_QUERY_ISSUE,
+    WINED3D_CS_OP_QUERY_DESTROY,
+    WINED3D_CS_OP_BUFFER_PRELOAD,
+    WINED3D_CS_OP_VDECL_DESTROY,
+    WINED3D_CS_OP_SHADER_CLEANUP,
+    WINED3D_CS_OP_UPDATE_SURFACE,
+    WINED3D_CS_OP_TEXTURE_PRELOAD,
+    WINED3D_CS_OP_SURFACE_PRELOAD,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_EVICT_RESOURCE,
+    WINED3D_CS_OP_SURFACE_FLIP,
+    WINED3D_CS_OP_CREATE_VBO,
+    WINED3D_CS_OP_RESOURCE_CLEANUP,
+    WINED3D_CS_OP_BUFFER_CLEANUP,
+    WINED3D_CS_OP_VOLUME_CLEANUP,
+    WINED3D_CS_OP_SURFACE_CLEANUP,
+    WINED3D_CS_OP_TEXTURE_CLEANUP,
+    WINED3D_CS_OP_CREATE_DUMMY_TEXTURES,
+    WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT,
+    WINED3D_CS_OP_DELETE_GL_CONTEXTS,
+    WINED3D_CS_OP_STOP,
+};
+
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
 };
 
+struct wined3d_cs_fence
+{
+    enum wined3d_cs_op opcode;
+    BOOL *signalled;
+};
+
+#define CS_PRESENT_SRC_RECT 1
+#define CS_PRESENT_DST_RECT 2
+#define CS_PRESENT_DIRTY_RGN 4
 struct wined3d_cs_present
 {
     enum wined3d_cs_op opcode;
     HWND dst_window_override;
     struct wined3d_swapchain *swapchain;
-    const RECT *src_rect;
-    const RECT *dst_rect;
-    const RGNDATA *dirty_region;
+    RECT src_rect;
+    RECT dst_rect;
+    RGNDATA dirty_region;
     DWORD flags;
+    DWORD set_data;
 };
 
 struct wined3d_cs_clear
 {
     enum wined3d_cs_op opcode;
     DWORD rect_count;
-    const RECT *rects;
     DWORD flags;
-    const struct wined3d_color *color;
+    struct wined3d_color color;
     float depth;
     DWORD stencil;
+    RECT rects[1];
 };
 
 struct wined3d_cs_draw
@@ -85,13 +141,13 @@
 struct wined3d_cs_set_viewport
 {
     enum wined3d_cs_op opcode;
-    const struct wined3d_viewport *viewport;
+    struct wined3d_viewport viewport;
 };
 
 struct wined3d_cs_set_scissor_rect
 {
     enum wined3d_cs_op opcode;
-    const RECT *rect;
+    RECT rect;
 };
 
 struct wined3d_cs_set_render_target
@@ -202,620 +258,2260 @@
 {
     enum wined3d_cs_op opcode;
     enum wined3d_transform_state state;
-    const struct wined3d_matrix *matrix;
+    struct wined3d_matrix matrix;
 };
 
 struct wined3d_cs_set_clip_plane
 {
     enum wined3d_cs_op opcode;
     UINT plane_idx;
-    const struct wined3d_vec4 *plane;
+    struct wined3d_vec4 plane;
 };
 
 struct wined3d_cs_set_material
 {
     enum wined3d_cs_op opcode;
-    const struct wined3d_material *material;
+    struct wined3d_material material;
 };
 
-static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_set_consts_f
 {
-    const struct wined3d_cs_present *op = data;
-    struct wined3d_swapchain *swapchain;
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4f_count;
+    float constants[4];
+};
 
-    swapchain = op->swapchain;
-    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+struct wined3d_cs_set_consts_b
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, bool_count;
+    BOOL constants[1];
+};
 
-    swapchain->swapchain_ops->swapchain_present(swapchain,
-            op->src_rect, op->dst_rect, op->dirty_region, op->flags);
-}
+struct wined3d_cs_set_consts_i
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4i_count;
+    int constants[4];
+};
 
-void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
-        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
-        const RGNDATA *dirty_region, DWORD flags)
+struct wined3d_cs_reset_state
 {
-    struct wined3d_cs_present *op;
+    enum wined3d_cs_op opcode;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_PRESENT;
-    op->dst_window_override = dst_window_override;
-    op->swapchain = swapchain;
-    op->src_rect = src_rect;
-    op->dst_rect = dst_rect;
-    op->dirty_region = dirty_region;
-    op->flags = flags;
+struct wined3d_cs_finish
+{
+    enum wined3d_cs_op opcode;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_set_base_vertex_index
+{
+    enum wined3d_cs_op opcode;
+    UINT base_vertex_index;
+};
 
-static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_set_primitive_type
 {
-    const struct wined3d_cs_clear *op = data;
-    struct wined3d_device *device;
-    RECT draw_rect;
+    enum wined3d_cs_op opcode;
+    GLenum gl_primitive_type;
+};
 
-    device = cs->device;
-    wined3d_get_draw_rect(&device->state, &draw_rect);
-    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
-            &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
-            op->color, op->depth, op->stencil);
-}
+struct wined3d_cs_set_light
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_light_info light;
+};
 
-void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
-        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+struct wined3d_cs_set_light_enable
 {
-    struct wined3d_cs_clear *op;
+    enum wined3d_cs_op opcode;
+    UINT idx;
+    BOOL enable;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_CLEAR;
-    op->rect_count = rect_count;
-    op->rects = rects;
-    op->flags = flags;
-    op->color = color;
-    op->depth = depth;
-    op->stencil = stencil;
+struct wined3d_cs_blt
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    WINEDDBLTFX fx;
+    enum wined3d_texture_filter_type filter;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_color_fill
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+    RECT rect;
+    struct wined3d_color color;
+};
 
-static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_resource_map
 {
-    const struct wined3d_cs_draw *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    DWORD flags;
+    void **mem;
+};
 
-    draw_primitive(cs->device, op->start_idx, op->index_count,
-            op->start_instance, op->instance_count, op->indexed);
-}
+struct wined3d_cs_resource_unmap
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed)
+struct wined3d_cs_resource_changed
 {
-    struct wined3d_cs_draw *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    struct wined3d_gl_bo *swap_buffer;
+    void *swap_heap_memory;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_DRAW;
-    op->start_idx = start_idx;
-    op->index_count = index_count;
-    op->start_instance = start_instance;
-    op->instance_count = instance_count;
-    op->indexed = indexed;
+struct wined3d_cs_skip
+{
+    enum wined3d_cs_op opcode;
+    DWORD size;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_swap_mem
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    BYTE *mem;
+};
 
-static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_buffer_invalidate_bo_range
 {
-    const struct wined3d_cs_set_viewport *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    UINT offset, size;
+};
 
-    cs->state.viewport = *op->viewport;
-    device_invalidate_state(cs->device, STATE_VIEWPORT);
-}
+struct wined3d_cs_query_issue
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+    DWORD flags;
+};
 
-void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
+struct wined3d_cs_query_destroy
 {
-    struct wined3d_cs_set_viewport *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
-    op->viewport = viewport;
+struct wined3d_cs_buffer_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_vertex_declaration_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_vertex_declaration *declaration;
+};
 
-static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_shader_cleanup
 {
-    const struct wined3d_cs_set_scissor_rect *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_shader *shader;
+};
 
-    cs->state.scissor_rect = *op->rect;
-    device_invalidate_state(cs->device, STATE_SCISSORRECT);
-}
+struct wined3d_cs_update_surface
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *src, *dst;
+    RECT src_rect;
+    POINT dst_point;
+    BOOL has_src_rect, has_dst_point;
+};
 
-void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
+struct wined3d_cs_texture_preload
 {
-    struct wined3d_cs_set_scissor_rect *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
-    op->rect = rect;
+struct wined3d_cs_surface_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
 
-static void wined3d_cs_exec_set_render_target(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_evict_resource
 {
-    const struct wined3d_cs_set_render_target *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-    cs->state.fb->render_targets[op->render_target_idx] = op->render_target;
-    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
-}
+struct wined3d_cs_surface_flip
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface, *override;
+};
 
-void wined3d_cs_emit_set_render_target(struct wined3d_cs *cs, UINT render_target_idx,
-        struct wined3d_surface *render_target)
+struct wined3d_cs_create_vbo
 {
-    struct wined3d_cs_set_render_target *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_RENDER_TARGET;
-    op->render_target_idx = render_target_idx;
-    op->render_target = render_target;
+struct wined3d_cs_resource_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_buffer_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-static void wined3d_cs_exec_set_depth_stencil(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_volume_cleanup
 {
-    const struct wined3d_cs_set_depth_stencil *op = data;
-    struct wined3d_device *device = cs->device;
-    struct wined3d_surface *prev;
+    enum wined3d_cs_op opcode;
+    struct wined3d_volume *volume;
+};
 
-    if ((prev = cs->state.fb->depth_stencil))
-    {
-        if (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
-                || prev->flags & SFLAG_DISCARD)
-        {
-            surface_modify_ds_location(prev, SFLAG_DISCARDED,
-                    prev->resource.width, prev->resource.height);
-            if (prev == device->onscreen_depth_stencil)
-            {
-                wined3d_surface_decref(device->onscreen_depth_stencil);
-                device->onscreen_depth_stencil = NULL;
-            }
-        }
-    }
+struct wined3d_cs_surface_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-    cs->fb.depth_stencil = op->depth_stencil;
+struct wined3d_cs_texture_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
 
-    if (!prev != !op->depth_stencil)
-    {
-        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
-    }
-    else if (prev && prev->resource.format->depth_size != op->depth_stencil->resource.format->depth_size)
-    {
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
-    }
+struct wined3d_cs_create_dummy_textures
+{
+    enum wined3d_cs_op opcode;
+};
 
-    device_invalidate_state(device, STATE_FRAMEBUFFER);
-}
+struct wined3d_cs_create_swapchain_context
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+    HRESULT *ret;
+};
 
-void wined3d_cs_emit_set_depth_stencil(struct wined3d_cs *cs, struct wined3d_surface *depth_stencil)
+struct wined3d_cs_delete_gl_contexts
 {
-    struct wined3d_cs_set_depth_stencil *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL;
-    op->depth_stencil = depth_stencil;
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->queue.head, new_val);
 
-    cs->ops->submit(cs);
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
 }
 
-static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+static void wined3d_cs_mt_submit_prio(struct wined3d_cs *cs, size_t size)
 {
-    const struct wined3d_cs_set_vertex_declaration *op = data;
+    LONG new_val = (cs->prio_queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->prio_queue.head, new_val);
 
-    cs->state.vertex_declaration = op->declaration;
-    device_invalidate_state(cs->device, STATE_VDECL);
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
 }
 
-void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+static UINT wined3d_cs_exec_nop(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_cs_set_vertex_declaration *op;
+    return sizeof(enum wined3d_cs_op);
+}
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
-    op->declaration = declaration;
+static UINT wined3d_cs_exec_skip(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_skip *op = data;
 
-    cs->ops->submit(cs);
+    return op->size;
 }
 
-static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_fence(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_stream_source *op = data;
-    struct wined3d_stream_state *stream;
-    struct wined3d_buffer *prev;
-
-    stream = &cs->state.streams[op->stream_idx];
-    prev = stream->buffer;
-    stream->buffer = op->buffer;
-    stream->offset = op->offset;
-    stream->stride = op->stride;
+    const struct wined3d_cs_fence *op = data;
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    InterlockedExchange(op->signalled, TRUE);
 
-    device_invalidate_state(cs->device, STATE_STREAMSRC);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
-        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+static void wined3d_cs_emit_fence(struct wined3d_cs *cs, BOOL *signalled)
 {
-    struct wined3d_cs_set_stream_source *op;
+    struct wined3d_cs_fence *op;
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
-    op->stream_idx = stream_idx;
-    op->buffer = buffer;
-    op->offset = offset;
-    op->stride = stride;
+    *signalled = FALSE;
 
-    cs->ops->submit(cs);
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+static void wined3d_cs_emit_fence_prio(struct wined3d_cs *cs, BOOL *signalled)
 {
-    const struct wined3d_cs_set_stream_source_freq *op = data;
-    struct wined3d_stream_state *stream;
+    struct wined3d_cs_fence *op;
 
-    stream = &cs->state.streams[op->stream_idx];
-    stream->frequency = op->frequency;
+    *signalled = FALSE;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static void wined3d_cs_surface_dec_fence(struct wined3d_surface *surface)
+{
+    if (surface->container)
+        wined3d_resource_dec_fence(&surface->container->resource);
+    else
+        wined3d_resource_dec_fence(&surface->resource);
+}
+
+static void wined3d_cs_surface_inc_fence(struct wined3d_surface *surface)
+{
+    if (surface->container)
+        wined3d_resource_inc_fence(&surface->container->resource);
+    else
+        wined3d_resource_inc_fence(&surface->resource);
+}
+
+static UINT wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_present *op = data;
+    struct wined3d_swapchain *swapchain;
+    const RECT *src_rect = op->set_data & CS_PRESENT_SRC_RECT ? &op->src_rect : NULL;
+    const RECT *dst_rect = op->set_data & CS_PRESENT_DST_RECT ? &op->dst_rect : NULL;
+    const RGNDATA *dirty_region = op->set_data & CS_PRESENT_DIRTY_RGN ? &op->dirty_region : NULL;
+    unsigned int i;
+
+    swapchain = op->swapchain;
+    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+
+    swapchain->swapchain_ops->swapchain_present(swapchain,
+            src_rect, dst_rect, dirty_region, op->flags,
+            cs->state.fb.depth_stencil);
+
+    InterlockedDecrement(&cs->pending_presents);
+
+    wined3d_cs_surface_dec_fence(swapchain->front_buffer);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_cs_surface_dec_fence(swapchain->back_buffers[i]);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
+        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
+        const RGNDATA *dirty_region, DWORD flags)
+{
+    struct wined3d_cs_present *op;
+    LONG pending;
+    unsigned int i;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_PRESENT;
+    op->dst_window_override = dst_window_override;
+    op->swapchain = swapchain;
+    op->set_data = 0;
+    if (src_rect)
+    {
+        op->src_rect = *src_rect;
+        op->set_data |= CS_PRESENT_SRC_RECT;
+    }
+    if (dst_rect)
+    {
+        op->dst_rect = *dst_rect;
+        op->set_data |= CS_PRESENT_DST_RECT;
+    }
+    if (dirty_region)
+    {
+        op->dirty_region = *dirty_region;
+        op->set_data = CS_PRESENT_DIRTY_RGN;
+    }
+    op->flags = flags;
+
+    wined3d_cs_surface_inc_fence(swapchain->front_buffer);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_cs_surface_inc_fence(swapchain->back_buffers[i]);
+
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs, sizeof(*op));
+
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+}
+
+static UINT wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear *op = data;
+    struct wined3d_device *device;
+    RECT draw_rect;
+    unsigned int extra_rects = op->rect_count ? op->rect_count - 1 : 0, i;
+
+    device = cs->device;
+    wined3d_get_draw_rect(&cs->state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &cs->state.fb, op->rect_count, op->rect_count ? op->rects : NULL, &draw_rect, op->flags,
+            &op->color, op->depth, op->stencil);
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+        {
+            if (cs->state.fb.render_targets[i])
+                wined3d_cs_surface_dec_fence(cs->state.fb.render_targets[i]);
+        }
+    }
+    if (op->flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_cs_surface_dec_fence(cs->state.fb.depth_stencil);
+
+    return sizeof(*op) + sizeof(*op->rects) * extra_rects;
+}
+
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+{
+    struct wined3d_cs_clear *op;
+    unsigned int extra_rects = rect_count ? rect_count - 1 : 0, i;
+    size_t size = sizeof(*op) + sizeof(*op->rects) * extra_rects;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, size);
+    op->opcode = WINED3D_CS_OP_CLEAR;
+    op->rect_count = rect_count;
+    if (rect_count)
+        memcpy(op->rects, rects, rect_count * sizeof(*rects));
+    op->flags = flags;
+    op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+
+    if (flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+        {
+            if (state->fb.render_targets[i])
+                wined3d_cs_surface_inc_fence(state->fb.render_targets[i]);
+        }
+    }
+    if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_cs_surface_inc_fence(state->fb.depth_stencil);
+
+    cs->ops->submit(cs, size);
+}
+
+static inline BOOL wined3d_cs_colorwrite_enabled(const struct wined3d_state *state, unsigned int i)
+{
+    switch (i)
+    {
+        case 0:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE];
+        case 1:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE1];
+        case 2:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE2];
+        case 3:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE3];
+        default:
+            ERR("Unexpected color target %u.\n", i);
+            return TRUE;
+    }
+}
+
+static inline BOOL wined3d_cs_depth_stencil_enabled(const struct wined3d_state *state)
+{
+    return state->render_states[WINED3D_RS_ZENABLE]
+            || state->render_states[WINED3D_RS_STENCILENABLE];
+}
+
+static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_draw *op = data;
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
+    unsigned int i;
+
+    if (op->indexed && !gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX])
+    {
+        if (cs->state.load_base_vertex_index != cs->state.base_vertex_index)
+        {
+            cs->state.load_base_vertex_index = cs->state.base_vertex_index;
+            device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+        }
+    }
+    else if (cs->state.load_base_vertex_index)
+    {
+        cs->state.load_base_vertex_index = 0;
+        device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+    }
+
+    draw_primitive(cs->device, &cs->state, op->start_idx, op->index_count,
+            op->start_instance, op->instance_count, op->indexed);
+
+    if (op->indexed)
+        wined3d_resource_dec_fence(&cs->state.index_buffer->resource);
+    for (i = 0; i < sizeof(cs->state.streams) / sizeof(*cs->state.streams); i++)
+    {
+        if (cs->state.streams[i].buffer)
+            wined3d_resource_dec_fence(&cs->state.streams[i].buffer->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.textures) / sizeof(*cs->state.textures); i++)
+    {
+        if (cs->state.textures[i])
+            wined3d_resource_dec_fence(&cs->state.textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+    {
+        if (cs->state.fb.render_targets[i] && wined3d_cs_colorwrite_enabled(&cs->state, i))
+            wined3d_cs_surface_dec_fence(cs->state.fb.render_targets[i]);
+    }
+    if (cs->state.fb.depth_stencil && wined3d_cs_depth_stencil_enabled(&cs->state))
+        wined3d_cs_surface_dec_fence(cs->state.fb.depth_stencil);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
+        UINT start_instance, UINT instance_count, BOOL indexed)
+{
+    struct wined3d_cs_draw *op;
+    unsigned int i;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DRAW;
+    op->start_idx = start_idx;
+    op->index_count = index_count;
+    op->start_instance = start_instance;
+    op->instance_count = instance_count;
+    op->indexed = indexed;
+
+    if (indexed)
+        wined3d_resource_inc_fence(&state->index_buffer->resource);
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+    {
+        if (state->streams[i].buffer)
+            wined3d_resource_inc_fence(&state->streams[i].buffer->resource);
+    }
+    for (i = 0; i < sizeof(state->textures) / sizeof(*state->textures); i++)
+    {
+        if (state->textures[i])
+            wined3d_resource_inc_fence(&state->textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+    {
+        if (state->fb.render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
+            wined3d_cs_surface_inc_fence(state->fb.render_targets[i]);
+    }
+    if (state->fb.depth_stencil && wined3d_cs_depth_stencil_enabled(state))
+        wined3d_cs_surface_inc_fence(state->fb.depth_stencil);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_viewport *op = data;
+    struct wined3d_device *device = cs->device;
+
+    cs->state.viewport = op->viewport;
+    device_invalidate_state(device, STATE_VIEWPORT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
+{
+    struct wined3d_cs_set_viewport *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
+    op->viewport = *viewport;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_scissor_rect *op = data;
+
+    cs->state.scissor_rect = op->rect;
+    device_invalidate_state(cs->device, STATE_SCISSORRECT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
+{
+    struct wined3d_cs_set_scissor_rect *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
+    op->rect = *rect;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_render_target(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_target *op = data;
+
+    cs->state.fb.render_targets[op->render_target_idx] = op->render_target;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_render_target(struct wined3d_cs *cs, UINT render_target_idx,
+        struct wined3d_surface *render_target)
+{
+    struct wined3d_cs_set_render_target *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDER_TARGET;
+    op->render_target_idx = render_target_idx;
+    op->render_target = render_target;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_depth_stencil(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_depth_stencil *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_surface *prev;
+
+    if ((prev = cs->state.fb.depth_stencil))
+    {
+        if (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || prev->flags & SFLAG_DISCARD)
+        {
+            surface_modify_ds_location(prev, WINED3D_LOCATION_DISCARDED,
+                    prev->resource.width, prev->resource.height);
+            if (prev == cs->onscreen_depth_stencil)
+            {
+                wined3d_surface_decref(cs->onscreen_depth_stencil);
+                cs->onscreen_depth_stencil = NULL;
+            }
+        }
+    }
+
+    cs->state.fb.depth_stencil = op->depth_stencil;
+
+    if (!prev != !op->depth_stencil)
+    {
+        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+    else if (prev && prev->resource.format->depth_size != op->depth_stencil->resource.format->depth_size)
+    {
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+
+    device_invalidate_state(device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_depth_stencil(struct wined3d_cs *cs, struct wined3d_surface *depth_stencil)
+{
+    struct wined3d_cs_set_depth_stencil *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL;
+    op->depth_stencil = depth_stencil;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_vertex_declaration *op = data;
+
+    cs->state.vertex_declaration = op->declaration;
+    device_invalidate_state(cs->device, STATE_VDECL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_set_vertex_declaration *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source *op = data;
+    struct wined3d_stream_state *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.streams[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+    stream->stride = op->stride;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+{
+    struct wined3d_cs_set_stream_source *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->stride = stride;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source_freq *op = data;
+    struct wined3d_stream_state *stream;
+
+    stream = &cs->state.streams[op->stream_idx];
+    stream->frequency = op->frequency;
     stream->flags = op->flags;
 
-    device_invalidate_state(cs->device, STATE_STREAMSRC);
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+{
+    struct wined3d_cs_set_stream_source_freq *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
+    op->stream_idx = stream_idx;
+    op->frequency = frequency;
+    op->flags = flags;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_output *op = data;
+    struct wined3d_stream_output *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.stream_output[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset)
+{
+    struct wined3d_cs_set_stream_output *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_index_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.index_buffer;
+    cs->state.index_buffer = op->buffer;
+    cs->state.index_format = op->format_id;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        enum wined3d_format_id format_id)
+{
+    struct wined3d_cs_set_index_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
+    op->buffer = buffer;
+    op->format_id = format_id;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_constant_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.cb[op->type][op->cb_idx];
+    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT cb_idx, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_set_constant_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
+    op->type = type;
+    op->cb_idx = cb_idx;
+    op->buffer = buffer;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
+    const struct wined3d_cs_set_texture *op = data;
+    struct wined3d_texture *prev;
+
+    prev = cs->state.textures[op->stage];
+    cs->state.textures[op->stage] = op->texture;
+
+    if (op->texture)
+    {
+        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
+            op->texture->sampler = op->stage;
+
+        if (!prev || op->texture->target != prev->target)
+            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+
+        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            /* The source arguments for color and alpha ops have different
+             * meanings when a NULL texture is bound, so the COLOR_OP and
+             * ALPHA_OP have to be dirtified. */
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+    }
+
+    if (prev)
+    {
+        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
+        {
+            unsigned int i;
+
+            /* Search for other stages the texture is bound to. Shouldn't
+             * happen if applications bind textures to a single stage only. */
+            TRACE("Searching for other stages the texture is bound to.\n");
+            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
+            {
+                if (cs->state.textures[i] == prev)
+                {
+                    TRACE("Texture is also bound to stage %u.\n", i);
+                    prev->sampler = i;
+                    break;
+                }
+            }
+        }
+
+        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+    }
+
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_set_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
+    op->stage = stage;
+    op->texture = texture;
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler *op = data;
+
+    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT sampler_idx, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_set_sampler *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
+    op->type = type;
+    op->sampler_idx = sampler_idx;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader *op = data;
+
+    cs->state.shader[op->type] = op->shader;
+    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_set_shader *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER;
+    op->type = type;
+    op->shader = shader;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.vs_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.vs_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_vertex_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.ps_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.ps_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_pixel_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register,
+        const float *constants, UINT vector4f_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_f *op;
+    UINT extra_space = vector4f_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4f_count = vector4f_count;
+    memcpy(op->constants, constants, sizeof(*constants) * 4 * vector4f_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_state *op = data;
+
+    cs->state.render_states[op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+{
+    struct wined3d_cs_set_render_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.vs_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.ps_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_b *op;
+    UINT extra_space = bool_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->bool_count = bool_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * bool_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_i[op->start_register], op->constants,
+            sizeof(*cs->state.vs_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_i[op->start_register], op->constants,
+            sizeof(*cs->state.ps_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_i *op;
+    UINT extra_space = vector4i_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            ERR("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4i_count = vector4i_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * vector4i_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_texture_state *op = data;
+
+    cs->state.texture_states[op->stage][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
+        enum wined3d_texture_stage_state state, DWORD value)
+{
+    struct wined3d_cs_set_texture_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
+    op->stage = stage;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler_state *op = data;
+
+    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
+        enum wined3d_sampler_state state, DWORD value)
+{
+    struct wined3d_cs_set_sampler_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
+    op->sampler_idx = sampler_idx;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_transform *op = data;
+
+    cs->state.transforms[op->state] = op->matrix;
+    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->gl_info.limits.blends))
+        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
+        const struct wined3d_matrix *matrix)
+{
+    struct wined3d_cs_set_transform *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
+    op->state = state;
+    op->matrix = *matrix;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_clip_plane *op = data;
+
+    cs->state.clip_planes[op->plane_idx] = op->plane;
+    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+{
+    struct wined3d_cs_set_clip_plane *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
+    op->plane_idx = plane_idx;
+    op->plane = *plane;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_material *op = data;
+
+    cs->state.material = op->material;
+    device_invalidate_state(cs->device, STATE_MATERIAL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+{
+    struct wined3d_cs_set_material *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
+    op->material = *material;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_reset_state *op = data;
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
+    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
+
+    state_cleanup(&cs->state);
+    state_init(&cs->state, gl_info, d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_reset_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESET_STATE;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_finish *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_context *context;
+
+    if (!device->d3d_initialized)
+        return sizeof(*op);
+
+    context = context_acquire(device, NULL);
+    context->gl_info->gl_ops.gl.p_glFinish();
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_base_vertex_index(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_base_vertex_index *op = data;
+
+    cs->state.base_vertex_index = op->base_vertex_index;
+    device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index)
+{
+    struct wined3d_cs_set_base_vertex_index *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_BASE_VERTEX_INDEX;
+    op->base_vertex_index = base_vertex_index;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_primitive_type(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_primitive_type *op = data;
+    GLenum prev;
+
+    prev = cs->state.gl_primitive_type;
+
+    if (op->gl_primitive_type == GL_POINTS || prev == GL_POINTS)
+        device_invalidate_state(cs->device, STATE_POINT_SIZE_ENABLE);
+
+    cs->state.gl_primitive_type = op->gl_primitive_type;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type)
+{
+    struct wined3d_cs_set_primitive_type *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PRIMITIVE_TYPE;
+    op->gl_primitive_type = primitive_type;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light *op = data;
+
+    UINT light_idx = op->light.OriginalIndex;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->light.OriginalIndex);
+    struct wined3d_light_info *object = NULL;
+    struct list *e;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        object = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (object->OriginalIndex == light_idx)
+            break;
+        object = NULL;
+    }
+
+    if (!object)
+    {
+        TRACE("Adding new light\n");
+        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+        if (!object)
+            return E_OUTOFMEMORY;
+
+        list_add_head(&cs->state.light_map[hash_idx], &object->entry);
+        object->glIndex = -1;
+        object->OriginalIndex = light_idx;
+    }
+
+    object->OriginalParms = op->light.OriginalParms;
+    memcpy(object->lightPosn, op->light.lightPosn, sizeof(object->lightPosn));
+    memcpy(object->lightDirn, op->light.lightDirn, sizeof(object->lightDirn));
+    object->exponent = op->light.exponent;
+    object->cutoff = op->light.cutoff;
+
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1)
+    {
+        if (object->OriginalParms.type != op->light.OriginalParms.type)
+            device_invalidate_state(cs->device, STATE_LIGHT_TYPE);
+        device_invalidate_state(cs->device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
+{
+    struct wined3d_cs_set_light *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT;
+    op->light = *light;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light_enable *op = data;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->idx);
+    struct wined3d_light_info *light_info = NULL;
+    struct list *e;
+    struct wined3d_device *device = cs->device;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        light_info = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (light_info->OriginalIndex == op->idx)
+            break;
+        light_info = NULL;
+    }
+    TRACE("Found light %p.\n", light_info);
+
+    /* Should be handled by the device by emitting a set_light op */
+    if (!light_info)
+    {
+        ERR("Light enabled requested but light not defined in cs state!\n");
+        return sizeof(*op);
+    }
+
+    if (!op->enable)
+    {
+        if (light_info->glIndex != -1)
+        {
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            cs->state.lights[light_info->glIndex] = NULL;
+            light_info->glIndex = -1;
+        }
+        else
+        {
+            TRACE("Light already disabled, nothing to do\n");
+        }
+        light_info->enabled = FALSE;
+    }
+    else
+    {
+        light_info->enabled = TRUE;
+        if (light_info->glIndex != -1)
+        {
+            TRACE("Nothing to do as light was enabled\n");
+        }
+        else
+        {
+            unsigned int i;
+            const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+            /* Find a free GL light. */
+            for (i = 0; i < gl_info->limits.lights; ++i)
+            {
+                if (!cs->state.lights[i])
+                {
+                    cs->state.lights[i] = light_info;
+                    light_info->glIndex = i;
+                    break;
+                }
+            }
+            if (light_info->glIndex == -1)
+            {
+                /* Should be caught by the device before emitting
+                 * the light_enable op */
+                ERR("Too many concurrently active lights in cs\n");
+                return sizeof(*op);
+            }
+
+            /* i == light_info->glIndex */
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+        }
+    }
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable)
 {
-    struct wined3d_cs_set_stream_source_freq *op;
+    struct wined3d_cs_set_light_enable *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
-    op->stream_idx = stream_idx;
-    op->frequency = frequency;
+    op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
+    op->idx = idx;
+    op->enable = enable;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect,
+            op->src_surface, &op->src_rect,
+            op->flags, &op->fx, op->filter);
+
+    wined3d_cs_surface_dec_fence(op->dst_surface);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_cs_surface_dec_fence(op->src_surface);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
     op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
 
-    cs->ops->submit(cs);
+    wined3d_cs_surface_inc_fence(dst_surface);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_cs_surface_inc_fence(src_surface);
+
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_color_fill(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_stream_output *op = data;
-    struct wined3d_stream_output *stream;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_color_fill *op = data;
 
-    stream = &cs->state.stream_output[op->stream_idx];
-    prev = stream->buffer;
-    stream->buffer = op->buffer;
-    stream->offset = op->offset;
+    surface_color_fill(op->surface, &op->rect, &op->color);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    wined3d_cs_surface_dec_fence(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
-        struct wined3d_buffer *buffer, UINT offset)
+void wined3d_cs_emit_color_fill(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        const RECT *rect, const struct wined3d_color *color)
 {
-    struct wined3d_cs_set_stream_output *op;
+    struct wined3d_cs_color_fill *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
-    op->stream_idx = stream_idx;
+    op->opcode = WINED3D_CS_OP_COLOR_FILL;
+    op->surface = surface;
+    op->rect = *rect;
+    op->color = *color;
+
+    wined3d_cs_surface_inc_fence(surface);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_resource_map(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_map *op = data;
+
+    *op->mem = wined3d_resource_map_internal(op->resource, op->flags);
+
+    return sizeof(*op);
+}
+
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags)
+{
+    struct wined3d_cs_resource_map *op;
+    void *ret;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_MAP;
+    op->resource = resource;
+    op->flags = flags;
+    op->mem = &ret;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+
+    cs->ops->finish_prio(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_resource_unmap(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_unmap *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_unmap_internal(resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_resource_unmap *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_UNMAP;
+    op->resource = resource;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_resource_changed(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_changed *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_changed(resource, op->swap_buffer, op->swap_heap_memory);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_cs_resource_changed *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_CHANGED;
+    op->resource = resource;
+    op->swap_buffer = swap_buffer;
+    op->swap_heap_memory = swap_heap_memory;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_swap_mem(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_swap_mem *op = data;
+    struct wined3d_buffer *buffer = op->buffer;
+
+    buffer_swap_mem(buffer, op->mem);
+
+    if (!buffer->buffer_object && buffer->resource.bind_count)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer, BYTE *mem)
+{
+    struct wined3d_cs_swap_mem *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SWAP_MEM;
+    op->buffer = buffer;
+    op->mem = mem;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_invalidate_bo_range(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_invalidate_bo_range *op = data;
+
+    buffer_invalidate_bo_range(op->buffer, op->offset, op->size);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size)
+{
+    struct wined3d_cs_buffer_invalidate_bo_range *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE;
     op->buffer = buffer;
     op->offset = offset;
+    op->size = size;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_index_buffer *op = data;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_query_issue *op = data;
+    struct wined3d_query *query = op->query;
+    BOOL poll;
 
-    prev = cs->state.index_buffer;
-    cs->state.index_buffer = op->buffer;
-    cs->state.index_format = op->format_id;
+    poll = query->query_ops->query_issue(query, op->flags);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    if (wined3d_use_csmt(cs->device))
+    {
+        if (poll && list_empty(&query->poll_list_entry))
+        {
+            list_add_tail(&cs->query_poll_list, &query->poll_list_entry);
+        }
+        else if (!poll && !list_empty(&query->poll_list_entry))
+        {
+            /* Can happen if occlusion queries are restarted. This discards the old
+             * result, polling it could result in a GL error */
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+        }
+        else if (op->flags & WINED3DISSUE_END)
+        {
+            /* Can happen when an occlusion query is ended without being started,
+             * in which case we don't want to poll, but still have to counter-balance
+             * the increment of the main counter (!poll && list_empty).
+             *
+             * This can also happen if an event query is re-issued before the first
+             * fence was reached (poll && !list_empty). In this case the query is
+             * already in the list and the poll function will check the new fence.
+             * We have to counter-balance the discarded increment. */
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
 
-    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
-        enum wined3d_format_id format_id)
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
 {
-    struct wined3d_cs_set_index_buffer *op;
+    struct wined3d_cs_query_issue *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
-    op->buffer = buffer;
-    op->format_id = format_id;
+    op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
+    op->query = query;
+    op->flags = flags;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_query_destroy(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_constant_buffer *op = data;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_query_destroy *op = data;
 
-    prev = cs->state.cb[op->type][op->cb_idx];
-    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+    if (!list_empty(&op->query->poll_list_entry))
+        list_remove(&op->query->poll_list_entry);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    wined3d_query_destroy(op->query);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
-        UINT cb_idx, struct wined3d_buffer *buffer)
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query)
 {
-    struct wined3d_cs_set_constant_buffer *op;
+    struct wined3d_cs_query_destroy *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
-    op->type = type;
-    op->cb_idx = cb_idx;
+    op->opcode = WINED3D_CS_OP_QUERY_DESTROY;
+    op->query = query;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_preload *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    buffer_internal_preload(op->buffer, context, NULL);
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_buffer_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_PRELOAD;
     op->buffer = buffer;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_vertex_declaration_destroy(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
-    const struct wined3d_cs_set_texture *op = data;
-    struct wined3d_texture *prev;
+    const struct wined3d_cs_vertex_declaration_destroy *op = data;
+
+    wined3d_vertex_declaration_destroy(op->declaration);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_vertex_declaration_destroy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_VDECL_DESTROY;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_shader_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_shader_cleanup *op = data;
+
+    shader_cleanup(op->shader);
+    HeapFree(GetProcessHeap(), 0, op->shader);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_shader_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SHADER_CLEANUP;
+    op->shader = shader;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_surface(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_surface *op = data;
+
+    surface_upload_from_surface(op->dst, op->has_dst_point ? &op->dst_point : NULL,
+            op->src, op->has_src_rect ? &op->src_rect : NULL);
+
+    if (op->src->container)
+        wined3d_resource_dec_fence(&op->src->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->src->resource);
+
+    if (op->dst->container)
+        wined3d_resource_dec_fence(&op->dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src, const RECT *src_rect,
+        struct wined3d_surface *dst, const POINT *dst_point)
+{
+    struct wined3d_cs_update_surface *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_SURFACE;
+    op->src = src;
+    op->dst = dst;
+    op->has_src_rect = FALSE;
+    op->has_dst_point = FALSE;
+
+    if (src_rect)
+    {
+        op->has_src_rect = TRUE;
+        op->src_rect = *src_rect;
+    }
+
+    if (dst_point)
+    {
+        op->has_dst_point = TRUE;
+        op->dst_point = *dst_point;
+    }
+
+    if (src->container)
+        wined3d_resource_inc_fence(&src->container->resource);
+    else
+        wined3d_resource_inc_fence(&src->resource);
+
+    if (dst->container)
+        wined3d_resource_inc_fence(&dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_texture_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_preload *op = data;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture = op->texture;
+
+    context = context_acquire(cs->device, NULL);
+    texture->texture_ops->texture_preload(texture, context, SRGB_ANY);
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_texture_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_PRELOAD;
+    op->texture = texture;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_surface_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_surface_preload *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    surface_internal_preload(op->surface, context, SRGB_ANY);
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface)
+{
+    struct wined3d_cs_surface_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SURFACE_PRELOAD;
+    op->surface = surface;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&op->src->resource);
+    wined3d_resource_dec_fence(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_inc_fence(&op->src->resource);
+    wined3d_resource_inc_fence(&op->dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_evict_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_evict_resource *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    resource->resource_ops->resource_unload(resource);
+
+    /* FIXME: Is this necessary? Bound buffers are preloaded anyway, and in theory
+     * PreLoad should take care of invalidating the state if the VBO changes */
+    if (resource->bind_count && resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_evict_resource *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_EVICT_RESOURCE;
+    op->resource = resource;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_surface_flip(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_surface_flip *op = data;
 
-    prev = cs->state.textures[op->stage];
-    cs->state.textures[op->stage] = op->texture;
+    surface_flip(op->surface, op->override);
 
-    if (op->texture)
-    {
-        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
-            op->texture->sampler = op->stage;
+    return sizeof(*op);
+}
 
-        if (!prev || op->texture->target != prev->target)
-            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+void wined3d_cs_emit_surface_flip(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        struct wined3d_surface *override)
+{
+    struct wined3d_cs_surface_flip *op;
 
-        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
-        {
-            /* The source arguments for color and alpha ops have different
-             * meanings when a NULL texture is bound, so the COLOR_OP and
-             * ALPHA_OP have to be dirtified. */
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
-        }
-    }
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SURFACE_FLIP;
+    op->surface = surface;
+    op->override = override;
 
-    if (prev)
-    {
-        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
-        {
-            unsigned int i;
+    cs->ops->submit(cs, sizeof(*op));
+}
 
-            /* Search for other stages the texture is bound to. Shouldn't
-             * happen if applications bind textures to a single stage only. */
-            TRACE("Searching for other stages the texture is bound to.\n");
-            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
-            {
-                if (cs->state.textures[i] == prev)
-                {
-                    TRACE("Texture is also bound to stage %u.\n", i);
-                    prev->sampler = i;
-                    break;
-                }
-            }
-        }
+static UINT wined3d_cs_exec_create_vbo(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_vbo *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
 
-        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
-        {
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
-        }
-    }
+    buffer_create_buffer_object(op->buffer, context);
 
-    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+    context_release(context);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
 {
-    struct wined3d_cs_set_texture *op;
+    struct wined3d_cs_create_vbo *op;
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
-    op->stage = stage;
-    op->texture = texture;
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_VBO;
+    op->buffer = buffer;
 
-    cs->ops->submit(cs);
+    cs->ops->submit_prio(cs, sizeof(*op));
+    cs->ops->finish_prio(cs);
 }
 
-static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_resource_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_sampler *op = data;
+    const struct wined3d_cs_resource_cleanup *op = data;
 
-    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+    wined3d_resource_cleanup_cs(op->resource);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
-        UINT sampler_idx, struct wined3d_sampler *sampler)
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs, struct wined3d_resource *resource)
 {
-    struct wined3d_cs_set_sampler *op;
+    struct wined3d_cs_resource_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
-    op->type = type;
-    op->sampler_idx = sampler_idx;
-    op->sampler = sampler;
+    op->opcode = WINED3D_CS_OP_RESOURCE_CLEANUP;
+    op->resource = resource;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_buffer_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_shader *op = data;
+    const struct wined3d_cs_buffer_cleanup *op = data;
 
-    cs->state.shader[op->type] = op->shader;
-    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+    wined3d_buffer_cleanup_cs(op->buffer);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
 {
-    struct wined3d_cs_set_shader *op;
+    struct wined3d_cs_buffer_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SHADER;
-    op->type = type;
-    op->shader = shader;
+    op->opcode = WINED3D_CS_OP_BUFFER_CLEANUP;
+    op->buffer = buffer;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_volume_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_render_state *op = data;
+    const struct wined3d_cs_volume_cleanup *op = data;
 
-    cs->state.render_states[op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+    wined3d_volume_cleanup_cs(op->volume);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume)
 {
-    struct wined3d_cs_set_render_state *op;
+    struct wined3d_cs_volume_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_VOLUME_CLEANUP;
+    op->volume = volume;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_surface_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_texture_state *op = data;
+    const struct wined3d_cs_surface_cleanup *op = data;
 
-    cs->state.texture_states[op->stage][op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+    wined3d_surface_cleanup_cs(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
-        enum wined3d_texture_stage_state state, DWORD value)
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    struct wined3d_cs_set_texture_state *op;
+    struct wined3d_cs_surface_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
-    op->stage = stage;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_SURFACE_CLEANUP;
+    op->surface = surface;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_texture_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_sampler_state *op = data;
+    const struct wined3d_cs_texture_cleanup *op = data;
 
-    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+    wined3d_texture_cleanup_cs(op->texture);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
-        enum wined3d_sampler_state state, DWORD value)
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture)
 {
-    struct wined3d_cs_set_sampler_state *op;
+    struct wined3d_cs_texture_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
-    op->sampler_idx = sampler_idx;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_TEXTURE_CLEANUP;
+    op->texture = texture;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_create_dummy_textures(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_transform *op = data;
+    const struct wined3d_cs_create_dummy_textures *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
 
-    cs->state.transforms[op->state] = *op->matrix;
-    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->gl_info.limits.blends))
-        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+    device_create_dummy_textures(cs->device, context);
+
+    context_release(context);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
-        const struct wined3d_matrix *matrix)
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs)
 {
-    struct wined3d_cs_set_transform *op;
+    struct wined3d_cs_create_dummy_textures *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
-    op->state = state;
-    op->matrix = matrix;
+    op->opcode = WINED3D_CS_OP_CREATE_DUMMY_TEXTURES;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_create_swapchain_context(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_clip_plane *op = data;
+    const struct wined3d_cs_create_swapchain_context *op = data;
 
-    cs->state.clip_planes[op->plane_idx] = *op->plane;
-    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+    *op->ret = swapchain_create_context_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_cs_set_clip_plane *op;
+    HRESULT ret;
+    struct wined3d_cs_create_swapchain_context *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
-    op->plane_idx = plane_idx;
-    op->plane = plane;
+    op->opcode = WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT;
+    op->swapchain = swapchain;
+    op->ret = &ret;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+
+    return ret;
 }
 
-static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_delete_gl_contexts(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_material *op = data;
+    const struct wined3d_cs_delete_gl_contexts *op = data;
 
-    cs->state.material = *op->material;
-    device_invalidate_state(cs->device, STATE_MATERIAL);
+    device_delete_opengl_contexts_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_cs_set_material *op;
+    struct wined3d_cs_delete_gl_contexts *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
-    op->material = material;
+    op->opcode = WINED3D_CS_OP_DELETE_GL_CONTEXTS;
+    op->swapchain = swapchain;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+static UINT (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
+    /* WINED3D_CS_OP_NOP                    */ wined3d_cs_exec_nop,
+    /* WINED3D_CS_OP_SKIP                   */ wined3d_cs_exec_skip,
+    /* WINED3D_CS_OP_FENCE                  */ wined3d_cs_exec_fence,
     /* WINED3D_CS_OP_PRESENT                */ wined3d_cs_exec_present,
     /* WINED3D_CS_OP_CLEAR                  */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DRAW                   */ wined3d_cs_exec_draw,
@@ -838,77 +2534,389 @@
     /* WINED3D_CS_OP_SET_TRANSFORM          */ wined3d_cs_exec_set_transform,
     /* WINED3D_CS_OP_SET_CLIP_PLANE         */ wined3d_cs_exec_set_clip_plane,
     /* WINED3D_CS_OP_SET_MATERIAL           */ wined3d_cs_exec_set_material,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_F        */ wined3d_cs_exec_set_vs_consts_f,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_B        */ wined3d_cs_exec_set_vs_consts_b,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_I        */ wined3d_cs_exec_set_vs_consts_i,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_F        */ wined3d_cs_exec_set_ps_consts_f,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_B        */ wined3d_cs_exec_set_ps_consts_b,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_I        */ wined3d_cs_exec_set_ps_consts_i,
+    /* WINED3D_CS_OP_RESET_STATE            */ wined3d_cs_exec_reset_state,
+    /* WINED3D_CS_OP_GLFINISH               */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_SET_BASE_VERTEX_INDEX  */ wined3d_cs_exec_set_base_vertex_index,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE     */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT              */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE       */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_BLT                    */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_COLOR_FILL             */ wined3d_cs_exec_color_fill,
+    /* WINED3D_CS_OP_RESOURCE_MAP           */ wined3d_cs_exec_resource_map,
+    /* WINED3D_CS_OP_RESOURCE_UNMAP         */ wined3d_cs_exec_resource_unmap,
+    /* WINED3D_CS_OP_RESOURCE_CHANGED       */ wined3d_cs_exec_resource_changed,
+    /* WINED3D_CS_OP_SWAP_MEM               */ wined3d_cs_exec_swap_mem,
+    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE*/ wined3d_cs_exec_buffer_invalidate_bo_range,
+    /* WINED3D_CS_OP_QUERY_ISSUE            */ wined3d_cs_exec_query_issue,
+    /* WINED3D_CS_OP_QUERY_DESTROY          */ wined3d_cs_exec_query_destroy,
+    /* WINED3D_CS_OP_BUFFER_PRELOAD         */ wined3d_cs_exec_buffer_preload,
+    /* WINED3D_CS_OP_VDECL_DESTROY          */ wined3d_cs_exec_vertex_declaration_destroy,
+    /* WINED3D_CS_OP_SHADER_CLEANUP         */ wined3d_cs_exec_shader_cleanup,
+    /* WINED3D_CS_OP_UPDATE_SURFACE         */ wined3d_cs_exec_update_surface,
+    /* WINED3D_CS_OP_TEXTURE_PRELOAD        */ wined3d_cs_exec_texture_preload,
+    /* WINED3D_CS_OP_SURFACE_PRELOAD        */ wined3d_cs_exec_surface_preload,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE         */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_EVICT_RESOURCE         */ wined3d_cs_exec_evict_resource,
+    /* WINED3D_CS_OP_SURFACE_FLIP           */ wined3d_cs_exec_surface_flip,
+    /* WINED3D_CS_OP_CREATE_VBO             */ wined3d_cs_exec_create_vbo,
+    /* WINED3D_CS_OP_RESOURCE_CLEANUP       */ wined3d_cs_exec_resource_cleanup,
+    /* WINED3D_CS_OP_BUFFER_CLEANUP         */ wined3d_cs_exec_buffer_cleanup,
+    /* WINED3D_CS_OP_VOLUME_CLEANUP         */ wined3d_cs_exec_volume_cleanup,
+    /* WINED3D_CS_OP_SURFACE_CLEANUP        */ wined3d_cs_exec_surface_cleanup,
+    /* WINED3D_CS_OP_TEXTURE_CLEANUP        */ wined3d_cs_exec_texture_cleanup,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES  */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CON...*/ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS     */ wined3d_cs_exec_delete_gl_contexts,
 };
 
-static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+static inline void *_wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, BOOL prio)
+{
+    struct wined3d_cs_queue *queue = prio ? &cs->prio_queue : &cs->queue;
+    size_t queue_size = sizeof(queue->data) / sizeof(*queue->data);
+
+    if (queue_size - size < queue->head)
+    {
+        struct wined3d_cs_skip *skip;
+        size_t nop_size = queue_size - queue->head;
+
+        skip = _wined3d_cs_mt_require_space(cs, nop_size, prio);
+        if (nop_size < sizeof(*skip))
+        {
+            skip->opcode = WINED3D_CS_OP_NOP;
+        }
+        else
+        {
+            skip->opcode = WINED3D_CS_OP_SKIP;
+            skip->size = nop_size;
+        }
+
+        if (prio)
+            cs->ops->submit_prio(cs, nop_size);
+        else
+            cs->ops->submit(cs, nop_size);
+
+        assert(!queue->head);
+    }
+
+    while(1)
+    {
+        LONG head = queue->head;
+        LONG tail = *((volatile LONG *)&queue->tail);
+        LONG new_pos;
+        /* Empty */
+        if (head == tail)
+            break;
+        /* Head ahead of tail, take care of wrap-around */
+        new_pos = (head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+        if (head > tail && (new_pos || tail))
+            break;
+        /* Tail ahead of head, but still enough space */
+        if (new_pos < tail && new_pos)
+            break;
+
+        TRACE("Waiting for free space. Head %u, tail %u, want %u\n", head, tail,
+                (unsigned int) size);
+    }
+
+    return &queue->data[queue->head];
+}
+
+static inline void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, FALSE);
+}
+
+static inline void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, TRUE);
+}
+
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
 {
-    if (size > cs->data_size)
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
     {
-        void *new_data;
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
 
-        size = max( size, cs->data_size * 2 );
-        if (!(new_data = HeapReAlloc(GetProcessHeap(), 0, cs->data, size)))
-            return NULL;
+    wined3d_cs_emit_fence_prio(cs, &fence);
 
-        cs->data_size = size;
-        cs->data = new_data;
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_require_space_prio,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_prio,
+    wined3d_cs_mt_finish,
+    wined3d_cs_mt_finish_prio,
+};
+
+static void wined3d_cs_st_submit(struct wined3d_cs *cs, size_t size)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&cs->queue.data;
+
+    if (opcode >= WINED3D_CS_OP_STOP)
+    {
+        ERR("Invalid opcode %#x.\n", opcode);
+        return;
     }
 
-    return cs->data;
+    wined3d_cs_op_handlers[opcode](cs, &cs->queue.data);
 }
 
-static void wined3d_cs_st_submit(struct wined3d_cs *cs)
+static void wined3d_cs_st_finish(struct wined3d_cs *cs)
 {
-    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)cs->data;
+}
 
-    wined3d_cs_op_handlers[opcode](cs, cs->data);
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return cs->queue.data;
 }
 
 static const struct wined3d_cs_ops wined3d_cs_st_ops =
 {
     wined3d_cs_st_require_space,
+    wined3d_cs_st_require_space,
     wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_finish,
+    wined3d_cs_st_finish,
 };
 
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (cs->onscreen_depth_stencil)
+    {
+        surface_load_ds_location(cs->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(cs->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                cs->onscreen_depth_stencil->ds_current_size.cx,
+                cs->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_surface_decref(cs->onscreen_depth_stencil);
+    }
+    cs->onscreen_depth_stencil = depth_stencil;
+    wined3d_surface_incref(cs->onscreen_depth_stencil);
+}
+
+static inline void poll_queries(struct wined3d_cs *cs)
+{
+    struct wined3d_query *query, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(query, cursor, &cs->query_poll_list, struct wined3d_query, poll_list_entry)
+    {
+        BOOL ret;
+
+        ret = query->query_ops->query_poll(query);
+        if (!ret)
+            break;
+
+        list_remove(&query->poll_list_entry);
+        list_init(&query->poll_list_entry);
+        InterlockedIncrement(&query->counter_retrieved);
+    }
+}
+
+static inline BOOL queue_is_empty(const struct wined3d_cs_queue *queue)
+{
+    return *((volatile LONG *)&queue->head) == queue->tail;
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (!queue_is_empty(&cs->prio_queue) || !queue_is_empty(&cs->queue))
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, FALSE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+    }
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+    enum wined3d_cs_op opcode;
+    LONG tail;
+    struct wined3d_cs_queue *queue;
+    char poll = 0;
+    unsigned int spin_count = 0;
+
+    TRACE("Started.\n");
+
+    list_init(&cs->query_poll_list);
+    cs->thread_id = GetCurrentThreadId();
+    for (;;)
+    {
+        if (poll == 10)
+        {
+            poll = 0;
+            poll_queries(cs);
+        }
+        else
+            poll++;
+
+        if (!queue_is_empty(&cs->prio_queue))
+        {
+            queue = &cs->prio_queue;
+        }
+        else if (!queue_is_empty(&cs->queue))
+        {
+            queue = &cs->queue;
+            if (!queue_is_empty(&cs->prio_queue))
+                queue = &cs->prio_queue;
+        }
+        else
+        {
+            spin_count++;
+            if (spin_count >= WINED3D_CS_SPIN_COUNT && list_empty(&cs->query_poll_list))
+                wined3d_cs_wait_event(cs);
+
+            continue;
+        }
+
+        spin_count = 0;
+
+        tail = queue->tail;
+        opcode = *(const enum wined3d_cs_op *)&queue->data[tail];
+
+        if (opcode >= WINED3D_CS_OP_STOP)
+        {
+            if (opcode > WINED3D_CS_OP_STOP)
+                ERR("Invalid opcode %#x.\n", opcode);
+            goto done;
+        }
+
+        tail += wined3d_cs_op_handlers[opcode](cs, &queue->data[tail]);
+        tail &= (WINED3D_CS_QUEUE_SIZE - 1);
+        InterlockedExchange(&queue->tail, tail);
+    }
+
+done:
+    TRACE("Stopped.\n");
+    return 0;
+}
+
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-    struct wined3d_cs *cs;
+    struct wined3d_cs *cs = NULL;
 
     if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
         return NULL;
 
-    if (!(cs->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(*cs->fb.render_targets) * gl_info->limits.buffers)))
-    {
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
-    }
-
-    if (FAILED(state_init(&cs->state, &cs->fb, gl_info, &device->adapter->d3d_info,
+    if (FAILED(state_init(&cs->state, gl_info, &device->adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
     {
-        HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
+        goto err;
     }
 
     cs->ops = &wined3d_cs_st_ops;
     cs->device = device;
 
-    cs->data_size = WINED3D_INITIAL_CS_SIZE;
-    if (!(cs->data = HeapAlloc(GetProcessHeap(), 0, cs->data_size)))
+    if (wined3d_use_csmt(device))
     {
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
+        cs->ops = &wined3d_cs_mt_ops;
+
+        cs->event = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, NULL)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            goto err;
+        }
     }
 
     return cs;
+
+err:
+    if (cs)
+        state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs);
+    return NULL;
 }
 
 void wined3d_cs_destroy(struct wined3d_cs *cs)
 {
+    DWORD ret;
+
     state_cleanup(&cs->state);
-    HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
+
+    if (wined3d_use_csmt(cs->device))
+    {
+        wined3d_cs_emit_stop(cs);
+
+        ret = WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+        if (ret != WAIT_OBJECT_0)
+            ERR("Wait failed (%#x).\n", ret);
+        if (!CloseHandle(cs->event))
+            ERR("Closing event failed.\n");
+    }
+
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff -Naur a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/device.c	2013-11-07 21:40:10.000000000 +0000
@@ -196,22 +196,6 @@
     device->contexts = new_array;
 }
 
-void device_switch_onscreen_ds(struct wined3d_device *device,
-        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
-{
-    if (device->onscreen_depth_stencil)
-    {
-        surface_load_ds_location(device->onscreen_depth_stencil, context, SFLAG_INTEXTURE);
-
-        surface_modify_ds_location(device->onscreen_depth_stencil, SFLAG_INTEXTURE,
-                device->onscreen_depth_stencil->ds_current_size.cx,
-                device->onscreen_depth_stencil->ds_current_size.cy);
-        wined3d_surface_decref(device->onscreen_depth_stencil);
-    }
-    device->onscreen_depth_stencil = depth_stencil;
-    wined3d_surface_incref(device->onscreen_depth_stencil);
-}
-
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     /* partial draw rect */
@@ -234,7 +218,7 @@
 {
     RECT current_rect, r;
 
-    if (ds->flags & SFLAG_DISCARDED)
+    if (ds->resource.locations & WINED3D_LOCATION_DISCARDED)
     {
         /* Depth buffer was discarded, make it entirely current in its new location since
          * there is no other place where we would get data anyway. */
@@ -304,17 +288,17 @@
      * anyway. If we're not clearing the color buffer we don't have to copy either since we're not going to set
      * the drawable up to date. We have to check all settings that limit the clear area though. Do not bother
      * checking all this if the dest surface is in the drawable anyway. */
+    context = context_acquire(device, target);
     if (flags & WINED3DCLEAR_TARGET && !is_full_clear(target, draw_rect, clear_rect))
     {
         for (i = 0; i < rt_count; ++i)
         {
             struct wined3d_surface *rt = fb->render_targets[i];
             if (rt)
-                surface_load_location(rt, rt->draw_binding, NULL);
+                wined3d_resource_load_location(&rt->resource, context, rt->draw_binding);
         }
     }
 
-    context = context_acquire(device, target);
     if (!context->valid)
     {
         context_release(context);
@@ -337,10 +321,10 @@
 
     if (flags & WINED3DCLEAR_ZBUFFER)
     {
-        DWORD location = render_offscreen ? fb->depth_stencil->draw_binding : SFLAG_INDRAWABLE;
+        DWORD location = render_offscreen ? fb->depth_stencil->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
-        if (!render_offscreen && fb->depth_stencil != device->onscreen_depth_stencil)
-            device_switch_onscreen_ds(device, context, fb->depth_stencil);
+        if (!render_offscreen && fb->depth_stencil != device->cs->onscreen_depth_stencil)
+            wined3d_cs_switch_onscreen_ds(device->cs, context, fb->depth_stencil);
         prepare_ds_clear(fb->depth_stencil, context, location,
                 draw_rect, rect_count, clear_rect, &ds_rect);
     }
@@ -369,7 +353,7 @@
 
     if (flags & WINED3DCLEAR_ZBUFFER)
     {
-        DWORD location = render_offscreen ? fb->depth_stencil->draw_binding : SFLAG_INDRAWABLE;
+        DWORD location = render_offscreen ? fb->depth_stencil->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
         surface_modify_ds_location(fb->depth_stencil, location, ds_rect.right, ds_rect.bottom);
 
@@ -388,8 +372,8 @@
 
             if (rt)
             {
-                surface_validate_location(rt, rt->draw_binding);
-                surface_invalidate_location(rt, ~rt->draw_binding);
+                wined3d_resource_validate_location(&rt->resource, rt->draw_binding);
+                wined3d_resource_invalidate_location(&rt->resource, ~rt->draw_binding);
             }
         }
 
@@ -607,7 +591,7 @@
 }
 
 /* Context activation is done by the caller. */
-static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     unsigned int i, j, count;
@@ -834,7 +818,7 @@
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
-    if (device->fb.render_targets)
+    if (device->state.fb.render_targets)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -852,9 +836,7 @@
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
-    struct wined3d_context *context;
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -865,9 +847,6 @@
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
-    device->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(*device->fb.render_targets) * gl_info->limits.buffers);
-
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -900,9 +879,7 @@
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
-    context = context_acquire(device, swapchain->front_buffer);
-
-    create_dummy_textures(device, context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     device->contexts[0]->last_was_rhw = 0;
 
@@ -914,7 +891,7 @@
 
         case ORM_BACKBUFFER:
         {
-            if (context_get_current()->aux_buffers > 0)
+            if (device->contexts[0]->aux_buffers > 0)
             {
                 TRACE("Using auxiliary buffer for offscreen rendering\n");
                 device->offscreenBuffer = GL_AUX0;
@@ -926,11 +903,10 @@
             }
         }
     }
+    device->contexts[0]->offscreenBuffer = device->offscreenBuffer;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
 
-    context_release(context);
-
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
         clear_flags |= WINED3DCLEAR_TARGET;
@@ -946,7 +922,6 @@
     return WINED3D_OK;
 
 err_out:
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (swapchain)
@@ -995,8 +970,6 @@
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_context *context;
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1005,66 +978,25 @@
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
-    /* Force making the context current again, to verify it is still valid
-     * (workaround for broken drivers) */
-    context_set_current(NULL);
-    /* I don't think that the interface guarantees that the device is destroyed from the same thread
-     * it was created. Thus make sure a context is active for the glDelete* calls
-     */
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
+    if (wined3d_use_csmt(device))
+        device->cs->ops->finish(device->cs);
 
     if (device->logo_surface)
         wined3d_surface_decref(device->logo_surface);
 
-    state_unbind_resources(&device->state);
-
-    /* Unload resources */
-    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
-    {
-        TRACE("Unloading resource %p.\n", resource);
-
-        resource->resource_ops->resource_unload(resource);
-    }
-
-    /* Delete the mouse cursor texture */
-    if (device->cursorTexture)
-    {
-        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->cursorTexture);
-        device->cursorTexture = 0;
-    }
-
-    /* Destroy the depth blt resources, they will be invalid after the reset. Also free shader
-     * private data, it might contain opengl pointers
-     */
-    if (device->depth_blt_texture)
+    /* Release the buffers (with sanity checks).
+     * FIXME: Move this move into a separate patch. I think the idea
+     * behind this is that those surfaces should be freed before unloading
+     * remaining resources below.
+     * FIXME 2: Shouldn't the cs take care of onscreen_depth_stencil? */
+    if (device->cs->onscreen_depth_stencil)
     {
-        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
-        device->depth_blt_texture = 0;
-    }
-
-    /* Destroy the shader backend. Note that this has to happen after all shaders are destroyed. */
-    device->blitter->free_private(device);
-    device->shader_backend->shader_free_private(device);
-    destroy_dummy_textures(device, gl_info);
-
-    /* Release the buffers (with sanity checks)*/
-    if (device->onscreen_depth_stencil)
-    {
-        surface = device->onscreen_depth_stencil;
-        device->onscreen_depth_stencil = NULL;
+        surface = device->cs->onscreen_depth_stencil;
+        device->cs->onscreen_depth_stencil = NULL;
         wined3d_surface_decref(surface);
     }
 
-    if (device->fb.depth_stencil)
-    {
-        surface = device->fb.depth_stencil;
-
-        TRACE("Releasing depth/stencil buffer %p.\n", surface);
-
-        device->fb.depth_stencil = NULL;
-        wined3d_surface_decref(surface);
-    }
+    state_unbind_resources(&device->state);
 
     if (device->auto_depth_stencil)
     {
@@ -1074,12 +1006,14 @@
             FIXME("Something's still holding the auto depth stencil buffer (%p).\n", surface);
     }
 
-    for (i = 0; i < gl_info->limits.buffers; ++i)
+    /* Unload resources */
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
-        wined3d_device_set_render_target(device, i, NULL, FALSE);
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_evict_resource(device->cs, resource);
     }
 
-    context_release(context);
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
 
     for (i = 0; i < device->swapchain_count; ++i)
     {
@@ -1092,9 +1026,6 @@
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
-    device->fb.render_targets = NULL;
-
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1459,14 +1390,6 @@
     TRACE("... Range(%f), Falloff(%f), Theta(%f), Phi(%f)\n",
             light->range, light->falloff, light->theta, light->phi);
 
-    /* Update the live definitions if the light is currently assigned a glIndex. */
-    if (object->glIndex != -1 && !device->recording)
-    {
-        if (object->OriginalParms.type != light->type)
-            device_invalidate_state(device, STATE_LIGHT_TYPE);
-        device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
-    }
-
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1539,6 +1462,9 @@
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light(device->cs, object);
+
     return WINED3D_OK;
 }
 
@@ -1611,12 +1537,6 @@
     {
         if (light_info->glIndex != -1)
         {
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
-            }
-
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1658,16 +1578,12 @@
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
-
-            /* i == light_info->glIndex */
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(i));
-            }
         }
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+
     return WINED3D_OK;
 }
 
@@ -1841,6 +1757,9 @@
     TRACE("device %p, base_index %d.\n", device, base_index);
 
     device->update_state->base_vertex_index = base_index;
+
+    if (!device->recording)
+        wined3d_cs_emit_set_base_vertex_index(device->cs, base_index);
 }
 
 INT CDECL wined3d_device_get_base_vertex_index(const struct wined3d_device *device)
@@ -1885,7 +1804,7 @@
             || !(texture->resource.format->flags & WINED3DFMT_FLAG_DEPTH))
         return;
     surface = surface_from_resource(texture->sub_resources[0]);
-    depth_stencil = state->fb->depth_stencil;
+    depth_stencil = state->fb.depth_stencil;
     if (!depth_stencil)
         return;
 
@@ -2160,7 +2079,7 @@
     return device->state.sampler[WINED3D_SHADER_TYPE_VERTEX][idx];
 }
 
-static void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
 {
     UINT i;
 
@@ -2193,7 +2112,8 @@
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_VERTEX);
     }
 
     return WINED3D_OK;
@@ -2240,7 +2160,8 @@
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_VERTEX);
     }
 
     return WINED3D_OK;
@@ -2291,8 +2212,8 @@
         memset(device->recording->changed.vertexShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.vertexShaderConstantsF) * vector4f_count);
     else
-        device->shader_backend->shader_update_float_vertex_constants(device, start_register, vector4f_count);
-
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_VERTEX);
 
     return WINED3D_OK;
 }
@@ -2405,7 +2326,8 @@
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_PIXEL);
     }
 
     return WINED3D_OK;
@@ -2452,7 +2374,8 @@
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_PIXEL);
     }
 
     return WINED3D_OK;
@@ -2504,7 +2427,8 @@
         memset(device->recording->changed.pixelShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.pixelShaderConstantsF) * vector4f_count);
     else
-        device->shader_backend->shader_update_float_pixel_constants(device, start_register, vector4f_count);
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_PIXEL);
 
     return WINED3D_OK;
 }
@@ -2642,6 +2566,13 @@
         return hr;
     }
 
+    if (wined3d_use_csmt(device))
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3141,8 +3072,6 @@
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
-    struct wined3d_context *context;
-
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3151,13 +3080,6 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    context = context_acquire(device, NULL);
-    /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
-    context->gl_info->gl_ops.gl.p_glFlush();
-    /* No checkGLcall here to avoid locking the lock just for checking a call that hardly ever
-     * fails. */
-    context_release(context);
-
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3183,6 +3105,8 @@
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+    const struct wined3d_fb_state *fb = &device->state.fb;
+
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color {%.8e, %.8e, %.8e, %.8e}, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, color->r, color->g, color->b, color->a, depth, stencil);
 
@@ -3191,10 +3115,12 @@
         WARN("Rects is %p, but rect_count is 0, ignoring clear\n", rects);
         return WINED3D_OK;
     }
+    if (rect_count && !rects)
+        rect_count = 0;
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
+        struct wined3d_surface *ds = fb->depth_stencil;
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3203,8 +3129,8 @@
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
-            if (ds->resource.width < device->fb.render_targets[0]->resource.width
-                    || ds->resource.height < device->fb.render_targets[0]->resource.height)
+            if (ds->resource.width < fb->render_targets[0]->resource.width
+                    || ds->resource.height < fb->render_targets[0]->resource.height)
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3221,7 +3147,6 @@
         enum wined3d_primitive_type primitive_type)
 {
     GLenum gl_primitive_type, prev;
-
     TRACE("device %p, primitive_type %s\n", device, debug_d3dprimitivetype(primitive_type));
 
     gl_primitive_type = gl_primitive_type_from_d3d(primitive_type);
@@ -3229,8 +3154,8 @@
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
-    else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-        device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+    else if (gl_primitive_type != prev)
+        wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3253,12 +3178,6 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (device->state.load_base_vertex_index)
-    {
-        device->state.load_base_vertex_index = 0;
-        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
-    }
-
     wined3d_cs_emit_draw(device->cs, start_vertex, vertex_count, 0, 0, FALSE);
 
     return WINED3D_OK;
@@ -3266,8 +3185,6 @@
 
 HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count)
 {
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-
     TRACE("device %p, start_idx %u, index_count %u.\n", device, start_idx, index_count);
 
     if (!device->state.index_buffer)
@@ -3286,13 +3203,6 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (!gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX] &&
-        device->state.load_base_vertex_index != device->state.base_vertex_index)
-    {
-        device->state.load_base_vertex_index = device->state.base_vertex_index;
-        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
-    }
-
     wined3d_cs_emit_draw(device->cs, start_idx, index_count, 0, 0, TRUE);
 
     return WINED3D_OK;
@@ -3307,97 +3217,43 @@
 }
 
 /* This is a helper function for UpdateTexture, there is no UpdateVolume method in D3D. */
-static HRESULT device_update_volume(struct wined3d_device *device,
+static void device_update_volume(struct wined3d_context *context,
         struct wined3d_volume *src_volume, struct wined3d_volume *dst_volume)
 {
-    struct wined3d_map_desc src;
-    HRESULT hr;
     struct wined3d_bo_address data;
-    struct wined3d_context *context;
 
-    TRACE("device %p, src_volume %p, dst_volume %p.\n",
-            device, src_volume, dst_volume);
+    TRACE("src_volume %p, dst_volume %p.\n",
+            src_volume, dst_volume);
 
     if (src_volume->resource.format != dst_volume->resource.format)
     {
         FIXME("Source and destination formats do not match.\n");
-        return WINED3DERR_INVALIDCALL;
+        return;
     }
     if (src_volume->resource.width != dst_volume->resource.width
             || src_volume->resource.height != dst_volume->resource.height
             || src_volume->resource.depth != dst_volume->resource.depth)
     {
         FIXME("Source and destination sizes do not match.\n");
-        return WINED3DERR_INVALIDCALL;
+        return;
     }
 
-    if (FAILED(hr = wined3d_volume_map(src_volume, &src, NULL, WINED3D_MAP_READONLY)))
-        return hr;
-
-    context = context_acquire(device, NULL);
-
     wined3d_volume_load(dst_volume, context, FALSE);
-
-    data.buffer_object = 0;
-    data.addr = src.data;
+    wined3d_resource_get_memory(&src_volume->resource, src_volume->resource.map_binding, &data);
     wined3d_volume_upload_data(dst_volume, context, &data);
-    wined3d_volume_invalidate_location(dst_volume, ~WINED3D_LOCATION_TEXTURE_RGB);
-
-    context_release(context);
-
-    hr = wined3d_volume_unmap(src_volume);
-
-    return hr;
+    wined3d_resource_invalidate_location(&dst_volume->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 }
 
-HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
-        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
 {
-    enum wined3d_resource_type type;
-    unsigned int level_count, i;
-    HRESULT hr;
-    struct wined3d_context *context;
-
-    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
-
-    /* Verify that the source and destination textures are non-NULL. */
-    if (!src_texture || !dst_texture)
-    {
-        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
-    {
-        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
-    {
-        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    /* Verify that the source and destination textures are the same type. */
-    type = src_texture->resource.type;
-    if (dst_texture->resource.type != type)
-    {
-        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    /* Check that both textures have the identical numbers of levels. */
-    level_count = wined3d_texture_get_level_count(src_texture);
-    if (wined3d_texture_get_level_count(dst_texture) != level_count)
-    {
-        WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+    enum wined3d_resource_type type = src_texture->resource.type;
+    unsigned int level_count = wined3d_texture_get_level_count(src_texture);
+    unsigned int i;
 
     /* Make sure that the destination texture is loaded. */
-    context = context_acquire(device, NULL);
     dst_texture->texture_ops->texture_preload(dst_texture, context, SRGB_RGB);
-    context_release(context);
 
     /* Update every surface level of the texture. */
     switch (type)
@@ -3411,12 +3267,7 @@
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
-                hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
-                if (FAILED(hr))
-                {
-                    WARN("Failed to update surface, hr %#x.\n", hr);
-                    return hr;
-                }
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
             }
             break;
         }
@@ -3430,12 +3281,7 @@
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
-                hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
-                if (FAILED(hr))
-                {
-                    WARN("Failed to update surface, hr %#x.\n", hr);
-                    return hr;
-                }
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
             }
             break;
         }
@@ -3444,22 +3290,62 @@
         {
             for (i = 0; i < level_count; ++i)
             {
-                hr = device_update_volume(device,
+                device_update_volume(context,
                         volume_from_resource(wined3d_texture_get_sub_resource(src_texture, i)),
                         volume_from_resource(wined3d_texture_get_sub_resource(dst_texture, i)));
-                if (FAILED(hr))
-                {
-                    WARN("Failed to update volume, hr %#x.\n", hr);
-                    return hr;
-                }
             }
             break;
         }
 
         default:
             FIXME("Unsupported texture type %#x.\n", type);
-            return WINED3DERR_INVALIDCALL;
+            return;
     }
+}
+
+HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+{
+    enum wined3d_resource_type type;
+    unsigned int level_count;
+
+    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
+
+    /* Verify that the source and destination textures are non-NULL. */
+    if (!src_texture || !dst_texture)
+    {
+        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
+    {
+        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
+    {
+        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Verify that the source and destination textures are the same type. */
+    type = src_texture->resource.type;
+    if (dst_texture->resource.type != type)
+    {
+        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Check that both textures have the identical numbers of levels. */
+    level_count = wined3d_texture_get_level_count(src_texture);
+    if (wined3d_texture_get_level_count(dst_texture) != level_count)
+    {
+        WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
 
     return WINED3D_OK;
 }
@@ -3522,8 +3408,8 @@
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
-        struct wined3d_surface *target = device->fb.render_targets[0];
+        struct wined3d_surface *ds = state->fb.depth_stencil;
+        struct wined3d_surface *target = state->fb.render_targets[0];
 
         if(ds && target
                 && (ds->resource.width < target->resource.width || ds->resource.height < target->resource.height))
@@ -3621,6 +3507,13 @@
         struct wined3d_surface *src_surface, const RECT *src_rect,
         struct wined3d_surface *dst_surface, const POINT *dst_point)
 {
+    const struct wined3d_format *src_format = src_surface->resource.format;
+    const struct wined3d_format *dst_format = dst_surface->resource.format;
+    UINT update_w, update_h;
+    UINT dst_w, dst_h;
+    RECT r, dst_rect;
+    POINT p;
+
     TRACE("device %p, src_surface %p, src_rect %s, dst_surface %p, dst_point %s.\n",
             device, src_surface, wine_dbgstr_rect(src_rect),
             dst_surface, wine_dbgstr_point(dst_point));
@@ -3632,7 +3525,68 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    return surface_upload_from_surface(dst_surface, dst_point, src_surface, src_rect);
+    if (src_format->id != dst_format->id)
+    {
+        WARN("Source and destination surfaces should have the same format.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!dst_point)
+    {
+        p.x = 0;
+        p.y = 0;
+        dst_point = &p;
+    }
+    else if (dst_point->x < 0 || dst_point->y < 0)
+    {
+        WARN("Invalid destination point.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!src_rect)
+    {
+        r.left = 0;
+        r.top = 0;
+        r.right = src_surface->resource.width;
+        r.bottom = src_surface->resource.height;
+        src_rect = &r;
+    }
+    else if (src_rect->left < 0 || src_rect->left >= src_rect->right
+            || src_rect->top < 0 || src_rect->top >= src_rect->bottom)
+    {
+        WARN("Invalid source rectangle.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    dst_w = dst_surface->resource.width;
+    dst_h = dst_surface->resource.height;
+
+    update_w = src_rect->right - src_rect->left;
+    update_h = src_rect->bottom - src_rect->top;
+
+    if (update_w > dst_w || dst_point->x > dst_w - update_w
+            || update_h > dst_h || dst_point->y > dst_h - update_h)
+    {
+        WARN("Destination out of bounds.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if ((src_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(src_surface, src_rect))
+    {
+        WARN("Source rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    SetRect(&dst_rect, dst_point->x, dst_point->y, dst_point->x + update_w, dst_point->y + update_h);
+    if ((dst_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(dst_surface, &dst_rect))
+    {
+        WARN("Destination rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_surface(device->cs, src_surface, src_rect, dst_surface, dst_point);
+
+    return WINED3D_OK;
 }
 
 HRESULT CDECL wined3d_device_color_fill(struct wined3d_device *device,
@@ -3656,7 +3610,9 @@
         rect = &r;
     }
 
-    return surface_color_fill(surface, rect, color);
+    wined3d_cs_emit_color_fill(device->cs, surface, rect, color);
+
+    return WINED3D_OK;
 }
 
 void CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *device,
@@ -3673,6 +3629,13 @@
         return;
     }
 
+    if (wined3d_use_csmt(device))
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     SetRect(&rect, 0, 0, resource->width, resource->height);
     hr = surface_color_fill(surface_from_resource(resource), &rect, color);
     if (FAILED(hr)) ERR("Color fill failed, hr %#x.\n", hr);
@@ -3689,20 +3652,21 @@
         return NULL;
     }
 
-    return device->fb.render_targets[render_target_idx];
+    return device->state.fb.render_targets[render_target_idx];
 }
 
 struct wined3d_surface * CDECL wined3d_device_get_depth_stencil(const struct wined3d_device *device)
 {
     TRACE("device %p.\n", device);
 
-    return device->fb.depth_stencil;
+    return device->state.fb.depth_stencil;
 }
 
 HRESULT CDECL wined3d_device_set_render_target(struct wined3d_device *device,
         UINT render_target_idx, struct wined3d_surface *render_target, BOOL set_viewport)
 {
     struct wined3d_surface *prev;
+    struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("device %p, render_target_idx %u, render_target %p, set_viewport %#x.\n",
             device, render_target_idx, render_target, set_viewport);
@@ -3742,13 +3706,13 @@
     }
 
 
-    prev = device->fb.render_targets[render_target_idx];
+    prev = fb->render_targets[render_target_idx];
     if (render_target == prev)
         return WINED3D_OK;
 
     if (render_target)
         wined3d_surface_incref(render_target);
-    device->fb.render_targets[render_target_idx] = render_target;
+    fb->render_targets[render_target_idx] = render_target;
     wined3d_cs_emit_set_render_target(device->cs, render_target_idx, render_target);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -3760,7 +3724,8 @@
 
 void CDECL wined3d_device_set_depth_stencil(struct wined3d_device *device, struct wined3d_surface *depth_stencil)
 {
-    struct wined3d_surface *prev = device->fb.depth_stencil;
+    struct wined3d_fb_state *fb = &device->state.fb;
+    struct wined3d_surface *prev = fb->depth_stencil;
 
     TRACE("device %p, depth_stencil %p, old depth_stencil %p.\n",
             device, depth_stencil, prev);
@@ -3771,7 +3736,7 @@
         return;
     }
 
-    device->fb.depth_stencil = depth_stencil;
+    fb->depth_stencil = depth_stencil;
     if (depth_stencil)
         wined3d_surface_incref(depth_stencil);
     wined3d_cs_emit_set_depth_stencil(device->cs, depth_stencil);
@@ -3785,15 +3750,6 @@
     TRACE("device %p, x_hotspot %u, y_hotspot %u, cursor_image %p.\n",
             device, x_hotspot, y_hotspot, cursor_image);
 
-    /* some basic validation checks */
-    if (device->cursorTexture)
-    {
-        struct wined3d_context *context = context_acquire(device, NULL);
-        context->gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->cursorTexture);
-        context_release(context);
-        device->cursorTexture = 0;
-    }
-
     if (cursor_image)
     {
         struct wined3d_display_mode mode;
@@ -3831,46 +3787,6 @@
          * instead. */
         device->cursorWidth = cursor_image->resource.width;
         device->cursorHeight = cursor_image->resource.height;
-        if (SUCCEEDED(wined3d_surface_map(cursor_image, &map_desc, NULL, WINED3D_MAP_READONLY)))
-        {
-            const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-            const struct wined3d_format *format = wined3d_get_format(gl_info, WINED3DFMT_B8G8R8A8_UNORM);
-            struct wined3d_context *context;
-            char *mem, *bits = map_desc.data;
-            GLint intfmt = format->glInternal;
-            GLint gl_format = format->glFormat;
-            GLint type = format->glType;
-            INT height = device->cursorHeight;
-            INT width = device->cursorWidth;
-            INT bpp = format->byte_count;
-            INT i;
-
-            /* Reformat the texture memory (pitch and width can be
-             * different) */
-            mem = HeapAlloc(GetProcessHeap(), 0, width * height * bpp);
-            for (i = 0; i < height; ++i)
-                memcpy(&mem[width * bpp * i], &bits[map_desc.row_pitch * i], width * bpp);
-            wined3d_surface_unmap(cursor_image);
-
-            context = context_acquire(device, NULL);
-
-            context_invalidate_active_texture(context);
-            /* Create a new cursor texture */
-            gl_info->gl_ops.gl.p_glGenTextures(1, &device->cursorTexture);
-            checkGLcall("glGenTextures");
-            context_bind_texture(context, GL_TEXTURE_2D, device->cursorTexture);
-            /* Copy the bitmap memory into the cursor texture */
-            gl_info->gl_ops.gl.p_glTexImage2D(GL_TEXTURE_2D, 0, intfmt, width, height, 0, gl_format, type, mem);
-            checkGLcall("glTexImage2D");
-            HeapFree(GetProcessHeap(), 0, mem);
-
-            context_release(context);
-        }
-        else
-        {
-            FIXME("A cursor texture was not returned.\n");
-            device->cursorTexture = 0;
-        }
 
         if (cursor_image->resource.width == 32 && cursor_image->resource.height == 32)
         {
@@ -3967,11 +3883,6 @@
         else
             SetCursor(NULL);
     }
-    else
-    {
-        if (device->cursorTexture)
-            device->bCursorVisible = show;
-    }
 
     return oldVisible;
 }
@@ -3982,6 +3893,8 @@
 
     TRACE("device %p.\n", device);
 
+    /* The resource list is manged by the main thread, iterate here and emit commands for
+     * each resource */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Checking resource %p for eviction.\n", resource);
@@ -3989,46 +3902,30 @@
         if (resource->pool == WINED3D_POOL_MANAGED && !resource->map_count)
         {
             TRACE("Evicting %p.\n", resource);
-            resource->resource_ops->resource_unload(resource);
+            wined3d_cs_emit_evict_resource(device->cs, resource);
         }
     }
-
-    /* Invalidate stream sources, the buffer(s) may have been evicted. */
-    device_invalidate_state(device, STATE_STREAMSRC);
 }
 
-static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_resource *resource, *cursor;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_shader *shader;
 
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
-
-    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
-    {
-        TRACE("Unloading resource %p.\n", resource);
-
-        resource->resource_ops->resource_unload(resource);
-    }
-
     LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
     {
         device->shader_backend->shader_destroy(shader);
     }
 
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
     if (device->depth_blt_texture)
     {
         gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
         device->depth_blt_texture = 0;
     }
-    if (device->cursorTexture)
-    {
-        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->cursorTexture);
-        device->cursorTexture = 0;
-    }
 
     device->blitter->free_private(device);
     device->shader_backend->shader_free_private(device);
@@ -4043,12 +3940,25 @@
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+    swapchain->num_contexts = 0;
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+
+        wined3d_cs_emit_evict_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, swapchain);
 }
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_context *context;
-    struct wined3d_surface *target;
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4065,30 +3975,15 @@
         return hr;
     }
 
-    /* Recreate the primary swapchain's context */
-    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-    if (!swapchain->context)
-    {
-        ERR("Failed to allocate memory for swapchain context array.\n");
-        device->blitter->free_private(device);
-        device->shader_backend->shader_free_private(device);
-        return E_OUTOFMEMORY;
-    }
-
-    target = swapchain->back_buffers ? swapchain->back_buffers[0] : swapchain->front_buffer;
-    if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+    hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+    if (FAILED(hr))
     {
         WARN("Failed to create context.\n");
         device->blitter->free_private(device);
         device->shader_backend->shader_free_private(device);
-        HeapFree(GetProcessHeap(), 0, swapchain->context);
-        return E_FAIL;
+        return hr;
     }
-
-    swapchain->context[0] = context;
-    swapchain->num_contexts = 1;
-    create_dummy_textures(device, context);
-    context_release(context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     return WINED3D_OK;
 }
@@ -4109,30 +4004,38 @@
 
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p.\n", device, swapchain_desc, mode, callback);
 
+    if (wined3d_use_csmt(device))
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
         ERR("Failed to get the first implicit swapchain.\n");
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (reset_state)
-        state_unbind_resources(&device->state);
-
-    if (device->fb.render_targets)
+    if (device->state.fb.render_targets)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
             wined3d_device_set_render_target(device, i, NULL, FALSE);
         }
-        if (swapchain->back_buffers && swapchain->back_buffers[0])
-            wined3d_device_set_render_target(device, 0, swapchain->back_buffers[0], FALSE);
     }
+
     wined3d_device_set_depth_stencil(device, NULL);
 
-    if (device->onscreen_depth_stencil)
+    if (reset_state)
     {
-        wined3d_surface_decref(device->onscreen_depth_stencil);
-        device->onscreen_depth_stencil = NULL;
+        state_unbind_resources(&device->state);
+    }
+
+    if (device->cs->onscreen_depth_stencil)
+    {
+        wined3d_surface_decref(device->cs->onscreen_depth_stencil);
+        device->cs->onscreen_depth_stencil = NULL;
     }
 
     if (reset_state)
@@ -4219,10 +4122,6 @@
         }
     }
 
-    /* Reset the depth stencil */
-    if (swapchain_desc->enable_auto_depth_stencil)
-        wined3d_device_set_depth_stencil(device, device->auto_depth_stencil);
-
     if (mode)
     {
         DisplayModeChanged = TRUE;
@@ -4390,32 +4289,39 @@
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
-        if (FAILED(hr = state_init(&device->state, &device->fb, &device->adapter->gl_info,
+        if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
             ERR("Failed to initialize device state, hr %#x.\n", hr);
+        wined3d_cs_emit_reset_state(device->cs);
         device->update_state = &device->state;
 
         device_init_swapchain_state(device, swapchain);
     }
     else
     {
-        struct wined3d_surface *rt = device->fb.render_targets[0];
         struct wined3d_state *state = &device->state;
 
         /* Note the min_z / max_z is not reset. */
         state->viewport.x = 0;
         state->viewport.y = 0;
-        state->viewport.width = rt->resource.width;
-        state->viewport.height = rt->resource.height;
+        state->viewport.width = swapchain->desc.backbuffer_width;
+        state->viewport.height = swapchain->desc.backbuffer_height;
         wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
 
         state->scissor_rect.top = 0;
         state->scissor_rect.left = 0;
-        state->scissor_rect.right = rt->resource.width;
-        state->scissor_rect.bottom = rt->resource.height;
+        state->scissor_rect.right = swapchain->desc.backbuffer_width;
+        state->scissor_rect.bottom = swapchain->desc.backbuffer_height;
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
+    if (swapchain->back_buffers && swapchain->back_buffers[0])
+        wined3d_device_set_render_target(device, 0, swapchain->back_buffers[0], FALSE);
+
+    /* Reset the depth stencil */
+    if (swapchain_desc->enable_auto_depth_stencil)
+        wined3d_device_set_depth_stencil(device, device->auto_depth_stencil);
+
     swapchain_update_render_to_fbo(swapchain);
     swapchain_update_draw_bindings(swapchain);
 
@@ -4503,17 +4409,17 @@
 
                 for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
                 {
-                    if (device->fb.render_targets[i] == surface)
+                    if (device->state.fb.render_targets[i] == surface)
                     {
                         ERR("Surface %p is still in use as render target %u.\n", surface, i);
-                        device->fb.render_targets[i] = NULL;
+                        device->state.fb.render_targets[i] = NULL;
                     }
                 }
 
-                if (device->fb.depth_stencil == surface)
+                if (device->state.fb.depth_stencil == surface)
                 {
                     ERR("Surface %p is still in use as depth/stencil buffer.\n", surface);
-                    device->fb.depth_stencil = NULL;
+                    device->state.fb.depth_stencil = NULL;
                 }
             }
             break;
@@ -4654,7 +4560,7 @@
 
     device->blitter = adapter->blitter;
 
-    if (FAILED(hr = state_init(&device->state, &device->fb, &adapter->gl_info,
+    if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
     {
         ERR("Failed to initialize device state, hr %#x.\n", hr);
@@ -4750,3 +4656,56 @@
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffersARB(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBufferARB(type_hint, ret->name));
+    GL_EXTCALL(glBufferDataARB(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBufferARB(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffersARB(1, &bo->name));
+    checkGLcall("glDeleteBuffersARB");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
diff -Naur a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
--- a/dlls/wined3d/directx.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/directx.c	2013-11-07 21:40:10.000000000 +0000
@@ -277,7 +277,7 @@
         ERR("wglDeleteContext(%p) failed, last error %#x.\n", ctx->gl_ctx, err);
     }
 
-    ReleaseDC(ctx->wnd, ctx->dc);
+    wined3d_release_dc(ctx->wnd, ctx->dc);
     DestroyWindow(ctx->wnd);
 
     if (ctx->restore_gl_ctx && !wglMakeCurrent(ctx->restore_dc, ctx->restore_gl_ctx))
@@ -595,6 +595,45 @@
     return TRUE;
 }
 
+static BOOL match_apple_ati(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    return gl_vendor == GL_VENDOR_APPLE && card_vendor == HW_VENDOR_AMD;
+}
+
+static BOOL match_apple_ati_sl(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    /* ATI cards on Snow Leopard support GL_ARB_texture_rg, but not on Leopard, according
+     * to Apple's OpenGL capabilities matrix. Nvidia cards don't support it, but that's ok
+     * for this matcher since its only intended for ATI anyway.
+     */
+    if(!gl_info->supported[ARB_TEXTURE_RG]) return FALSE;
+    return match_apple_ati(gl_info, gl_renderer, gl_vendor, card_vendor, device);
+}
+
+static BOOL match_broken_ara(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    if (!gl_info->supported[NV_VERTEX_PROGRAM2_OPTION]) return FALSE;
+    if (gl_vendor != GL_VENDOR_APPLE) return FALSE;
+
+    switch (device)
+    {
+        /* There are no intel macs with pre-geforce 7 cards. ARA works on pre-gf8 cards */
+        case CARD_NVIDIA_GEFORCE_7400:
+        case CARD_NVIDIA_GEFORCE_7300:
+        case CARD_NVIDIA_GEFORCE_7600:
+        case CARD_NVIDIA_GEFORCE_7800GT:
+            /* ARA works on GF7 cards */
+            return FALSE;
+
+        default:
+            /* Assume ARA is broken */
+            return TRUE;
+    }
+}
+
 static BOOL match_dx10_capable(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -608,6 +647,45 @@
     return gl_info->limits.glsl_varyings > 44;
 }
 
+static BOOL match_apple_broken_uniforms(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+                                        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    const char *sysrelease;
+    unsigned int major, minor, ret;
+    void (CDECL *my_wine_get_host_version)(const char **sysname, const char **release);
+
+    /* MacOS dx9 GPU drivers more GLSL vertex shader uniforms than supported by the hardware, and if
+     * more are used it falls back to software. While the compiler can detect if the shader uses all
+     * declared uniforms, the optimization fails if the shader uses relative addressing. So any GLSL
+     * shader using relative addressing falls back to software.
+     *
+     * ARB vp gives the correct amount of uniforms, so use it instead of GLSL.
+     *
+     * In addition, AMD Radeon HD GPUs advertise > 256 constants and can support this in HW, but the
+     * driver nevertheless falls back to software if more than 256 are used. This is fixed in MacOS
+     * 10.8.3 */
+
+    /* Non-Apple GL vendors report uniforms correctly */
+    if (!match_apple(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return FALSE;
+    /* All dx9 cards are overreported on OSX */
+    if (!match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return TRUE;
+    /* Nvidia and Intel DX10 cards support > 256 uniforms */
+    if (card_vendor != HW_VENDOR_AMD) return FALSE;
+
+    /* On OSX 10.8.3 and later, AMD GPUs support more than 256 constants. This OSX version reports
+     * uname -r "12.3.0" */
+    my_wine_get_host_version = (void *)GetProcAddress(GetModuleHandleA("ntdll.dll"), "wine_get_host_version");
+    if (!my_wine_get_host_version) return FALSE;
+
+    my_wine_get_host_version(NULL, &sysrelease);
+    ret = sscanf(sysrelease, "%u.%u", &major, &minor);
+    if (ret != 2) return FALSE; /* String format changed, assume workaround not needed */
+    if (major > 12) return FALSE;
+    if (major == 12 && minor >= 3) return FALSE;
+
+    return TRUE;
+}
+
 static BOOL match_not_dx10_capable(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -768,6 +846,14 @@
     return gl_vendor == GL_VENDOR_FGLRX;
 }
 
+static void quirk_arb_constants(struct wined3d_gl_info *gl_info)
+{
+    TRACE("Using ARB vs constant limit(=%u) for GLSL.\n", gl_info->limits.arb_vs_native_constants);
+    gl_info->limits.glsl_vs_float_constants = gl_info->limits.arb_vs_native_constants;
+    TRACE("Using ARB ps constant limit(=%u) for GLSL.\n", gl_info->limits.arb_ps_native_constants);
+    gl_info->limits.glsl_ps_float_constants = gl_info->limits.arb_ps_native_constants;
+}
+
 static BOOL match_r200(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -871,6 +957,36 @@
     return data[0] != 0x00ff0000 || data[3] != 0x0000ff00;
 }
 
+static BOOL match_nvidia_multithreading(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    char buffer[2];
+    DWORD ret;
+
+    if (gl_vendor != GL_VENDOR_NVIDIA) return FALSE;
+
+    SetLastError(0);
+    ret = GetEnvironmentVariableA("__GL_THREADED_OPTIMIZATIONS", buffer, sizeof(buffer));
+
+    /* The nvidia driver enables its threaded optimizations when the variable is set
+     * and not "0", "n" or "N". Even a value like "00", "NN" or "" enables it */
+    if (!ret)
+        return !GetLastError();
+    if (ret > 1)
+        return TRUE;
+
+    switch(buffer[0])
+    {
+        case 'n':
+        case 'N':
+        case '0':
+            return FALSE;
+
+        default:
+            return TRUE;
+    }
+}
+
 static void quirk_apple_glsl_constants(struct wined3d_gl_info *gl_info)
 {
     /* MacOS needs uniforms for relative addressing offsets. This can accumulate to quite a few uniforms.
@@ -956,11 +1072,45 @@
     gl_info->quirks |= WINED3D_QUIRK_NV_CLIP_BROKEN;
 }
 
+static void quirk_compressed_cube(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_COMPRESSED_CUBE_MIP;
+}
+
+static void quirk_apple_no_glsl_clip(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN;
+}
+
+static void texcoord_fog_quirk(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_TEXCOORD_FOG;
+}
+
+static void broken_ara_quirk(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_BROKEN_ARA;
+}
+
+static void fbo_blit_quirk(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_BLIT;
+}
+
 static void quirk_fbo_tex_update(struct wined3d_gl_info *gl_info)
 {
     gl_info->quirks |= WINED3D_QUIRK_FBO_TEX_UPDATE;
 }
 
+static void render_to_fbo_quirk(struct wined3d_gl_info *gl_info)
+{
+    /* Mac OSX 10.6(Snow Leopard) has a bug when glBlitFramebufferEXT
+     * is called to copy from the onscreen backbuffer to a framebuffer.
+     * Render the swapchain to a FBO to avoid from-backbuffer blits.
+     */
+    gl_info->quirks |= WINED3D_CX_QUIRK_RENDER_TO_FBO;
+}
+
 static void quirk_broken_rgba16(struct wined3d_gl_info *gl_info)
 {
     gl_info->quirks |= WINED3D_QUIRK_BROKEN_RGBA16;
@@ -981,6 +1131,11 @@
     gl_info->quirks |= WINED3D_QUIRK_LIMITED_TEX_FILTERING;
 }
 
+static void quirk_apple_double_buffer(struct wined3d_gl_info *gl_info)
+{
+    gl_info->quirks |= WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER;
+}
+
 static void quirk_r200_constants(struct wined3d_gl_info *gl_info)
 {
     /* The Mesa r200 driver (and there is no other driver for this GPU Wine would run on)
@@ -1007,6 +1162,14 @@
     const char *description;
 };
 
+static void quirk_mapbuffer(struct wined3d_gl_info *gl_info)
+{
+    if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_STATIC_NV)
+        cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_STATIC;
+    else if (cxgames_hacks.allow_glmapbuffer == WINED3D_MAPBUF_NEVER_NV)
+        cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_NEVER;
+}
+
 static const struct driver_quirk quirk_table[] =
 {
     {
@@ -1017,8 +1180,21 @@
     {
         match_apple,
         quirk_apple_glsl_constants,
+        "Reserving 12 GLSL uniforms on OSX"
+    },
+    {
+        match_apple_broken_uniforms,
+        quirk_arb_constants,
         "Apple GLSL uniform override"
     },
+    /* Additionally to matching the apple vendor this code could try to compile a testing NVvp shader
+     * that writes to result.clip[n]. This syntax is broken on osx
+     */
+    {
+        match_apple,
+        quirk_apple_no_glsl_clip,
+        "Disabled vertex shader clipping on Macs"
+    },
     {
         match_geforce5,
         quirk_no_np2,
@@ -1029,6 +1205,13 @@
         quirk_texcoord_w,
         "Init texcoord .w for Apple Intel GPU driver"
     },
+    /* Used as a workaround for Apple X3100 cards, where linear mipmapping fails
+     * on compressed cube maps. Rdar 6963094. */
+    {
+        match_apple_intel,
+        quirk_compressed_cube,
+        "Disabled compressed cube maps on Apple Intel GPU driver"
+    },
     {
         match_apple_nonr500ati,
         quirk_texcoord_w,
@@ -1040,6 +1223,17 @@
         "Reserved varying for gl_ClipPos"
     },
     {
+        match_amd_r300_to_500,
+        texcoord_fog_quirk,
+        "Disable fog if 8 texcoords are used"
+    },
+    {
+        /* GL_NV_vertex_program2's ARA instruction is broken on gf8+ cards on OSX. */
+        match_broken_ara,
+        broken_ara_quirk,
+        "Disable broken ARA instruction"
+    },
+    {
         /* GL_EXT_secondary_color does not allow 4 component secondary colors, but most
          * GL implementations accept it. The Mac GL is the only implementation known to
          * reject it.
@@ -1060,6 +1254,11 @@
         "Apple NV_vertex_program clip bug quirk"
     },
     {
+        match_apple_ati,
+        fbo_blit_quirk,
+        "GL_EXT_framebuffer_blit glBlendFunc and glColorMask quirk"
+    },
+    {
         match_fbo_tex_update,
         quirk_fbo_tex_update,
         "FBO rebind for attachment updates"
@@ -1080,6 +1279,16 @@
         "Texture filtering, blending and VTF support is limited"
     },
     {
+        match_apple_ati_sl,
+        render_to_fbo_quirk,
+        "Render to FBO quirk"
+    },
+    {
+        match_apple,
+        quirk_apple_double_buffer,
+        "Apple double buffered context bug (9330)"
+    },
+    {
         match_r200,
         quirk_r200_constants,
         "r200 vertex shader constants"
@@ -1089,8 +1298,32 @@
         quirk_broken_arb_fog,
         "ARBfp fogstart == fogend workaround"
     },
+    {
+        match_nvidia_multithreading,
+        quirk_mapbuffer,
+        "NVidia multithreading glMapBuffer[Range] quirk"
+    },
 };
 
+/* NOT a quirk function! */
+static void apply_auto_glsl(struct wined3d_gl_info *gl_info, enum wined3d_gl_vendor gl_vendor,
+        enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    /* Disable GLSL if NV asm extensions are supported */
+    if(gl_info->supported[NV_VERTEX_PROGRAM2_OPTION] && gl_info->supported[NV_FRAGMENT_PROGRAM_OPTION]
+            && gl_info->limits.arb_vs_float_constants >= 256 && gl_info->limits.arb_vs_native_constants >= 256
+            && gl_info->limits.arb_ps_float_constants >= 256 && gl_info->limits.arb_ps_native_constants >= 256)
+    {
+        TRACE("Auto GLSL: Not using GLSL because NV asm extensions are supported\n");
+        gl_info->supported[ARB_VERTEX_SHADER] = FALSE;
+        gl_info->supported[ARB_FRAGMENT_SHADER] = FALSE;
+        return;
+    }
+
+    /* Otherwise use GLSL */
+    TRACE("Auto GLSL: Using GLSL\n");
+}
+
 /* Certain applications (Steam) complain if we report an outdated driver version. In general,
  * reporting a driver version is moot because we are not the Windows driver, and we have different
  * bugs, features, etc.
@@ -1514,6 +1747,29 @@
         quirk_table[i].apply(gl_info);
     }
 
+    if (gl_info->supported[APPLE_CLIENT_STORAGE])
+    {
+        if (cxgames_hacks.allow_apple_client_storage == CLIENTSTORAGE_DISABLE)
+        {
+            TRACE("Client storage disabled\n");
+            gl_info->supported[APPLE_CLIENT_STORAGE] = FALSE;
+        }
+        else if (cxgames_hacks.allow_apple_client_storage == CLIENTSTORAGE_DISABLE_NVIDIA_GF7
+                && (card_vendor != HW_VENDOR_NVIDIA || strstr(gl_renderer, "GeForce 8")))
+        {
+            TRACE("Client storage enabled for non-nvidia or gf8 card\n");
+        }
+        else if (cxgames_hacks.allow_apple_client_storage == CLIENTSTORAGE_ENABLE)
+        {
+            TRACE("Client storage enabled\n");
+        }
+        else
+        {
+            TRACE("Client storage disabled for gf7 card\n");
+            gl_info->supported[APPLE_CLIENT_STORAGE] = FALSE;
+        }
+    }
+
     /* Find out if PBOs work as they are supposed to. */
     test_pbo_functionality(gl_info);
 }
@@ -2441,7 +2697,7 @@
 
 static const struct wined3d_shader_backend_ops *select_shader_backend(const struct wined3d_gl_info *gl_info)
 {
-    BOOL glsl = wined3d_settings.glslRequested && gl_info->glsl_version >= MAKEDWORD_VERSION(1, 20);
+    BOOL glsl = wined3d_settings.glslRequested != GLSL_DISABLED && gl_info->glsl_version >= MAKEDWORD_VERSION(1, 20);
 
     if (glsl && gl_info->supported[ARB_FRAGMENT_SHADER])
         return &glsl_shader_backend;
@@ -2504,6 +2760,38 @@
     }
 }
 
+static void disable_extensions(struct wined3d_gl_info *gl_info, const char *extensions,
+        const struct wined3d_extension_map *map, UINT entry_count)
+{
+    while (*extensions)
+    {
+        const char *start;
+        size_t len;
+        UINT i;
+
+        while (isspace(*extensions))
+            ++extensions;
+        start = extensions;
+        while (!isspace(*extensions) && *extensions)
+            ++extensions;
+
+        len = extensions - start;
+        if (!len)
+            continue;
+
+        for (i = 0; i < entry_count; ++i)
+        {
+            if (len == strlen(map[i].extension_string)
+                    && !memcmp(start, map[i].extension_string, len))
+            {
+                TRACE(" DISABLING: %s.\n", map[i].extension_string);
+                gl_info->supported[map[i].extension] = FALSE;
+                break;
+            }
+        }
+    }
+}
+
 static void load_gl_funcs(struct wined3d_gl_info *gl_info)
 {
 #define USE_GL_FUNC(pfn) gl_info->gl_ops.ext.p_##pfn = (void *)wglGetProcAddress(#pfn);
@@ -2726,6 +3014,14 @@
     }
 }
 
+/* CodeWeavers HACK bug 10104
+ * Allow a registry key to dictate the number of vertex constants. */ 
+static void fix_vs_constants(struct wined3d_gl_info *gl_info)
+{
+    if(cxgames_hacks.fixed_vs_constants_limit)
+        gl_info->limits.glsl_vs_float_constants = cxgames_hacks.fixed_vs_constants_limit;
+}
+
 /* Context activation is done by the caller. */
 static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
 {
@@ -2822,6 +3118,15 @@
         gl_info->supported[ARB_TEXTURE_NON_POWER_OF_TWO] = TRUE;
     }
 
+    /* CodeWeavers Hack bug 5501 - Allow registry disabling of OpenGL extensions. */
+    if (cxgames_hacks.disabled_extensions)
+    {
+        disable_extensions(gl_info, cxgames_hacks.disabled_extensions, gl_extension_map,
+                sizeof(gl_extension_map) / sizeof(*gl_extension_map));
+        disable_extensions(gl_info, cxgames_hacks.disabled_extensions, wgl_extension_map,
+                sizeof(wgl_extension_map) / sizeof(*wgl_extension_map));
+    }
+
     if (gl_version >= MAKEDWORD_VERSION(2, 0)) gl_info->supported[WINED3D_GL_VERSION_2_0] = TRUE;
 
     if (gl_info->supported[APPLE_FENCE])
@@ -2950,26 +3255,12 @@
 
     checkGLcall("extension detection");
 
-    adapter->shader_backend = select_shader_backend(gl_info);
-    adapter->vertex_pipe = select_vertex_implementation(gl_info, adapter->shader_backend);
-    adapter->fragment_pipe = select_fragment_implementation(gl_info, adapter->shader_backend);
-    adapter->blitter = select_blit_implementation(gl_info, adapter->shader_backend);
-
-    adapter->shader_backend->shader_get_caps(&adapter->gl_info, &shader_caps);
-    adapter->d3d_info.vs_clipping = shader_caps.wined3d_caps & WINED3D_SHADER_CAP_VS_CLIPPING;
-    adapter->d3d_info.limits.vs_version = shader_caps.vs_version;
-    adapter->d3d_info.limits.gs_version = shader_caps.gs_version;
-    adapter->d3d_info.limits.ps_version = shader_caps.ps_version;
-    adapter->d3d_info.limits.vs_uniform_count = shader_caps.vs_uniform_count;
-    adapter->d3d_info.limits.ps_uniform_count = shader_caps.ps_uniform_count;
-
-    adapter->vertex_pipe->vp_get_caps(gl_info, &vertex_caps);
-    adapter->d3d_info.xyzrhw = vertex_caps.xyzrhw;
+    gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
+    card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
+    TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
 
-    adapter->fragment_pipe->get_caps(gl_info, &fragment_caps);
-    adapter->d3d_info.limits.ffp_blend_stages = fragment_caps.MaxTextureBlendStages;
-    adapter->d3d_info.limits.ffp_textures = fragment_caps.MaxSimultaneousTextures;
-    TRACE("Max texture stages: %u.\n", adapter->d3d_info.limits.ffp_blend_stages);
+    device = wined3d_guess_card(gl_info, gl_renderer_str, &gl_vendor, &card_vendor);
+    TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
 
     if (gl_info->supported[ARB_FRAMEBUFFER_OBJECT])
     {
@@ -3033,13 +3324,6 @@
         }
     }
 
-    gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
-    card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
-    TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
-
-    device = wined3d_guess_card(gl_info, gl_renderer_str, &gl_vendor, &card_vendor);
-    TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
-
     gl_info->wrap_lookup[WINED3D_TADDRESS_WRAP - WINED3D_TADDRESS_WRAP] = GL_REPEAT;
     gl_info->wrap_lookup[WINED3D_TADDRESS_MIRROR - WINED3D_TADDRESS_WRAP] =
             gl_info->supported[ARB_TEXTURE_MIRRORED_REPEAT] ? GL_MIRRORED_REPEAT_ARB : GL_REPEAT;
@@ -3054,9 +3338,34 @@
         adapter->d3d_info.valid_rt_mask |= (1 << i);
 
     fixup_extensions(gl_info, gl_renderer_str, gl_vendor, card_vendor, device);
+    fix_vs_constants(gl_info);
     init_driver_info(driver_info, card_vendor, device);
     add_gl_compat_wrappers(gl_info);
 
+    if (wined3d_settings.glslRequested == GLSL_AUTO)
+        apply_auto_glsl(gl_info, gl_vendor, card_vendor, device);
+
+    adapter->shader_backend = select_shader_backend(gl_info);
+    adapter->vertex_pipe = select_vertex_implementation(gl_info, adapter->shader_backend);
+    adapter->fragment_pipe = select_fragment_implementation(gl_info, adapter->shader_backend);
+    adapter->blitter = select_blit_implementation(gl_info, adapter->shader_backend);
+
+    adapter->shader_backend->shader_get_caps(&adapter->gl_info, &shader_caps);
+    adapter->d3d_info.vs_clipping = shader_caps.wined3d_caps & WINED3D_SHADER_CAP_VS_CLIPPING;
+    adapter->d3d_info.limits.vs_version = shader_caps.vs_version;
+    adapter->d3d_info.limits.gs_version = shader_caps.gs_version;
+    adapter->d3d_info.limits.ps_version = shader_caps.ps_version;
+    adapter->d3d_info.limits.vs_uniform_count = shader_caps.vs_uniform_count;
+    adapter->d3d_info.limits.ps_uniform_count = shader_caps.ps_uniform_count;
+
+    adapter->vertex_pipe->vp_get_caps(gl_info, &vertex_caps);
+    adapter->d3d_info.xyzrhw = vertex_caps.xyzrhw;
+
+    adapter->fragment_pipe->get_caps(gl_info, &fragment_caps);
+    adapter->d3d_info.limits.ffp_blend_stages = fragment_caps.MaxTextureBlendStages;
+    adapter->d3d_info.limits.ffp_textures = fragment_caps.MaxSimultaneousTextures;
+    TRACE("Max texture stages: %u.\n", adapter->d3d_info.limits.ffp_blend_stages);
+
     return TRUE;
 }
 
@@ -3765,6 +4074,10 @@
     if (CheckDepthStencilCapability(adapter, adapter_format, check_format)) return TRUE;
 
     /* If opengl can't process the format natively, the blitter may be able to convert it */
+    if(0) {
+    /* Disabled for now in CrossOver. It is not needed by any supported application, and it currently
+     * breaks quicktime because we cannot do offscreen->offscreen YUV conversions yet
+     */
     if (adapter->blitter->blit_supported(&adapter->gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
             NULL, WINED3D_POOL_DEFAULT, 0, check_format,
             NULL, WINED3D_POOL_DEFAULT, 0, adapter_format))
@@ -3772,6 +4085,7 @@
         TRACE("[OK]\n");
         return TRUE;
     }
+    }
 
     /* Reject other formats */
     TRACE("[FAILED]\n");
@@ -4462,7 +4776,11 @@
 
     caps->MaxUserClipPlanes                = vertex_caps.max_user_clip_planes;
     caps->MaxActiveLights                  = vertex_caps.max_active_lights;
-    caps->MaxVertexBlendMatrices           = vertex_caps.max_vertex_blend_matrices;
+
+    if (cxgames_hacks.max_vertex_blend_matrices && vertex_caps.max_vertex_blend_matrices <= 1)
+        caps->MaxVertexBlendMatrices = cxgames_hacks.max_vertex_blend_matrices;
+    else
+        caps->MaxVertexBlendMatrices           = vertex_caps.max_vertex_blend_matrices;
     caps->MaxVertexBlendMatrixIndex        = vertex_caps.max_vertex_blend_matrix_index;
     caps->VertexProcessingCaps             = vertex_caps.vertex_processing_caps;
     caps->FVFCaps                          = vertex_caps.fvf_caps;
@@ -4707,7 +5025,7 @@
 }
 
 /* Helper functions for providing vertex data to opengl. The arrays are initialized based on
- * the extension detection and are used in drawStridedSlow
+ * the extension detection and are used in draw_strided_slow
  */
 static void WINE_GLAPI position_d3dcolor(const void *data)
 {
diff -Naur a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
--- a/dlls/wined3d/drawprim.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/drawprim.c	2013-11-07 21:40:10.000000000 +0000
@@ -36,7 +36,7 @@
 #include <math.h>
 
 /* Context activation is done by the caller. */
-static void drawStridedFast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
+static void draw_strided_fast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
         const void *idx_data, UINT start_idx, INT base_vertex_index, UINT start_instance, UINT instance_count)
 {
     if (idx_size)
@@ -44,7 +44,7 @@
         GLenum idxtype = idx_size == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT;
         if (instance_count)
         {
-            if (!gl_info->supported[ARB_DRAW_INSTANCED])
+            if (!gl_info->supported[ARB_DRAW_INSTANCED] && !gl_info->supported[ARB_INSTANCED_ARRAYS])
             {
                 FIXME("Instanced drawing not supported.\n");
             }
@@ -52,9 +52,18 @@
             {
                 if (start_instance)
                     FIXME("Start instance (%u) not supported.\n", start_instance);
-                GL_EXTCALL(glDrawElementsInstancedBaseVertex(primitive_type, count, idxtype,
-                        (const char *)idx_data + (idx_size * start_idx), instance_count, base_vertex_index));
-                checkGLcall("glDrawElementsInstancedBaseVertex");
+                if (gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX])
+                {
+                    GL_EXTCALL(glDrawElementsInstancedBaseVertex(primitive_type, count, idxtype,
+                            (const char *)idx_data + (idx_size * start_idx), instance_count, base_vertex_index));
+                    checkGLcall("glDrawElementsInstancedBaseVertex");
+                }
+                else
+                {
+                    GL_EXTCALL(glDrawElementsInstancedARB(primitive_type, count, idxtype,
+                            (const char *)idx_data + (idx_size * start_idx), instance_count));
+                    checkGLcall("glDrawElementsInstancedARB");
+                }
             }
         }
         else if (gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX])
@@ -83,7 +92,7 @@
  */
 
 /* Context activation is done by the caller. */
-static void drawStridedSlow(const struct wined3d_device *device, struct wined3d_context *context,
+static void draw_strided_slow(const struct wined3d_state *state, struct wined3d_context *context,
         const struct wined3d_stream_info *si, UINT NumVertexes, GLenum glPrimType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -91,7 +100,6 @@
     const WORD                *pIdxBufS     = NULL;
     const DWORD               *pIdxBufL     = NULL;
     UINT vx_index;
-    const struct wined3d_state *state = &device->state;
     LONG SkipnStrides = startIdx;
     BOOL pixelShader = use_ps(state);
     BOOL specular_fog = FALSE;
@@ -441,7 +449,7 @@
 }
 
 /* Context activation is done by the caller. */
-static void drawStridedSlowVs(struct wined3d_context *context, const struct wined3d_state *state,
+static void draw_strided_slow_vs(struct wined3d_context *context, const struct wined3d_state *state,
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -498,7 +506,7 @@
 }
 
 /* Context activation is done by the caller. */
-static void drawStridedInstanced(struct wined3d_context *context, const struct wined3d_state *state,
+static void draw_strided_instanced(struct wined3d_context *context, const struct wined3d_state *state,
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx, UINT base_vertex_index, UINT instance_count)
 {
@@ -583,10 +591,10 @@
 }
 
 /* Routine common to the draw primitive and draw indexed primitive routines */
-void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed)
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed)
 {
-    const struct wined3d_state *state = &device->state;
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_stream_info si_emulated;
@@ -599,21 +607,21 @@
 
     if (!index_count) return;
 
+    context = context_acquire(device, state->fb.render_targets[0]);
     if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
     {
         /* Invalidate the back buffer memory so LockRect will read it the next time */
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
-            struct wined3d_surface *target = device->fb.render_targets[i];
+            struct wined3d_surface *target = state->fb.render_targets[i];
             if (target)
             {
-                surface_load_location(target, target->draw_binding, NULL);
-                surface_invalidate_location(target, ~target->draw_binding);
+                wined3d_resource_load_location(&target->resource, context, target->draw_binding);
+                wined3d_resource_invalidate_location(&target->resource, ~target->draw_binding);
             }
         }
     }
 
-    context = context_acquire(device, device->fb.render_targets[0]);
     if (!context->valid)
     {
         context_release(context);
@@ -622,21 +630,21 @@
     }
     gl_info = context->gl_info;
 
-    if (device->fb.depth_stencil)
+    if (state->fb.depth_stencil)
     {
         /* Note that this depends on the context_acquire() call above to set
          * context->render_offscreen properly. We don't currently take the
          * Z-compare function into account, but we could skip loading the
          * depthstencil for D3DCMP_NEVER and D3DCMP_ALWAYS as well. Also note
          * that we never copy the stencil data.*/
-        DWORD location = context->render_offscreen ? device->fb.depth_stencil->draw_binding : SFLAG_INDRAWABLE;
+        DWORD location = context->render_offscreen ? state->fb.depth_stencil->draw_binding : WINED3D_LOCATION_DRAWABLE;
         if (state->render_states[WINED3D_RS_ZWRITEENABLE] || state->render_states[WINED3D_RS_ZENABLE])
         {
-            struct wined3d_surface *ds = device->fb.depth_stencil;
+            struct wined3d_surface *ds = state->fb.depth_stencil;
             RECT current_rect, draw_rect, r;
 
-            if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
-                device_switch_onscreen_ds(device, context, ds);
+            if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
+                wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
 
             if (ds->flags & location)
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
@@ -651,17 +659,17 @@
         }
     }
 
-    if (!context_apply_draw_state(context, device))
+    if (!context_apply_draw_state(context, device, state))
     {
         context_release(context);
         WARN("Unable to apply draw state, skipping draw.\n");
         return;
     }
 
-    if (device->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
+    if (state->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
-        DWORD location = context->render_offscreen ? ds->draw_binding : SFLAG_INDRAWABLE;
+        struct wined3d_surface *ds = state->fb.depth_stencil;
+        DWORD location = context->render_offscreen ? ds->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
         surface_modify_ds_location(ds, location, ds->ds_current_size.cx, ds->ds_current_size.cy);
     }
@@ -743,24 +751,24 @@
             else
                 WARN_(d3d_perf)("Using immediate mode with vertex shaders for half float emulation.\n");
 
-            drawStridedSlowVs(context, state, stream_info, index_count,
+            draw_strided_slow_vs(context, state, stream_info, index_count,
                     state->gl_primitive_type, idx_data, idx_size, start_idx);
         }
         else
         {
-            drawStridedSlow(device, context, stream_info, index_count,
+            draw_strided_slow(state, context, stream_info, index_count,
                     state->gl_primitive_type, idx_data, idx_size, start_idx);
         }
     }
     else if (!gl_info->supported[ARB_INSTANCED_ARRAYS] && instance_count)
     {
         /* Instancing emulation by mixing immediate mode and arrays. */
-        drawStridedInstanced(context, state, stream_info, index_count, state->gl_primitive_type,
+        draw_strided_instanced(context, state, stream_info, index_count, state->gl_primitive_type,
                 idx_data, idx_size, start_idx, state->base_vertex_index, instance_count);
     }
     else
     {
-        drawStridedFast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
+        draw_strided_fast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
                 start_idx, state->base_vertex_index, start_instance, instance_count);
     }
 
diff -Naur a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
--- a/dlls/wined3d/glsl_shader.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/glsl_shader.c	2013-11-07 21:40:10.000000000 +0000
@@ -146,6 +146,7 @@
     GLhandleARB programId;
     DWORD constant_update_mask;
     UINT constant_version;
+    DWORD clipplanes;
 };
 
 struct glsl_program_key
@@ -153,6 +154,7 @@
     GLhandleARB vs_id;
     GLhandleARB gs_id;
     GLhandleARB ps_id;
+    DWORD clipplanes;
 };
 
 struct shader_glsl_ctx_priv {
@@ -193,6 +195,7 @@
         struct glsl_ps_compiled_shader *ps;
     } gl_shaders;
     UINT num_gl_shaders, shader_array_size;
+    DWORD clipplane_emulation;
 };
 
 struct glsl_ffp_vertex_shader
@@ -323,11 +326,17 @@
 /* Context activation is done by the caller. */
 static void shader_glsl_compile(const struct wined3d_gl_info *gl_info, GLhandleARB shader, const char *src)
 {
+    WORD old_fpu_cw = wined3d_get_fpu_cw();
+
     TRACE("Compiling shader object %u.\n", shader);
     GL_EXTCALL(glShaderSourceARB(shader, 1, &src, NULL));
     checkGLcall("glShaderSourceARB");
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(WINED3D_DEFAULT_FPU_CW);
     GL_EXTCALL(glCompileShaderARB(shader));
     checkGLcall("glCompileShaderARB");
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(old_fpu_cw);
     print_glsl_info_log(gl_info, shader);
 }
 
@@ -966,10 +975,8 @@
         const struct wined3d_shader_reg_maps *reg_maps, const struct shader_glsl_ctx_priv *ctx_priv)
 {
     const struct wined3d_shader_version *version = &reg_maps->shader_version;
-    const struct wined3d_state *state = &shader->device->state;
     const struct ps_compile_args *ps_args = ctx_priv->cur_ps_args;
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_fb_state *fb = &shader->device->fb;
     unsigned int i, extra_constants_needed = 0;
     const struct wined3d_shader_lconst *lconst;
     const char *prefix;
@@ -1025,9 +1032,17 @@
                  * Writing gl_ClipVertex requires one uniform for each
                  * clipplane as well. */
                 max_constantsF = gl_info->limits.glsl_vs_float_constants - 3;
-                if(ctx_priv->cur_vs_args->clip_enabled)
+                if (ctx_priv->cur_vs_args->clip_enabled)
                 {
-                    max_constantsF -= gl_info->limits.clipplanes;
+                    if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+                    {
+                        /* The link program reads at most 4 clipplanes to emulate clipping */
+                        max_constantsF -= 4;
+                    }
+                    else
+                    {
+                        max_constantsF -= gl_info->limits.clipplanes;
+                    }
                 }
                 max_constantsF -= count_bits(reg_maps->integer_constants);
                 /* Strictly speaking a bool only uses one scalar, but the nvidia(Linux) compiler doesn't pack them properly,
@@ -1194,7 +1209,7 @@
         {
             UINT in_count = min(vec4_varyings(version->major, gl_info), shader->limits.packed_input);
 
-            if (use_vs(state))
+            if (ps_args->vp_mode == vertexshader)
                 shader_addline(buffer, "varying vec4 %s_in[%u];\n", prefix, in_count);
             else
                 /* TODO: Write a replacement shader for the fixed function
@@ -1241,21 +1256,14 @@
             }
             else
             {
-                float ycorrection[] =
-                {
-                    context->render_offscreen ? 0.0f : fb->render_targets[0]->resource.height,
-                    context->render_offscreen ? 1.0f : -1.0f,
-                    0.0f,
-                    0.0f,
-                };
-
                 /* This happens because we do not have proper tracking of the
                  * constant registers that are actually used, only the max
-                 * limit of the shader version. */
+                 * limit of the shader version.
+                 *
+                 * FIXME 2: This is wrong, there's no need to do this. Get rid of
+                 * it and just create the uniform.
+                 */
                 FIXME("Cannot find a free uniform for vpos correction params\n");
-                shader_addline(buffer, "const vec4 ycorrection = ");
-                shader_glsl_append_imm_vec4(buffer, ycorrection);
-                shader_addline(buffer, ";\n");
             }
             shader_addline(buffer, "vec4 vpos;\n");
         }
@@ -4186,6 +4194,24 @@
  * Vertex Shader Specific Code begins here
  ********************************************/
 
+static DWORD find_clipplanes(const struct wined3d_context *context,
+                             const struct wined3d_state *state,
+                             const struct wined3d_gl_info *gl_info,
+                             const struct wined3d_d3d_info *d3d_info )
+{
+    /* If HW clipping is used, no clipplane emulation */
+    if (!(gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)) return 0;
+    /* If clipping is disabled, no clipplanes are needed */
+    if (!state->render_states[WINED3D_RS_CLIPPING]) return 0;
+    /* With pixelshaders, emulate all enabled clipplanes(disabled per shader
+     * if no free texcoord is found. */
+    if (use_ps(state)) return state->render_states[WINED3D_RS_CLIPPLANEENABLE];
+    /* With FFP, if all texcoords are used, don't emulate clipplanes */
+    if (context->lowest_disabled_stage >= d3d_info->limits.ffp_blend_stages) return 0;
+    /* Otherwise(FFP with highest texcoord free) emulate all enabled planes */
+    return state->render_states[WINED3D_RS_CLIPPLANEENABLE];
+}
+
 static void add_glsl_program_entry(struct shader_glsl_priv *priv, struct glsl_shader_prog_link *entry)
 {
     struct glsl_program_key key;
@@ -4193,6 +4219,7 @@
     key.vs_id = entry->vs.id;
     key.gs_id = entry->gs.id;
     key.ps_id = entry->ps.id;
+    key.clipplanes = entry->clipplanes;
 
     if (wine_rb_put(&priv->program_lookup, &key, &entry->program_lookup_entry) == -1)
     {
@@ -4201,7 +4228,11 @@
 }
 
 static struct glsl_shader_prog_link *get_glsl_program_entry(const struct shader_glsl_priv *priv,
-        GLhandleARB vs_id, GLhandleARB gs_id, GLhandleARB ps_id)
+                                                            GLhandleARB vs_id, GLhandleARB gs_id, GLhandleARB ps_id,
+                                                            const struct wined3d_context *context,
+                                                            const struct wined3d_state *state,
+                                                            const struct wined3d_gl_info *gl_info,
+                                                            const struct wined3d_d3d_info *d3d_info )
 {
     struct wine_rb_entry *entry;
     struct glsl_program_key key;
@@ -4209,6 +4240,7 @@
     key.vs_id = vs_id;
     key.gs_id = gs_id;
     key.ps_id = ps_id;
+    key.clipplanes = find_clipplanes(context, state, gl_info, d3d_info);
 
     entry = wine_rb_get(&priv->program_lookup, &key);
     return entry ? WINE_RB_ENTRY_VALUE(entry, struct glsl_shader_prog_link, program_lookup_entry) : NULL;
@@ -4223,6 +4255,7 @@
     key.vs_id = entry->vs.id;
     key.gs_id = entry->gs.id;
     key.ps_id = entry->ps.id;
+    key.clipplanes = entry->clipplanes;
     wine_rb_remove(&priv->program_lookup, &key);
 
     GL_EXTCALL(glDeleteObjectARB(entry->programId));
@@ -4330,10 +4363,60 @@
     HeapFree(GetProcessHeap(), 0, set);
 }
 
+static void glsl_gen_clipplane_emul(const struct wined3d_shader *ps, struct wined3d_shader_buffer *buffer,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
+        DWORD enabled_clipplanes)
+{
+    DWORD clip_coord = 0;
+
+    /* Generate a clipplane emulation texcoord if native clipplanes are broken */
+    if(ps)
+    {
+        struct glsl_shader_private *shader_priv = ps->backend_data;
+        clip_coord = shader_priv->clipplane_emulation;
+    }
+    else if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+    {
+        clip_coord = d3d_info->limits.ffp_blend_stages;
+    }
+
+    if(clip_coord)
+    {
+        unsigned int i, coord = 0;
+        char component;
+
+        shader_addline(buffer, "gl_TexCoord[%u] = vec4(1.0);\n", clip_coord - 1);
+        if(enabled_clipplanes)
+        {
+            shader_addline(buffer, "vec4 ClipCoord = gl_Position;\n");
+            shader_addline(buffer, "ClipCoord.xy += posFixup.zw * ClipCoord.ww;\n");
+            for(i = 0; i < gl_info->limits.clipplanes; i++)
+            {
+                if(enabled_clipplanes & (1 << i))
+                {
+                    if(coord == 0) component = 'x';
+                    else if(coord == 1) component = 'y';
+                    else if(coord == 2) component = 'z';
+                    else if(coord == 3) component = 'w';
+                    else
+                    {
+                        FIXME("Too many clipplanes used for clipplane emulation\n");
+                        break;
+                    }
+                    shader_addline(buffer, "gl_TexCoord[%u].%c = dot(ClipCoord, gl_ClipPlane[%u]);\n", clip_coord - 1,
+                                   component, i);
+                    coord++;
+                }
+            }
+        }
+    }
+}
+
 /* Context activation is done by the caller. */
 static GLhandleARB generate_param_reorder_function(struct wined3d_shader_buffer *buffer,
         const struct wined3d_shader *vs, const struct wined3d_shader *ps,
-        const struct wined3d_gl_info *gl_info)
+        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info, 
+        DWORD enabled_clipplanes)
 {
     GLhandleARB ret = 0;
     DWORD ps_major = ps ? ps->reg_maps.shader_version.major : 0;
@@ -4350,6 +4433,7 @@
 
     if (ps_major < 3)
     {
+        if(enabled_clipplanes) shader_addline(buffer, "uniform vec4 posFixup;\n");
         shader_addline(buffer, "void order_ps_input(in vec4 vs_out[%u])\n{\n", vs->limits.packed_output);
 
         for (i = 0; map; map >>= 1, ++i)
@@ -4399,6 +4483,7 @@
                 shader_addline(buffer, "gl_FogFragCoord = clamp(vs_out[%u].%c, 0.0, 1.0);\n", i, reg_mask[1]);
             }
         }
+        glsl_gen_clipplane_emul(ps, buffer, gl_info, d3d_info, enabled_clipplanes);
         shader_addline(buffer, "}\n");
     }
     else
@@ -4406,6 +4491,7 @@
         UINT in_count = min(vec4_varyings(ps_major, gl_info), ps->limits.packed_input);
         /* This one is tricky: a 3.0 pixel shader reads from a 3.0 vertex shader */
         shader_addline(buffer, "varying vec4 ps_in[%u];\n", in_count);
+        if(enabled_clipplanes) shader_addline(buffer, "uniform vec4 posFixup;\n");
         shader_addline(buffer, "void order_ps_input(in vec4 vs_out[%u])\n{\n", vs->limits.packed_output);
 
         /* First, sort out position and point size. Those are not passed to the pixel shader */
@@ -4431,6 +4517,7 @@
         handle_ps3_input(buffer, gl_info, ps->u.ps.input_reg_map, ps->input_signature,
                 &ps->reg_maps, output_signature, &vs->reg_maps);
 
+        glsl_gen_clipplane_emul(ps, buffer, gl_info, d3d_info, enabled_clipplanes);
         shader_addline(buffer, "}\n");
     }
 
@@ -4489,6 +4576,8 @@
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const DWORD *function = shader->function;
     struct shader_glsl_ctx_priv priv_ctx;
+    BOOL varying_limit_ok = TRUE;
+    struct glsl_shader_private *shader_priv = shader->backend_data;
 
     /* Create the hw GLSL shader object and assign it as the shader->prgId */
     GLhandleARB shader_obj = GL_EXTCALL(glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB));
@@ -4517,6 +4606,11 @@
     if (reg_maps->shader_version.major >= 3 && args->vp_mode != vertexshader)
         shader_glsl_input_pack(shader, buffer, shader->input_signature, reg_maps, args->vp_mode);
 
+    if(shader_priv->clipplane_emulation && args->clip)
+    {
+        shader_addline(buffer, "if(any(lessThan(gl_TexCoord[%u], vec4(0.0)))) discard;\n", shader_priv->clipplane_emulation - 1);
+    }
+
     /* Base Shader Body */
     shader_generate_main(shader, buffer, reg_maps, function, &priv_ctx);
 
@@ -4530,8 +4624,23 @@
     if (args->srgb_correction)
         shader_glsl_generate_srgb_write_correction(buffer);
 
+    if (gl_info->quirks & WINED3D_CX_QUIRK_TEXCOORD_FOG)
+    {
+        unsigned int cnt = 0, i;
+        for(i = 0; i < MAX_REG_TEXCRD; i++)
+        {
+            if (reg_maps->texcoord & (1 << i)) ++cnt;
+        }
+        if(shader_priv->clipplane_emulation) cnt++;
+        if(cnt >= 8)
+        {
+            WARN("Disabling fog because 8 texcoords are used\n");
+            varying_limit_ok = FALSE;
+        }
+    }
+
     /* SM < 3 does not replace the fog stage. */
-    if (reg_maps->shader_version.major < 3)
+    if (reg_maps->shader_version.major < 3 && varying_limit_ok)
         shader_glsl_generate_fog_code(buffer, args->fog);
 
     shader_addline(buffer, "}\n");
@@ -4586,7 +4695,7 @@
         shader_addline(buffer, "gl_FogFragCoord = 0.0;\n");
 
     /* We always store the clipplanes without y inversion */
-    if (args->clip_enabled)
+    if (args->clip_enabled && !(gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN))
         shader_addline(buffer, "gl_ClipVertex = gl_Position;\n");
 
     /* Write the final position.
@@ -4660,12 +4769,21 @@
 
     if (!shader->backend_data)
     {
+        const struct wined3d_gl_info *gl_info = &shader->device->adapter->gl_info;
         shader->backend_data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*shader_data));
         if (!shader->backend_data)
         {
             ERR("Failed to allocate backend data.\n");
             return 0;
         }
+
+        if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+        {
+            unsigned int coord;
+            coord = shader_find_free_input_register(&shader->reg_maps, context->d3d_info->limits.ffp_blend_stages - 1);
+            /* Store off by one, the code checks against zero */
+            ((struct glsl_shader_private *)shader->backend_data)->clipplane_emulation = coord + 1;
+        }
     }
     shader_data = shader->backend_data;
     gl_shaders = shader_data->gl_shaders.ps;
@@ -5771,6 +5889,7 @@
         struct shader_glsl_priv *priv, struct glsl_context_data *ctx_data)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
+    const struct wined3d_d3d_info *d3d_info = context->d3d_info;
     const struct ps_np2fixup_info *np2fixup_info = NULL;
     struct glsl_shader_prog_link *entry = NULL;
     struct wined3d_shader *vshader = NULL;
@@ -5783,6 +5902,7 @@
     GLhandleARB gs_id = 0;
     GLhandleARB ps_id = 0;
     struct list *ps_list, *vs_list;
+    WORD old_fpu_cw;
 
     if (!(context->shader_update_mask & (1 << WINED3D_SHADER_TYPE_VERTEX)))
     {
@@ -5852,7 +5972,8 @@
         ps_list = &ffp_shader->linked_programs;
     }
 
-    if ((!vs_id && !gs_id && !ps_id) || (entry = get_glsl_program_entry(priv, vs_id, gs_id, ps_id)))
+    if ((!vs_id && !gs_id && !ps_id) || (entry = get_glsl_program_entry(priv, vs_id, gs_id, ps_id,
+                                                                        context, state, gl_info, d3d_info)))
     {
         ctx_data->glsl_program = entry;
         return;
@@ -5870,6 +5991,7 @@
     entry->ps.id = ps_id;
     entry->constant_version = 0;
     entry->ps.np2_fixup_info = np2fixup_info;
+    entry->clipplanes = find_clipplanes(context, state, gl_info, d3d_info);
     /* Add the hash table entry */
     add_glsl_program_entry(priv, entry);
 
@@ -5890,8 +6012,10 @@
     {
         WORD map = vshader->reg_maps.input_registers;
         char tmp_name[10];
+        DWORD clip = find_clipplanes(context, state, gl_info, d3d_info);
 
-        reorder_shader_id = generate_param_reorder_function(&priv->shader_buffer, vshader, pshader, gl_info);
+        reorder_shader_id = generate_param_reorder_function(&priv->shader_buffer, vshader, pshader,
+                gl_info, d3d_info, clip);
         TRACE("Attaching GLSL shader object %u to program %u\n", reorder_shader_id, programId);
         GL_EXTCALL(glAttachObjectARB(programId, reorder_shader_id));
         checkGLcall("glAttachObjectARB");
@@ -5952,7 +6076,16 @@
 
     /* Link the program */
     TRACE("Linking GLSL shader program %u\n", programId);
+
+    old_fpu_cw = wined3d_get_fpu_cw();
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(WINED3D_DEFAULT_FPU_CW);
+
     GL_EXTCALL(glLinkProgramARB(programId));
+
+    if (old_fpu_cw != WINED3D_DEFAULT_FPU_CW)
+        wined3d_set_fpu_cw(old_fpu_cw);
+
     shader_glsl_validate_link(gl_info, programId);
 
     shader_glsl_init_vs_uniform_locations(gl_info, programId, &entry->vs,
@@ -6412,6 +6545,9 @@
     if (k->ps_id > prog->ps.id) return 1;
     else if (k->ps_id < prog->ps.id) return -1;
 
+    if(k->clipplanes > prog->clipplanes) return 1;
+    else if(k->clipplanes < prog->clipplanes) return -1;
+
     return 0;
 }
 
@@ -6595,6 +6731,13 @@
     caps->vs_uniform_count = gl_info->limits.glsl_vs_float_constants;
     caps->ps_uniform_count = gl_info->limits.glsl_ps_float_constants;
 
+    if (cxgames_hacks.safe_vs_consts)
+    {
+        /* One for the posFixup, two for compiler constants, and the clipplanes. */
+        caps->vs_uniform_count -= 3 + gl_info->limits.clipplanes;
+        caps->vs_uniform_count -= gl_info->reserved_glsl_constants;
+    }
+
     /* FIXME: The following line is card dependent. -8.0 to 8.0 is the
      * Direct3D minimum requirement.
      *
@@ -6614,6 +6757,21 @@
      * shader_glsl_alloc(). */
     caps->wined3d_caps = WINED3D_SHADER_CAP_VS_CLIPPING
             | WINED3D_SHADER_CAP_SRGB_WRITE;
+
+    /* Do not advertise VS clipping if the no vs clipping quirk is set. On a
+     * proper GL driver this should not matter, but on a proper GL driver we
+     * don't need the quirk in the first place.
+     *
+     * ATI cards on OSX clip based on gl_Position if a clipplane is enabled.
+     * This would be almost perfect for our use, except that the Z fixup
+     * makes the clip position invalid. Don't try to make use of this bug
+     * though by disabling the Z fixup, I consider it a bad idea to depend on
+     * a bug, and disabling the Z fixup will break geometry position vs depth
+     * clear position, and it will reduce the Z buffer precision.
+     *
+     * Tracked by crossover hacks bug 5366. */
+    if (gl_info->quirks & WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN)
+        caps->wined3d_caps &= ~WINED3D_SHADER_CAP_VS_CLIPPING;
 }
 
 static BOOL shader_glsl_color_fixup_supported(struct color_fixup_desc fixup)
diff -Naur a/dlls/wined3d/query.c b/dlls/wined3d/query.c
--- a/dlls/wined3d/query.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/query.c	2013-11-07 21:40:10.000000000 +0000
@@ -233,6 +233,28 @@
     return refcount;
 }
 
+void wined3d_query_destroy(struct wined3d_query *query)
+{
+    /* Queries are specific to the GL context that created them. Not
+     * deleting the query will obviously leak it, but that's still better
+     * than potentially deleting a different query with the same id in this
+     * context, and (still) leaking the actual query. */
+    if (query->type == WINED3D_QUERY_TYPE_EVENT)
+    {
+        struct wined3d_event_query *event_query = query->extendedData;
+        if (event_query) wined3d_event_query_destroy(event_query);
+    }
+    else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
+    {
+        struct wined3d_occlusion_query *oq = query->extendedData;
+
+        if (oq->context) context_free_occlusion_query(oq);
+        HeapFree(GetProcessHeap(), 0, query->extendedData);
+    }
+
+    HeapFree(GetProcessHeap(), 0, query);
+}
+
 ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
 {
     ULONG refcount = InterlockedDecrement(&query->ref);
@@ -240,26 +262,7 @@
     TRACE("%p decreasing refcount to %u.\n", query, refcount);
 
     if (!refcount)
-    {
-        /* Queries are specific to the GL context that created them. Not
-         * deleting the query will obviously leak it, but that's still better
-         * than potentially deleting a different query with the same id in this
-         * context, and (still) leaking the actual query. */
-        if (query->type == WINED3D_QUERY_TYPE_EVENT)
-        {
-            struct wined3d_event_query *event_query = query->extendedData;
-            if (event_query) wined3d_event_query_destroy(event_query);
-        }
-        else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
-        {
-            struct wined3d_occlusion_query *oq = query->extendedData;
-
-            if (oq->context) context_free_occlusion_query(oq);
-            HeapFree(GetProcessHeap(), 0, query->extendedData);
-        }
-
-        HeapFree(GetProcessHeap(), 0, query);
-    }
+        wined3d_cs_emit_query_destroy(query->device->cs, query);
 
     return refcount;
 }
@@ -284,25 +287,26 @@
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
-    return query->query_ops->query_issue(query, flags);
+    if (flags & WINED3DISSUE_END)
+        query->counter_main++;
+
+    wined3d_cs_emit_query_issue(query->device->cs, query, flags);
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
 }
 
 static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         void *pData, DWORD dwSize, DWORD flags)
 {
-    struct wined3d_occlusion_query *oq = query->extendedData;
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-    struct wined3d_context *context;
-    DWORD* data = pData;
-    GLuint available;
-    GLuint samples;
-    HRESULT res;
-
-    TRACE("(%p) : type D3DQUERY_OCCLUSION, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
-
-    if (!oq->context)
-        query->state = QUERY_CREATED;
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    DWORD *data = pData;
 
     if (query->state == QUERY_CREATED)
     {
@@ -312,6 +316,8 @@
         return S_OK;
     }
 
+    TRACE("(%p) : type D3DQUERY_OCCLUSION, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
+
     if (query->state == QUERY_BUILDING)
     {
         /* Msdn says this returns an error, but our tests show that S_FALSE is returned */
@@ -326,11 +332,37 @@
         return S_OK;
     }
 
+    if (!wined3d_use_csmt(device))
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        *data = oq->samples;
+
+    return S_OK;
+}
+
+static BOOL wined3d_occlusion_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint samples;
+    BOOL ret;
+
     if (oq->context->tid != GetCurrentThreadId())
     {
         FIXME("%p Wrong thread, returning 1.\n", query);
-        *data = 1;
-        return S_OK;
+        oq->samples = 1;
+        return TRUE;
     }
 
     context = context_acquire(query->device, oq->context->current_rt);
@@ -341,63 +373,77 @@
 
     if (available)
     {
-        if (data)
-        {
-            GL_EXTCALL(glGetQueryObjectuivARB(oq->id, GL_QUERY_RESULT_ARB, &samples));
-            checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
-            TRACE("Returning %d samples.\n", samples);
-            *data = samples;
-        }
-        res = S_OK;
+        GL_EXTCALL(glGetQueryObjectuivARB(oq->id, GL_QUERY_RESULT_ARB, &samples));
+        checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
+        TRACE("Returning %d samples.\n", samples);
+        oq->samples = samples;
+        ret = TRUE;
     }
     else
     {
-        res = S_FALSE;
+        ret = FALSE;
     }
 
     context_release(context);
 
-    return res;
+    return ret;
 }
 
-static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
-        void *pData, DWORD dwSize, DWORD flags)
+static BOOL wined3d_event_query_ops_poll(struct wined3d_query *query)
 {
     struct wined3d_event_query *event_query = query->extendedData;
-    BOOL *data = pData;
     enum wined3d_event_query_result ret;
 
-    TRACE("query %p, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
-
-    if (!pData || !dwSize) return S_OK;
-    if (!event_query)
-    {
-        WARN("Event query not supported by GL, reporting GPU idle.\n");
-        *data = TRUE;
-        return S_OK;
-    }
-
     ret = wined3d_event_query_test(event_query, query->device);
     switch(ret)
     {
         case WINED3D_EVENT_QUERY_OK:
         case WINED3D_EVENT_QUERY_NOT_STARTED:
-            *data = TRUE;
-            break;
+            return TRUE;
 
         case WINED3D_EVENT_QUERY_WAITING:
-            *data = FALSE;
-            break;
+            return FALSE;
 
         case WINED3D_EVENT_QUERY_WRONG_THREAD:
             FIXME("(%p) Wrong thread, reporting GPU idle.\n", query);
-            *data = TRUE;
-            break;
+            return TRUE;
 
         case WINED3D_EVENT_QUERY_ERROR:
             ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
-            return WINED3DERR_INVALIDCALL;
+            return TRUE;
+
+        default:
+            ERR("Unexpected wined3d_event_query_test result %u\n", ret);
+            return TRUE;
     }
+}
+
+static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
+        void *pData, DWORD dwSize, DWORD flags)
+{
+    struct wined3d_event_query *event_query = query->extendedData;
+    BOOL *data = pData;
+    enum wined3d_event_query_result ret;
+
+    TRACE("query %p, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
+
+    if (!pData || !dwSize) return S_OK;
+    if (!event_query)
+    {
+        WARN("Event query not supported by GL, reporting GPU idle.\n");
+        *data = TRUE;
+        return S_OK;
+    }
+
+    if (!wined3d_use_csmt(query->device))
+        ret = query->query_ops->query_poll(query);
+    else if (query->counter_main != query->counter_retrieved)
+        ret = FALSE;
+    else
+        ret = TRUE;
+
+    if (data)
+        *data = ret;
 
     return S_OK;
 }
@@ -409,7 +455,7 @@
     return query->type;
 }
 
-static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -419,28 +465,24 @@
         struct wined3d_event_query *event_query = query->extendedData;
 
         /* Faked event query support */
-        if (!event_query) return WINED3D_OK;
+        if (!event_query) return FALSE;
 
         wined3d_event_query_issue(event_query, query->device);
+        return TRUE;
     }
     else if (flags & WINED3DISSUE_BEGIN)
     {
         /* Started implicitly at device creation */
         ERR("Event query issued with START flag - what to do?\n");
     }
-
-    if (flags & WINED3DISSUE_BEGIN)
-        query->state = QUERY_BUILDING;
-    else
-        query->state = QUERY_SIGNALLED;
-
-    return WINED3D_OK;
+    return FALSE;
 }
 
-static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    BOOL poll = FALSE;
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -452,7 +494,7 @@
         /* This is allowed according to msdn and our tests. Reset the query and restart */
         if (flags & WINED3DISSUE_BEGIN)
         {
-            if (query->state == QUERY_BUILDING)
+            if (oq->started)
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -481,6 +523,7 @@
             checkGLcall("glBeginQuery()");
 
             context_release(context);
+            oq->started = TRUE;
         }
         if (flags & WINED3DISSUE_END)
         {
@@ -488,7 +531,7 @@
              * our tests show that it returns OK. But OpenGL doesn't like it, so avoid
              * generating an error
              */
-            if (query->state == QUERY_BUILDING)
+            if (oq->started)
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -502,8 +545,10 @@
                     checkGLcall("glEndQuery()");
 
                     context_release(context);
+                    poll = TRUE;
                 }
             }
+            oq->started = FALSE;
         }
     }
     else
@@ -511,23 +556,20 @@
         FIXME("%p Occlusion queries not supported.\n", query);
     }
 
-    if (flags & WINED3DISSUE_BEGIN)
-        query->state = QUERY_BUILDING;
-    else
-        query->state = QUERY_SIGNALLED;
-
-    return WINED3D_OK; /* can be WINED3DERR_INVALIDCALL.    */
+    return poll;
 }
 
 static const struct wined3d_query_ops event_query_ops =
 {
     wined3d_event_query_ops_get_data,
+    wined3d_event_query_ops_poll,
     wined3d_event_query_ops_issue,
 };
 
 static const struct wined3d_query_ops occlusion_query_ops =
 {
     wined3d_occlusion_query_ops_get_data,
+    wined3d_occlusion_query_ops_poll,
     wined3d_occlusion_query_ops_issue,
 };
 
@@ -546,13 +588,13 @@
             }
             query->query_ops = &occlusion_query_ops;
             query->data_size = sizeof(DWORD);
-            query->extendedData = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_occlusion_query));
+            query->extendedData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(struct wined3d_occlusion_query));
             if (!query->extendedData)
             {
                 ERR("Failed to allocate occlusion query extended data.\n");
                 return E_OUTOFMEMORY;
             }
-            ((struct wined3d_occlusion_query *)query->extendedData)->context = NULL;
             break;
 
         case WINED3D_QUERY_TYPE_EVENT:
@@ -596,6 +638,7 @@
     query->state = QUERY_CREATED;
     query->device = device;
     query->ref = 1;
+    list_init(&query->poll_list_entry);
 
     return WINED3D_OK;
 }
diff -Naur a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
--- a/dlls/wined3d/resource.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/resource.c	2013-11-07 21:40:10.000000000 +0000
@@ -125,6 +125,7 @@
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+        resource->heap_memory = resource->map_heap_memory;
     }
     else
     {
@@ -149,6 +150,30 @@
     return WINED3D_OK;
 }
 
+static void wined3d_resource_free_bo(struct wined3d_resource *resource)
+{
+    struct wined3d_context *context = context_acquire(resource->device, NULL);
+
+    if (resource->buffer != resource->map_buffer)
+        ERR("Releasing resource buffer with buffer != map_buffer.\n");
+
+    wined3d_device_release_bo(resource->device, resource->buffer, context);
+    resource->buffer = NULL;
+    resource->map_buffer = NULL;
+
+    context_release(context);
+}
+
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource)
+{
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
+    wined3d_resource_free_sysmem(resource);
+    resource->allocatedMemory = NULL;
+    resource->map_heap_memory = NULL;
+}
+
 void resource_cleanup(struct wined3d_resource *resource)
 {
     const struct wined3d *d3d = resource->device->wined3d;
@@ -172,8 +197,7 @@
             ERR("Failed to free private data when destroying resource %p, hr = %#x.\n", resource, hr);
     }
 
-    wined3d_resource_free_sysmem(resource);
-    resource->allocatedMemory = NULL;
+    wined3d_cs_emit_resource_cleanup(resource->device->cs, resource);
 
     device_resource_released(resource->device, resource);
 }
@@ -183,6 +207,9 @@
     if (resource->map_count)
         ERR("Resource %p is being unloaded while mapped.\n", resource);
 
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
     context_resource_unloaded(resource->device,
             resource, resource->type);
 }
@@ -342,6 +369,21 @@
     desc->size = resource->size;
 }
 
+void *wined3d_resource_allocate_sysmem2(struct wined3d_resource *resource)
+{
+    void **p;
+    SIZE_T align = RESOURCE_ALIGNMENT - 1 + sizeof(*p);
+    void *mem;
+
+    if (!(mem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, resource->size + align)))
+        return FALSE;
+
+    p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
+    *p = mem;
+
+    return ++p;
+}
+
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
 {
     void **p;
@@ -354,7 +396,7 @@
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
-    resource->heap_memory = ++p;
+    resource->map_heap_memory = ++p;
 
     return TRUE;
 }
@@ -420,7 +462,7 @@
     return ret;
 }
 
-GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
+static GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
 {
     if (d3d_flags & WINED3D_MAP_READONLY)
         return GL_READ_ONLY_ARB;
@@ -428,3 +470,582 @@
         return GL_WRITE_ONLY_ARB;
     return GL_READ_WRITE_ARB;
 }
+
+void wined3d_resource_validate_location(struct wined3d_resource *resource, DWORD location)
+{
+    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations |= location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+}
+
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource, DWORD location)
+{
+    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations &= ~location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+}
+
+DWORD wined3d_resource_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_DISCARDED:
+            return 0;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER:
+        case WINED3D_LOCATION_DIB:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_BUFFER:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_DRAWABLE:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data)
+{
+    if (location & WINED3D_LOCATION_BUFFER)
+    {
+        data->buffer_object = resource->buffer->name;
+        data->addr = NULL;
+        return;
+    }
+    if (location & WINED3D_LOCATION_SYSMEM)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->heap_memory;
+        return;
+    }
+    if (location & WINED3D_LOCATION_USER)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->user_memory;
+        return;
+    }
+    if (location & WINED3D_LOCATION_DIB)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->dib_memory;
+        return;
+    }
+
+    ERR("Unexpected location %s.\n", wined3d_debug_location(location));
+}
+
+/* Context activation is done by the caller */
+static void wined3d_resource_download_buffer(const struct wined3d_resource *resource,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_bo_address *dst_data)
+{
+    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->buffer->name));
+    GL_EXTCALL(glGetBufferSubDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0, resource->size, dst_data->addr));
+    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+    checkGLcall("Download PBO");
+}
+
+/* Context activation is done by the caller */
+static void wined3d_resource_upload_buffer(const struct wined3d_resource *resource,
+        const struct wined3d_gl_info *gl_info, const struct wined3d_bo_address *src_data)
+{
+    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->buffer->name));
+    GL_EXTCALL(glBufferSubDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0, resource->size, src_data->addr));
+    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+    checkGLcall("Upload PBO");
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+static BOOL wined3d_resource_load_simple_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    struct wined3d_bo_address dst, src;
+    DWORD sysmem_locations = WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER | WINED3D_LOCATION_DIB;
+
+    if (resource->locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Resource was discarded, nothing to do.\n");
+        return TRUE;
+    }
+
+    wined3d_resource_get_memory(resource, location, &dst);
+
+    if (resource->locations & sysmem_locations)
+    {
+        wined3d_resource_get_memory(resource,
+                resource->locations & sysmem_locations, &src);
+
+        if (location == WINED3D_LOCATION_BUFFER)
+            wined3d_resource_upload_buffer(resource, context->gl_info, &src);
+        else
+            memcpy(dst.addr, src.addr, resource->size);
+
+        return TRUE;
+    }
+    if (resource->locations & WINED3D_LOCATION_BUFFER)
+    {
+        wined3d_resource_download_buffer(resource, context->gl_info, &dst);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    DWORD required_access = wined3d_resource_access_from_location(location);
+    DWORD basic_locations = WINED3D_LOCATION_BUFFER | WINED3D_LOCATION_SYSMEM
+            | WINED3D_LOCATION_USER | WINED3D_LOCATION_DIB;
+
+    if ((resource->locations & location) == location)
+    {
+        TRACE("Location(s) already up to date.\n");
+        return;
+    }
+
+    /* Keep this a WARN for now until surfaces are cleaned up. */
+    if ((resource->access_flags & required_access) != required_access)
+        WARN("Operation requires %#x access, but resource only has %#x.\n",
+                required_access, resource->access_flags);
+
+    if (location & basic_locations)
+    {
+        if (wined3d_resource_load_simple_location(resource, context, location))
+        {
+            resource->locations |= location;
+            return;
+        }
+    }
+
+    /* Context is NULL in ddraw-only operation without OpenGL. */
+    if (!context)
+        ERR("A context is required for non-sysmem operation.\n");
+
+    resource->resource_ops->resource_load_location(resource, context, location);
+}
+
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags)
+{
+    const struct wined3d_gl_info *gl_info;
+    BYTE *ptr;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->map_buffer->name));
+
+            if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+            {
+                GLbitfield mapflags = wined3d_resource_gl_map_flags(flags);
+                mapflags &= ~GL_MAP_FLUSH_EXPLICIT_BIT;
+                ptr = GL_EXTCALL(glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB,
+                        0, resource->size, mapflags));
+            }
+            else
+            {
+                GLenum access = wined3d_resource_gl_legacy_map_flags(flags);
+                ptr = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, access));
+            }
+
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+            checkGLcall("Map GL buffer");
+            return ptr;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return resource->map_heap_memory;
+
+        case WINED3D_LOCATION_USER:
+            return resource->user_memory;
+
+        case WINED3D_LOCATION_DIB:
+            return resource->dib_memory;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return NULL;
+    }
+}
+
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->map_buffer->name));
+            GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+            checkGLcall("Unmap GL buffer");
+            return;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER:
+        case WINED3D_LOCATION_DIB:
+            return;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return;
+    }
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_resource_prepare_bo(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    if (resource->buffer)
+        return;
+
+    resource->buffer = wined3d_device_get_bo(resource->device, resource->size,
+            GL_STREAM_DRAW_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, context);
+    resource->map_buffer = resource->buffer;
+    TRACE("Created GL buffer %u for resource %p.\n", resource->buffer->name, resource);
+}
+
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource)
+{
+    if (resource->heap_memory)
+        return TRUE;
+
+    if (!wined3d_resource_allocate_sysmem(resource))
+    {
+        ERR("Failed to allocate system memory.\n");
+        return FALSE;
+    }
+    resource->heap_memory = resource->map_heap_memory;
+    return TRUE;
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            wined3d_resource_prepare_bo(resource, context);
+            return TRUE;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return wined3d_resource_prepare_system_memory(resource);
+
+        case WINED3D_LOCATION_USER:
+            return TRUE;
+
+        case WINED3D_LOCATION_DIB:
+            if (resource->type != WINED3D_RTYPE_SURFACE)
+            {
+                ERR("Trying to create a DIB for a non-surface resource.\n");
+                return FALSE;
+            }
+
+            return wined3d_surface_prepare_dib(resource);
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return FALSE;
+    }
+}
+
+void CDECL wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch)
+{
+    const struct wined3d_format *format = resource->format;
+
+    if (resource->custom_row_pitch)
+    {
+        *row_pitch = resource->custom_row_pitch;
+        *slice_pitch = resource->custom_slice_pitch;
+        return;
+    }
+
+    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
+    {
+        /* Since compressed formats are block based, pitch means the amount of
+         * bytes to the next row of block rather than the next row of pixels. */
+        UINT row_block_count = (resource->width + format->block_width - 1) / format->block_width;
+        UINT slice_block_count = (resource->height + format->block_height - 1) / format->block_height;
+        *row_pitch = row_block_count * format->block_byte_count;
+        *slice_pitch = *row_pitch * slice_block_count;
+    }
+    else
+    {
+        unsigned char alignment = resource->device->surface_alignment;
+        *row_pitch = format->byte_count * resource->width;  /* Bytes / row */
+        *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
+        *slice_pitch = *row_pitch * resource->height;
+    }
+
+    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
+}
+
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box)
+{
+    UINT width_mask, height_mask;
+    const struct wined3d_format *format = resource->format;
+
+    if (!box)
+        return TRUE;
+
+    /* This assumes power of two block sizes, but NPOT block sizes would be
+     * silly anyway.
+     *
+     * This also assumes that the format's block depth is 1. */
+    width_mask = format->block_width - 1;
+    height_mask = format->block_height - 1;
+
+    if (box->left & width_mask)
+        return FALSE;
+    if (box->top & height_mask)
+        return FALSE;
+    if (box->right & width_mask && box->right != resource->width)
+        return FALSE;
+    if (box->bottom & height_mask && box->bottom != resource->height)
+        return FALSE;
+
+    return TRUE;
+}
+
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+    void *mem;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(resource, context))
+    {
+        WARN("Out of memory.\n");
+        context_release(context);
+        return NULL;
+    }
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+                resource->map_buffer = wined3d_device_get_bo(device, resource->size,
+                        GL_STREAM_DRAW_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, context);
+                break;
+
+            case WINED3D_LOCATION_SYSMEM:
+                wined3d_resource_allocate_sysmem(resource);
+                break;
+
+            default:
+                if (resource->access_fence)
+                    ERR("Location %s does not support DISCARD maps.\n", 
+                            wined3d_debug_location(resource->map_binding));
+                if (resource->pool != WINED3D_POOL_DEFAULT)
+                    FIXME("Discard used on %s pool resource.\n", debug_d3dpool(resource->pool));
+        }
+        wined3d_resource_validate_location(resource, resource->map_binding);
+    }
+    else
+    {
+        wined3d_resource_load_location(resource, context, resource->map_binding);
+    }
+
+    mem = wined3d_resource_get_map_ptr(resource, context, flags);
+
+    if (context)
+        context_release(context);
+
+    return mem;
+}
+
+static void wined3d_resource_sync(struct wined3d_resource *resource)
+{
+    struct wined3d_resource *real_res = resource;
+    struct wined3d_surface *surface;
+    struct wined3d_volume *volume;
+
+    switch (resource->type)
+    {
+        case WINED3D_RTYPE_SURFACE:
+            surface = surface_from_resource(resource);
+            if (surface->container)
+                real_res = &surface->container->resource;
+            break;
+
+        case WINED3D_RTYPE_VOLUME:
+            volume = volume_from_resource(resource);
+            real_res = &volume->container->resource;
+            break;
+
+        default:
+            break;
+    }
+    wined3d_resource_wait_fence(real_res);
+}
+
+HRESULT wined3d_resource_map(struct wined3d_resource *resource,
+        struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    BYTE *base_memory;
+    const struct wined3d_format *format = resource->format;
+
+    TRACE("resource %p, map_desc %p, box %p, flags %#x.\n",
+            resource, map_desc, box, flags);
+
+    if (resource->map_count)
+    {
+        WARN("Volume is already mapped.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    flags = wined3d_resource_sanitize_map_flags(resource, flags);
+
+    if (flags & WINED3D_MAP_NOOVERWRITE)
+        FIXME("WINED3D_MAP_NOOVERWRITE are not implemented yet.\n");
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+            case WINED3D_LOCATION_SYSMEM:
+                break;
+
+            default:
+                FIXME("Implement discard maps with %s map binding.\n",
+                        wined3d_debug_location(resource->map_binding));
+                wined3d_resource_sync(resource);
+        }
+    }
+    else
+        wined3d_resource_sync(resource);
+
+    base_memory = wined3d_cs_emit_resource_map(device->cs, resource, flags);
+    if (!base_memory)
+    {
+        WARN("Map failed.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    TRACE("Base memory pointer %p.\n", base_memory);
+
+    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
+    {
+        map_desc->row_pitch = resource->width * format->byte_count;
+        map_desc->slice_pitch = map_desc->row_pitch * resource->height;
+    }
+    else
+    {
+        wined3d_resource_get_pitch(resource, &map_desc->row_pitch, &map_desc->slice_pitch);
+    }
+
+    if (!box)
+    {
+        TRACE("No box supplied - all is ok\n");
+        map_desc->data = base_memory;
+    }
+    else
+    {
+        TRACE("Lock Box (%p) = l %u, t %u, r %u, b %u, fr %u, ba %u\n",
+                box, box->left, box->top, box->right, box->bottom, box->front, box->back);
+
+        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
+        {
+            /* Compressed textures are block based, so calculate the offset of
+             * the block that contains the top-left pixel of the locked rectangle. */
+            map_desc->data = base_memory
+                    + (box->front * map_desc->slice_pitch)
+                    + ((box->top / format->block_height) * map_desc->row_pitch)
+                    + ((box->left / format->block_width) * format->block_byte_count);
+        }
+        else
+        {
+            map_desc->data = base_memory
+                    + (map_desc->slice_pitch * box->front)
+                    + (map_desc->row_pitch * box->top)
+                    + (box->left * format->byte_count);
+        }
+    }
+
+    if (!(flags & WINED3D_MAP_READONLY))
+        resource->unmap_dirtify = TRUE;
+
+    resource->map_count++;
+
+    TRACE("Returning memory %p, row pitch %d, slice pitch %d.\n",
+            map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+    wined3d_resource_release_map_ptr(resource, context);
+    if (context)
+        context_release(context);
+}
+
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    TRACE("resource %p.\n", resource);
+
+    if (!resource->map_count)
+    {
+        WARN("Trying to unlock an unlocked resource %p.\n", resource);
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_resource_unmap(device->cs, resource);
+
+    if (resource->unmap_dirtify)
+    {
+        wined3d_cs_emit_resource_changed(device->cs, resource,
+                resource->map_buffer, resource->map_heap_memory);
+    }
+    resource->unmap_dirtify = FALSE;
+
+    resource->map_count--;
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_changed(struct wined3d_resource *resource, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory)
+{
+    struct wined3d_device *device = resource->device;
+
+    if (swap_buffer && swap_buffer != resource->buffer)
+    {
+        struct wined3d_context *context = context_acquire(device, NULL);
+        wined3d_device_release_bo(device, resource->buffer, context);
+        context_release(context);
+        resource->buffer = swap_buffer;
+    }
+    if (swap_heap_memory && swap_heap_memory != resource->heap_memory)
+    {
+        wined3d_resource_free_sysmem(resource);
+        resource->heap_memory = swap_heap_memory;
+    }
+
+    resource->resource_ops->resource_changed(resource);
+    wined3d_resource_invalidate_location(resource, ~resource->map_binding);
+}
diff -Naur a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
--- a/dlls/wined3d/shader.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/shader.c	2013-11-07 21:40:10.000000000 +0000
@@ -1486,7 +1486,7 @@
     }
 }
 
-static void shader_cleanup(struct wined3d_shader *shader)
+void shader_cleanup(struct wined3d_shader *shader)
 {
     shader->device->shader_backend->shader_destroy(shader);
     HeapFree(GetProcessHeap(), 0, shader->reg_maps.constf);
@@ -1740,9 +1740,10 @@
 
     if (!refcount)
     {
-        shader_cleanup(shader);
+        const struct wined3d_device *device = shader->device;
+
         shader->parent_ops->wined3d_object_destroyed(shader->parent);
-        HeapFree(GetProcessHeap(), 0, shader);
+        wined3d_cs_emit_shader_cleanup(device->cs, shader);
     }
 
     return refcount;
@@ -2034,7 +2035,7 @@
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && state->render_states[WINED3D_RS_SRGBWRITEENABLE])
     {
-        const struct wined3d_surface *rt = state->fb->render_targets[0];
+        const struct wined3d_surface *rt = state->fb.render_targets[0];
         if (rt->resource.format->flags & WINED3DFMT_FLAG_SRGB_WRITE)
         {
             static unsigned int warned = 0;
@@ -2197,6 +2198,16 @@
             args->fog = WINED3D_FFP_PS_FOG_OFF;
         }
     }
+    /* Only inser the KIL fragment.texcoord[clip] line if clipping is used.
+     * It is expensive because KIL can break early Z discard. Its cheaper to
+     * have two shaders than KIL needlessly. The same applies to the
+     * clipplane emulation in GLSL with discard. */
+    if (!shader->device->adapter->d3d_info.vs_clipping && use_vs(state)
+            && state->render_states[WINED3D_RS_CLIPPING]
+            && state->render_states[WINED3D_RS_CLIPPLANEENABLE])
+    {
+        args->clip = TRUE;
+    }
 }
 
 static void pixelshader_set_limits(struct wined3d_shader *shader)
diff -Naur a/dlls/wined3d/state.c b/dlls/wined3d/state.c
--- a/dlls/wined3d/state.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/state.c	2013-11-07 21:40:10.000000000 +0000
@@ -106,7 +106,7 @@
     static UINT once;
 
     /* No z test without depth stencil buffers */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -381,7 +381,7 @@
 
 static void state_blend(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_surface *target = state->fb->render_targets[0];
+    const struct wined3d_surface *target = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     GLenum srcBlend, dstBlend;
     enum wined3d_blend d3d_blend;
@@ -833,7 +833,7 @@
     GLint stencilPass_ccw = GL_KEEP;
 
     /* No stencil test without a stencil buffer. */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -919,7 +919,7 @@
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -933,7 +933,7 @@
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1175,7 +1175,7 @@
 
                 case WINED3D_FOG_NONE:
                     /* Both are none? According to msdn the alpha channel of the specular
-                     * color contains a fog factor. Set it in drawStridedSlow.
+                     * color contains a fog factor. Set it in draw_strided_slow.
                      * Same happens with Vertexfog on transformed vertices
                      */
                     new_source = FOGSOURCE_COORD;
@@ -1772,7 +1772,7 @@
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
-        const struct wined3d_surface *depth = state->fb->depth_stencil;
+        const struct wined3d_surface *depth = state->fb.depth_stencil;
         float scale;
 
         union
@@ -4286,7 +4286,7 @@
                 }
             }
         } else {
-            /* TODO: support blends in drawStridedSlow
+            /* TODO: support blends in draw_strided_slow
              * No need to write a FIXME here, this is done after the general vertex decl decoding
              */
             WARN("unsupported blending in openGl\n");
@@ -4643,7 +4643,7 @@
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_surface *target = state->fb->render_targets[0];
+    const struct wined3d_surface *target = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
 
@@ -4823,7 +4823,7 @@
     }
     else
     {
-        const struct wined3d_surface *target = state->fb->render_targets[0];
+        const struct wined3d_surface *target = state->fb.render_targets[0];
         UINT height;
         UINT width;
 
@@ -4891,7 +4891,7 @@
 void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_surface *rt = state->fb->render_targets[0];
+    const struct wined3d_surface *rt = state->fb.render_targets[0];
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
 
diff -Naur a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
--- a/dlls/wined3d/stateblock.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/stateblock.c	2013-11-07 21:40:10.000000000 +0000
@@ -463,6 +463,7 @@
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+    struct wined3d_surface *surface;
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -530,6 +531,31 @@
             }
         }
     }
+
+    if (state->fb.depth_stencil)
+    {
+        surface = state->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil buffer %p.\n", surface);
+
+        state->fb.depth_stencil = NULL;
+        wined3d_surface_decref(surface);
+    }
+
+    if (state->fb.render_targets)
+    {
+        for (i = 0; i < state->fb.rt_size; i++)
+        {
+            surface = state->fb.render_targets[i];
+            TRACE("Setting rendertarget %u to NULL\n", i);
+            state->fb.render_targets[i] = NULL;
+            if (surface)
+            {
+                TRACE("Releasing the render target at %p\n", surface);
+                wined3d_surface_decref(surface);
+            }
+        }
+    }
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -552,6 +578,7 @@
 
     HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
     HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+    HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -1033,8 +1060,8 @@
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
-        if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-            device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+        if (gl_primitive_type != prev)
+            wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
     }
 
     if (stateblock->changed.indices)
@@ -1295,17 +1322,23 @@
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+        state->textures[i] = NULL;
     }
+
+    state->index_buffer = NULL;
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        memset(&state->streams[i], 0, sizeof(state->streams[i]));
+
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = NULL;
+    state->shader[WINED3D_SHADER_TYPE_PIXEL] = NULL;
 }
 
-HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
-        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
-        DWORD flags)
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags)
 {
     unsigned int i;
 
     state->flags = flags;
-    state->fb = fb;
 
     for (i = 0; i < LIGHTMAP_SIZE; i++)
     {
@@ -1323,6 +1356,15 @@
         return E_OUTOFMEMORY;
     }
 
+    if (!(state->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*state->fb.render_targets) * gl_info->limits.buffers)))
+    {
+        HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+        HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
+        return E_OUTOFMEMORY;
+    }
+    state->fb.rt_size = gl_info->limits.buffers;
+
     if (flags & WINED3D_STATE_INIT_DEFAULT)
         state_init_default(state, gl_info);
 
@@ -1333,12 +1375,13 @@
         struct wined3d_device *device, enum wined3d_stateblock_type type)
 {
     HRESULT hr;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
 
     stateblock->ref = 1;
     stateblock->device = device;
 
-    if (FAILED(hr = state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0)))
+    if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
         return hr;
 
     if (FAILED(hr = stateblock_allocate_shader_constants(stateblock)))
diff -Naur a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
--- a/dlls/wined3d/surface.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/surface.c	2013-11-07 21:40:10.000000000 +0000
@@ -36,15 +36,10 @@
 
 #define MAXLOCKCOUNT 50 /* After this amount of locks do not free the sysmem copy. */
 
-static void surface_cleanup(struct wined3d_surface *surface)
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface)
 {
-    struct wined3d_surface *overlay, *cur;
-
-    TRACE("surface %p.\n", surface);
-
-    if (surface->texture_name || (surface->flags & SFLAG_PBO)
-             || surface->rb_multisample || surface->rb_resolved
-             || !list_empty(&surface->renderbuffers))
+    if (surface->texture_name || surface->rb_multisample
+            || surface->rb_resolved || !list_empty(&surface->renderbuffers))
     {
         struct wined3d_renderbuffer_entry *entry, *entry2;
         const struct wined3d_gl_info *gl_info;
@@ -59,12 +54,6 @@
             gl_info->gl_ops.gl.p_glDeleteTextures(1, &surface->texture_name);
         }
 
-        if (surface->flags & SFLAG_PBO)
-        {
-            TRACE("Deleting PBO %u.\n", surface->pbo);
-            GL_EXTCALL(glDeleteBuffersARB(1, &surface->pbo));
-        }
-
         if (surface->rb_multisample)
         {
             TRACE("Deleting multisample renderbuffer %u.\n", surface->rb_multisample);
@@ -91,12 +80,22 @@
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
-        surface->dib.bitmap_data = NULL;
-        surface->resource.allocatedMemory = NULL;
+        surface->resource.dib_memory = NULL;
     }
 
     if (surface->flags & SFLAG_USERPTR)
         wined3d_surface_set_mem(surface, NULL, 0);
+
+    TRACE("Destroyed surface %p.\n", surface);
+    HeapFree(GetProcessHeap(), 0, surface);
+}
+
+static void surface_cleanup(struct wined3d_surface *surface)
+{
+    struct wined3d_surface *overlay, *cur;
+
+    TRACE("surface %p.\n", surface);
+
     if (surface->overlay_dest)
         list_remove(&surface->overlay_entry);
 
@@ -107,16 +106,17 @@
     }
 
     resource_cleanup(&surface->resource);
+    wined3d_cs_emit_surface_cleanup(surface->resource.device->cs, surface);
 }
 
 void surface_update_draw_binding(struct wined3d_surface *surface)
 {
     if (!surface_is_offscreen(surface) || wined3d_settings.offscreen_rendering_mode != ORM_FBO)
-        surface->draw_binding = SFLAG_INDRAWABLE;
+        surface->draw_binding = WINED3D_LOCATION_DRAWABLE;
     else if (surface->resource.multisample_type)
-        surface->draw_binding = SFLAG_INRB_MULTISAMPLE;
+        surface->draw_binding = WINED3D_LOCATION_RB_MULTISAMPLE;
     else
-        surface->draw_binding = SFLAG_INTEXTURE;
+        surface->draw_binding = WINED3D_LOCATION_TEXTURE_RGB;
 }
 
 void surface_set_swapchain(struct wined3d_surface *surface, struct wined3d_swapchain *swapchain)
@@ -393,21 +393,20 @@
     masks[2] = ((1 << format->blue_size) - 1) << format->blue_offset;
 }
 
-static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
+BOOL wined3d_surface_prepare_dib(struct wined3d_resource *resource)
 {
+    struct wined3d_surface *surface = surface_from_resource(resource);
     const struct wined3d_format *format = surface->resource.format;
     SYSTEM_INFO sysInfo;
     BITMAPINFO *b_info;
     int extraline = 0;
     DWORD *masks;
+    UINT row_pitch, slice_pitch;
 
     TRACE("surface %p.\n", surface);
 
-    if (!(format->flags & WINED3DFMT_FLAG_GETDC))
-    {
-        WARN("Cannot use GetDC on a %s surface.\n", debug_d3dformat(format->id));
-        return WINED3DERR_INVALIDCALL;
-    }
+    if (surface->hDC)
+        return TRUE;
 
     switch (format->byte_count)
     {
@@ -429,7 +428,7 @@
     }
 
     if (!b_info)
-        return E_OUTOFMEMORY;
+        return FALSE;
 
     /* Some applications access the surface in via DWORDs, and do not take
      * the necessary care at the end of the surface. So we need at least
@@ -445,10 +444,11 @@
 
     b_info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     /* TODO: Is there a nicer way to force a specific alignment? (8 byte for ddraw) */
-    b_info->bmiHeader.biWidth = wined3d_surface_get_pitch(surface) / format->byte_count;
+    wined3d_resource_get_pitch(&surface->resource, &row_pitch, &slice_pitch);
+    b_info->bmiHeader.biWidth = row_pitch / format->byte_count;
     b_info->bmiHeader.biHeight = 0 - surface->resource.height - extraline;
     b_info->bmiHeader.biSizeImage = (surface->resource.height + extraline)
-            * wined3d_surface_get_pitch(surface);
+            * row_pitch;
     b_info->bmiHeader.biPlanes = 1;
     b_info->bmiHeader.biBitCount = format->byte_count * 8;
 
@@ -490,7 +490,7 @@
     TRACE("Creating a DIB section with size %dx%dx%d, size=%d.\n",
             b_info->bmiHeader.biWidth, b_info->bmiHeader.biHeight,
             b_info->bmiHeader.biBitCount, b_info->bmiHeader.biSizeImage);
-    surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->dib.bitmap_data, 0, 0);
+    surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->resource.dib_memory, 0, 0);
 
     if (!surface->dib.DIBsection)
     {
@@ -499,18 +499,7 @@
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
-    TRACE("DIBSection at %p.\n", surface->dib.bitmap_data);
-    /* Copy the existing surface to the dib section. */
-    if (surface->resource.allocatedMemory)
-    {
-        memcpy(surface->dib.bitmap_data, surface->resource.allocatedMemory,
-                surface->resource.height * wined3d_surface_get_pitch(surface));
-    }
-    else
-    {
-        /* This is to make maps read the GL texture although memory is allocated. */
-        surface->flags &= ~SFLAG_INSYSMEM;
-    }
+    TRACE("DIBSection at %p.\n", surface->resource.dib_memory);
     surface->dib.bitmap_size = b_info->bmiHeader.biSizeImage;
 
     HeapFree(GetProcessHeap(), 0, b_info);
@@ -523,84 +512,17 @@
 
     surface->flags |= SFLAG_DIBSECTION;
 
-    return WINED3D_OK;
-}
-
-static BOOL surface_need_pbo(const struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info)
-{
-    if (surface->resource.pool == WINED3D_POOL_SYSTEM_MEM)
-        return FALSE;
-    if (!(surface->flags & SFLAG_DYNLOCK))
-        return FALSE;
-    if (surface->flags & (SFLAG_CONVERTED | SFLAG_NONPOW2 | SFLAG_PIN_SYSMEM))
-        return FALSE;
-    if (!gl_info->supported[ARB_PIXEL_BUFFER_OBJECT])
-        return FALSE;
-
     return TRUE;
 }
 
-static void surface_load_pbo(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info)
-{
-    struct wined3d_context *context;
-    GLenum error;
-
-    context = context_acquire(surface->resource.device, NULL);
-
-    GL_EXTCALL(glGenBuffersARB(1, &surface->pbo));
-    error = gl_info->gl_ops.gl.p_glGetError();
-    if (!surface->pbo || error != GL_NO_ERROR)
-        ERR("Failed to create a PBO with error %s (%#x).\n", debug_glerror(error), error);
-
-    TRACE("Binding PBO %u.\n", surface->pbo);
-
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-    checkGLcall("glBindBufferARB");
-
-    GL_EXTCALL(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->resource.size + 4,
-            surface->resource.allocatedMemory, GL_STREAM_DRAW_ARB));
-    checkGLcall("glBufferDataARB");
-
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-    checkGLcall("glBindBufferARB");
-
-    /* We don't need the system memory anymore and we can't even use it for PBOs. */
-    if (!(surface->flags & SFLAG_CLIENT))
-        wined3d_resource_free_sysmem(&surface->resource);
-    surface->resource.allocatedMemory = NULL;
-    surface->flags |= SFLAG_PBO;
-    context_release(context);
-}
-
-static void surface_prepare_system_memory(struct wined3d_surface *surface)
-{
-    const struct wined3d_gl_info *gl_info = &surface->resource.device->adapter->gl_info;
-
-    TRACE("surface %p.\n", surface);
-
-    if (!(surface->flags & SFLAG_PBO) && surface_need_pbo(surface, gl_info))
-        surface_load_pbo(surface, gl_info);
-    else if (!(surface->resource.allocatedMemory || surface->flags & SFLAG_PBO))
-    {
-        /* Whatever surface we have, make sure that there is memory allocated
-         * for the downloaded copy, or a PBO to map. */
-        if (!surface->resource.heap_memory && !wined3d_resource_allocate_sysmem(&surface->resource))
-            ERR("Failed to allocate system memory.\n");
-        surface->resource.allocatedMemory = surface->resource.heap_memory;
-
-        if (surface->flags & SFLAG_INSYSMEM)
-            ERR("Surface without memory or PBO has SFLAG_INSYSMEM set.\n");
-    }
-}
-
 static void surface_evict_sysmem(struct wined3d_surface *surface)
 {
     if (surface->resource.map_count || (surface->flags & SFLAG_DONOTFREE))
         return;
 
     wined3d_resource_free_sysmem(&surface->resource);
-    surface->resource.allocatedMemory = NULL;
-    surface_invalidate_location(surface, SFLAG_INSYSMEM);
+    surface->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
 }
 
 /* Context activation is done by the caller. */
@@ -677,28 +599,28 @@
     surface->flags &= ~(SFLAG_ALLOCATED | SFLAG_SRGBALLOCATED);
 }
 
-static void surface_release_client_storage(struct wined3d_surface *surface)
+static BOOL surface_use_pbo(const struct wined3d_surface *surface)
 {
-    struct wined3d_context *context = context_acquire(surface->resource.device, NULL);
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    if (surface->texture_name)
-    {
-        surface_bind_and_dirtify(surface, context, FALSE);
-        gl_info->gl_ops.gl.p_glTexImage2D(surface->texture_target, surface->texture_level,
-                GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
-    }
-    if (surface->texture_name_srgb)
-    {
-        surface_bind_and_dirtify(surface, context, TRUE);
-        gl_info->gl_ops.gl.p_glTexImage2D(surface->texture_target, surface->texture_level,
-                GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
-    }
+    const struct wined3d_gl_info *gl_info = &surface->resource.device->adapter->gl_info;
 
-    context_release(context);
+    /* Note that SFLAG_PIN_SYSMEM disables PBOs for all ddraw surfaces except the
+     * swapchain's front buffer. The nice side effect of this is that we don't have
+     * to worry about surfaces that are converted because they have a color key set.
+     * Keep this in mind when adding support for ddraw PBOs with ARB_buffer_storage. */
+    if (!gl_info->supported[ARB_PIXEL_BUFFER_OBJECT])
+        return FALSE;
+    if (surface->resource.pool != WINED3D_POOL_DEFAULT)
+        return FALSE;
+    if (surface->flags & (SFLAG_NONPOW2 | SFLAG_PIN_SYSMEM))
+        return FALSE;
+    if (surface->resource.format->convert)
+        return FALSE;
+    if (!(surface->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
+        return FALSE;
+    if (surface->resource.format->flags & WINED3DFMT_FLAG_PALETTE)
+        return FALSE;
 
-    surface_invalidate_location(surface, SFLAG_INTEXTURE | SFLAG_INSRGBTEX);
-    surface_force_reload(surface);
+    return TRUE;
 }
 
 static HRESULT surface_private_setup(struct wined3d_surface *surface)
@@ -787,7 +709,10 @@
     }
 
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
-        surface->flags |= SFLAG_DISCARDED;
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+
+    if (surface_use_pbo(surface))
+        surface->resource.map_binding = WINED3D_LOCATION_BUFFER;
 
     return WINED3D_OK;
 }
@@ -795,32 +720,38 @@
 static void surface_realize_palette(struct wined3d_surface *surface)
 {
     struct wined3d_palette *palette = surface->palette;
+    struct wined3d_context *context;
 
     TRACE("surface %p.\n", surface);
 
     if (!palette) return;
 
-    if (surface->resource.format->id == WINED3DFMT_P8_UINT
-            || surface->resource.format->id == WINED3DFMT_P8_UINT_A8_UNORM)
+    context = context_acquire(surface->resource.device, NULL);
+
+    if (surface->resource.format->flags & WINED3DFMT_FLAG_PALETTE
+            && !(surface->resource.locations & WINED3D_LOCATION_DISCARDED))
     {
         if (surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
         {
+            /* FIXME: This codepath should be dead */
+
             /* Make sure the texture is up to date. This call doesn't do
              * anything if the texture is already up to date. */
-            surface_load_location(surface, SFLAG_INTEXTURE, NULL);
+            wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
 
             /* We want to force a palette refresh, so mark the drawable as not being up to date */
             if (!surface_is_offscreen(surface))
-                surface_invalidate_location(surface, SFLAG_INDRAWABLE);
+                wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_DRAWABLE);
         }
         else
         {
-            if (!(surface->flags & SFLAG_INSYSMEM))
+            if (!(surface->resource.locations & surface->resource.map_binding))
             {
                 TRACE("Palette changed with surface that does not have an up to date system memory copy.\n");
-                surface_load_location(surface, SFLAG_INSYSMEM, NULL);
+                wined3d_resource_prepare_map_memory(&surface->resource, context);
+                wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
             }
-            surface_invalidate_location(surface, ~SFLAG_INSYSMEM);
+            wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
         }
     }
 
@@ -843,186 +774,24 @@
 
     /* Propagate the changes to the drawable when we have a palette. */
     if (surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
-        surface_load_location(surface, surface->draw_binding, NULL);
-}
-
-static HRESULT surface_draw_overlay(struct wined3d_surface *surface)
-{
-    HRESULT hr;
-
-    /* If there's no destination surface there is nothing to do. */
-    if (!surface->overlay_dest)
-        return WINED3D_OK;
-
-    /* Blt calls ModifyLocation on the dest surface, which in turn calls
-     * DrawOverlay to update the overlay. Prevent an endless recursion. */
-    if (surface->overlay_dest->flags & SFLAG_INOVERLAYDRAW)
-        return WINED3D_OK;
-
-    surface->overlay_dest->flags |= SFLAG_INOVERLAYDRAW;
-    hr = wined3d_surface_blt(surface->overlay_dest, &surface->overlay_destrect, surface,
-            &surface->overlay_srcrect, WINEDDBLT_WAIT, NULL, WINED3D_TEXF_LINEAR);
-    surface->overlay_dest->flags &= ~SFLAG_INOVERLAYDRAW;
-
-    return hr;
-}
-
-static void surface_map(struct wined3d_surface *surface, const RECT *rect, DWORD flags)
-{
-    struct wined3d_device *device = surface->resource.device;
-    const RECT *pass_rect = rect;
-
-    TRACE("surface %p, rect %s, flags %#x.\n",
-            surface, wine_dbgstr_rect(rect), flags);
-
-    if (flags & WINED3D_MAP_DISCARD)
-    {
-        TRACE("WINED3D_MAP_DISCARD flag passed, marking SYSMEM as up to date.\n");
-        surface_prepare_system_memory(surface);
-        surface_validate_location(surface, SFLAG_INSYSMEM);
-        surface_invalidate_location(surface, ~SFLAG_INSYSMEM);
-    }
-    else
-    {
-        if (surface->resource.usage & WINED3DUSAGE_DYNAMIC)
-            WARN_(d3d_perf)("Mapping a dynamic surface without WINED3D_MAP_DISCARD.\n");
-
-        /* surface_load_location() does not check if the rectangle specifies
-         * the full surface. Most callers don't need that, so do it here. */
-        if (rect && !rect->top && !rect->left
-                && rect->right == surface->resource.width
-                && rect->bottom == surface->resource.height)
-            pass_rect = NULL;
-        surface_load_location(surface, SFLAG_INSYSMEM, pass_rect);
-    }
-
-    if (surface->flags & SFLAG_PBO)
-    {
-        const struct wined3d_gl_info *gl_info;
-        struct wined3d_context *context;
-
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
+        wined3d_resource_load_location(&surface->resource, context, surface->draw_binding);
 
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-        checkGLcall("glBindBufferARB");
-
-        /* This shouldn't happen but could occur if some other function
-         * didn't handle the PBO properly. */
-        if (surface->resource.allocatedMemory)
-            ERR("The surface already has PBO memory allocated.\n");
-
-        surface->resource.allocatedMemory = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_READ_WRITE_ARB));
-        checkGLcall("glMapBufferARB");
-
-        /* Make sure the PBO isn't set anymore in order not to break non-PBO
-         * calls. */
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("glBindBufferARB");
-
-        context_release(context);
-    }
-
-    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
-    {
-        if (!rect)
-            surface_add_dirty_rect(surface, NULL);
-        else
-        {
-            struct wined3d_box b;
-
-            b.left = rect->left;
-            b.top = rect->top;
-            b.right = rect->right;
-            b.bottom = rect->bottom;
-            b.front = 0;
-            b.back = 1;
-            surface_add_dirty_rect(surface, &b);
-        }
-    }
+    context_release(context);
 }
 
-static void surface_unmap(struct wined3d_surface *surface)
+static void surface_frontbuffer_updated(struct wined3d_surface *surface)
 {
-    struct wined3d_device *device = surface->resource.device;
-    BOOL fullsurface;
-
-    TRACE("surface %p.\n", surface);
-
-    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
-
-    if (surface->flags & SFLAG_PBO)
-    {
-        const struct wined3d_gl_info *gl_info;
-        struct wined3d_context *context;
-
-        TRACE("Freeing PBO memory.\n");
-
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-        GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("glUnmapBufferARB");
-        context_release(context);
-
-        surface->resource.allocatedMemory = NULL;
-    }
-
-    TRACE("dirtyfied %u.\n", surface->flags & (SFLAG_INDRAWABLE | SFLAG_INTEXTURE) ? 0 : 1);
+    struct wined3d_context *context;
 
-    if (surface->flags & (SFLAG_INDRAWABLE | SFLAG_INTEXTURE))
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
     {
         TRACE("Not dirtified, nothing to do.\n");
-        goto done;
-    }
-
-    if (surface->swapchain && surface->swapchain->front_buffer == surface)
-    {
-        if (!surface->dirtyRect.left && !surface->dirtyRect.top
-                && surface->dirtyRect.right == surface->resource.width
-                && surface->dirtyRect.bottom == surface->resource.height)
-        {
-            fullsurface = TRUE;
-        }
-        else
-        {
-            /* TODO: Proper partial rectangle tracking. */
-            fullsurface = FALSE;
-            surface->flags |= SFLAG_INSYSMEM;
-        }
-
-        surface_load_location(surface, surface->draw_binding, fullsurface ? NULL : &surface->dirtyRect);
-
-        /* Partial rectangle tracking is not commonly implemented, it is only
-         * done for render targets. INSYSMEM was set before to tell
-         * surface_load_location() where to read the rectangle from.
-         * Indrawable is set because all modifications from the partial
-         * sysmem copy are written back to the drawable, thus the surface is
-         * merged again in the drawable. The sysmem copy is not fully up to
-         * date because only a subrectangle was read in Map(). */
-        if (!fullsurface)
-        {
-            surface_validate_location(surface, surface->draw_binding);
-            surface_invalidate_location(surface, ~surface->draw_binding);
-            surface_evict_sysmem(surface);
-        }
-
-        surface->dirtyRect.left = surface->resource.width;
-        surface->dirtyRect.top = surface->resource.height;
-        surface->dirtyRect.right = 0;
-        surface->dirtyRect.bottom = 0;
-    }
-    else if (surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
-    {
-        FIXME("Depth / stencil buffer locking is not implemented.\n");
+        return;
     }
 
-done:
-    /* Overlays have to be redrawn manually after changes with the GL implementation */
-    if (surface->overlay_dest)
-        surface_draw_overlay(surface);
+    context = context_acquire(surface->resource.device, NULL);
+    wined3d_resource_load_location(&surface->resource, context, surface->draw_binding);
+    context_release(context);
 }
 
 static BOOL surface_is_full_rect(const struct wined3d_surface *surface, const RECT *r)
@@ -1045,9 +814,9 @@
 
     TRACE("device %p\n", device);
     TRACE("src_surface %p, src_location %s, src_rect %s,\n",
-            src_surface, debug_surflocation(src_location), wine_dbgstr_rect(src_rect));
+            src_surface, wined3d_debug_location(src_location), wine_dbgstr_rect(src_rect));
     TRACE("dst_surface %p, dst_location %s, dst_rect %s.\n",
-            dst_surface, debug_surflocation(dst_location), wine_dbgstr_rect(dst_rect));
+            dst_surface, wined3d_debug_location(dst_location), wine_dbgstr_rect(dst_rect));
 
     src_mask = src_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
     dst_mask = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
@@ -1073,13 +842,14 @@
     if (src_mask & WINED3DFMT_FLAG_STENCIL)
         gl_mask |= GL_STENCIL_BUFFER_BIT;
 
+    context = context_acquire(device, NULL);
+
     /* Make sure the locations are up-to-date. Loading the destination
      * surface isn't required if the entire surface is overwritten. */
-    surface_load_location(src_surface, src_location, NULL);
+    wined3d_resource_load_location(&src_surface->resource, context, src_location);
     if (!surface_is_full_rect(dst_surface, dst_rect))
-        surface_load_location(dst_surface, dst_location, NULL);
+        wined3d_resource_load_location(&dst_surface->resource, context, dst_location);
 
-    context = context_acquire(device, NULL);
     if (!context->valid)
     {
         context_release(context);
@@ -1126,6 +896,26 @@
     context_release(context);
 }
 
+static void prepare_blit_quirks(const struct wined3d_device *device, const struct wined3d_gl_info *gl_info)
+{
+    /* ATI Macs blend blits even though GL_EXT_framebuffer_blit says that this
+     * operation does not blend. This sometimes even happens if GL_BLEND is
+     * disabled, although in my glut test case blending has to be enabled for
+     * the bug to occur. While we're at it, disable blending.
+     *
+     * Tracked by crossover hacks bug 5391. */
+    gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
+    gl_info->gl_ops.gl.p_glBlendFunc(GL_ONE, GL_ZERO);
+    device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHABLENDENABLE));
+
+    gl_info->gl_ops.gl.p_glDisable(GL_ALPHA_TEST);
+    gl_info->gl_ops.gl.p_glAlphaFunc(GL_ALWAYS, 0.0);
+    device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHATESTENABLE));
+    gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
+    gl_info->gl_ops.gl.p_glStencilFunc(GL_ALWAYS, 0, 0);
+    device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+}
+
 /* Blit between surface locations. Onscreen on different swapchains is not supported.
  * Depth / stencil is not supported. */
 static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_texture_filter_type filter,
@@ -1140,9 +930,9 @@
 
     TRACE("device %p, filter %s,\n", device, debug_d3dtexturefiltertype(filter));
     TRACE("src_surface %p, src_location %s, src_rect %s,\n",
-            src_surface, debug_surflocation(src_location), wine_dbgstr_rect(src_rect_in));
+            src_surface, wined3d_debug_location(src_location), wine_dbgstr_rect(src_rect_in));
     TRACE("dst_surface %p, dst_location %s, dst_rect %s.\n",
-            dst_surface, debug_surflocation(dst_location), wine_dbgstr_rect(dst_rect_in));
+            dst_surface, wined3d_debug_location(dst_location), wine_dbgstr_rect(dst_rect_in));
 
     src_rect = *src_rect_in;
     dst_rect = *dst_rect_in;
@@ -1162,22 +952,14 @@
     }
 
     /* Resolve the source surface first if needed. */
-    if (src_location == SFLAG_INRB_MULTISAMPLE
+    if (src_location == WINED3D_LOCATION_RB_MULTISAMPLE
             && (src_surface->resource.format->id != dst_surface->resource.format->id
                 || abs(src_rect.bottom - src_rect.top) != abs(dst_rect.bottom - dst_rect.top)
                 || abs(src_rect.right - src_rect.left) != abs(dst_rect.right - dst_rect.left)))
-        src_location = SFLAG_INRB_RESOLVED;
-
-    /* Make sure the locations are up-to-date. Loading the destination
-     * surface isn't required if the entire surface is overwritten. (And is
-     * in fact harmful if we're being called by surface_load_location() with
-     * the purpose of loading the destination surface.) */
-    surface_load_location(src_surface, src_location, NULL);
-    if (!surface_is_full_rect(dst_surface, &dst_rect))
-        surface_load_location(dst_surface, dst_location, NULL);
+        src_location = WINED3D_LOCATION_RB_RESOLVED;
 
-    if (src_location == SFLAG_INDRAWABLE) context = context_acquire(device, src_surface);
-    else if (dst_location == SFLAG_INDRAWABLE) context = context_acquire(device, dst_surface);
+    if (src_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, src_surface);
+    else if (dst_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, dst_surface);
     else context = context_acquire(device, NULL);
 
     if (!context->valid)
@@ -1187,9 +969,17 @@
         return;
     }
 
+    /* Make sure the locations are up-to-date. Loading the destination
+     * surface isn't required if the entire surface is overwritten. (And is
+     * in fact harmful if we're being called by wined3d_surface_load_location() with
+     * the purpose of loading the destination surface.) */
+    wined3d_resource_load_location(&src_surface->resource, context, src_location);
+    if (!surface_is_full_rect(dst_surface, &dst_rect))
+        wined3d_resource_load_location(&dst_surface->resource, context, dst_location);
+
     gl_info = context->gl_info;
 
-    if (src_location == SFLAG_INDRAWABLE)
+    if (src_location == WINED3D_LOCATION_DRAWABLE)
     {
         TRACE("Source surface %p is onscreen.\n", src_surface);
         buffer = surface_get_gl_buffer(src_surface);
@@ -1206,7 +996,7 @@
     checkGLcall("glReadBuffer()");
     context_check_fbo_status(context, GL_READ_FRAMEBUFFER);
 
-    if (dst_location == SFLAG_INDRAWABLE)
+    if (dst_location == WINED3D_LOCATION_DRAWABLE)
     {
         TRACE("Destination surface %p is onscreen.\n", dst_surface);
         buffer = surface_get_gl_buffer(dst_surface);
@@ -1232,12 +1022,15 @@
     gl_info->gl_ops.gl.p_glDisable(GL_SCISSOR_TEST);
     context_invalidate_state(context, STATE_RENDER(WINED3D_RS_SCISSORTESTENABLE));
 
+    if (gl_info->quirks & WINED3D_CX_QUIRK_BLIT)
+        prepare_blit_quirks(device, gl_info);
+
     gl_info->fbo_ops.glBlitFramebuffer(src_rect.left, src_rect.top, src_rect.right, src_rect.bottom,
             dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom, GL_COLOR_BUFFER_BIT, gl_filter);
     checkGLcall("glBlitFramebuffer()");
 
     if (wined3d_settings.strict_draw_ordering
-            || (dst_location == SFLAG_INDRAWABLE
+            || (dst_location == WINED3D_LOCATION_DRAWABLE
             && dst_surface->swapchain->front_buffer == dst_surface))
         gl_info->gl_ops.gl.p_glFlush();
 
@@ -1416,67 +1209,6 @@
     return wined3d_surface_blt(surface, NULL, render_target, NULL, 0, NULL, WINED3D_TEXF_POINT);
 }
 
-/* Context activation is done by the caller. */
-static void surface_remove_pbo(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info)
-{
-    if (surface->flags & SFLAG_DIBSECTION)
-    {
-        surface->resource.allocatedMemory = surface->dib.bitmap_data;
-    }
-    else
-    {
-        if (!surface->resource.heap_memory)
-            wined3d_resource_allocate_sysmem(&surface->resource);
-        else if (!(surface->flags & SFLAG_CLIENT))
-            ERR("Surface %p has heap_memory %p and flags %#x.\n",
-                    surface, surface->resource.heap_memory, surface->flags);
-
-        surface->resource.allocatedMemory = surface->resource.heap_memory;
-    }
-
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-    checkGLcall("glBindBufferARB(GL_PIXEL_UNPACK_BUFFER, surface->pbo)");
-    GL_EXTCALL(glGetBufferSubDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0,
-            surface->resource.size, surface->resource.allocatedMemory));
-    checkGLcall("glGetBufferSubDataARB");
-    GL_EXTCALL(glDeleteBuffersARB(1, &surface->pbo));
-    checkGLcall("glDeleteBuffersARB");
-
-    surface->pbo = 0;
-    surface->flags &= ~SFLAG_PBO;
-}
-
-static BOOL surface_init_sysmem(struct wined3d_surface *surface)
-{
-    if (!surface->resource.allocatedMemory)
-    {
-        if (!surface->resource.heap_memory)
-        {
-            if (!wined3d_resource_allocate_sysmem(&surface->resource))
-            {
-                ERR("Failed to allocate system memory.\n");
-                return FALSE;
-            }
-        }
-        else if (!(surface->flags & SFLAG_CLIENT))
-        {
-            ERR("Surface %p has heap_memory %p and flags %#x.\n",
-                    surface, surface->resource.heap_memory, surface->flags);
-        }
-
-        surface->resource.allocatedMemory = surface->resource.heap_memory;
-    }
-    else
-    {
-        memset(surface->resource.allocatedMemory, 0, surface->resource.size);
-    }
-
-    surface_validate_location(surface, SFLAG_INSYSMEM);
-    surface_invalidate_location(surface, ~SFLAG_INSYSMEM);
-
-    return TRUE;
-}
-
 static void surface_unload(struct wined3d_resource *resource)
 {
     struct wined3d_surface *surface = surface_from_resource(resource);
@@ -1487,20 +1219,19 @@
 
     TRACE("surface %p.\n", surface);
 
-    if (resource->pool == WINED3D_POOL_DEFAULT)
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    if (resource->pool == WINED3D_POOL_DEFAULT
+            || !wined3d_resource_prepare_system_memory(&surface->resource))
     {
         /* Default pool resources are supposed to be destroyed before Reset is called.
          * Implicit resources stay however. So this means we have an implicit render target
          * or depth stencil. The content may be destroyed, but we still have to tear down
-         * opengl resources, so we cannot leave early.
-         *
-         * Put the surfaces into sysmem, and reset the content. The D3D content is undefined,
-         * but we can't set the sysmem INDRAWABLE because when we're rendering the swapchain
-         * or the depth stencil into an FBO the texture or render buffer will be removed
-         * and all flags get lost
-         */
-        if (!(surface->flags & SFLAG_PBO))
-            surface_init_sysmem(surface);
+         * opengl resources, so we cannot leave early. */
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DISCARDED);
+
         /* We also get here when the ddraw swapchain is destroyed, for example
          * for a mode switch. In this case this surface won't necessarily be
          * an implicit surface. We have to mark it lost so that the
@@ -1509,19 +1240,11 @@
     }
     else
     {
-        /* Load the surface into system memory */
-        surface_load_location(surface, SFLAG_INSYSMEM, NULL);
-        surface_invalidate_location(surface, surface->draw_binding);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_SYSMEM);
     }
-    surface_invalidate_location(surface, SFLAG_INTEXTURE | SFLAG_INSRGBTEX);
-    surface->flags &= ~(SFLAG_ALLOCATED | SFLAG_SRGBALLOCATED);
-
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
 
-    /* Destroy PBOs, but load them into real sysmem before */
-    if (surface->flags & SFLAG_PBO)
-        surface_remove_pbo(surface, gl_info);
+    surface->flags &= ~(SFLAG_ALLOCATED | SFLAG_SRGBALLOCATED);
 
     /* Destroy fbo render buffers. This is needed for implicit render targets, for
      * all application-created targets the application has to release the surface
@@ -1561,17 +1284,33 @@
     resource_unload(resource);
 }
 
+/* TODO: Fix this before sending... */
+static void wined3d_surface_load_location(struct wined3d_resource *resource, struct wined3d_context *context,
+        DWORD location);
+
+static void wined3d_surface_changed(struct wined3d_resource *resource)
+{
+    struct wined3d_surface *surface = surface_from_resource(resource);
+
+    if (surface->container)
+        wined3d_texture_set_dirty(surface->container);
+
+    if (surface->swapchain && surface == surface->swapchain->front_buffer)
+        surface->surface_ops->surface_frontbuffer_updated(surface);
+}
+
 static const struct wined3d_resource_ops surface_resource_ops =
 {
     surface_unload,
+    wined3d_surface_load_location,
+    wined3d_surface_changed,
 };
 
 static const struct wined3d_surface_ops surface_ops =
 {
     surface_private_setup,
     surface_realize_palette,
-    surface_map,
-    surface_unmap,
+    surface_frontbuffer_updated,
 };
 
 /*****************************************************************************
@@ -1591,8 +1330,6 @@
  *****************************************************************************/
 static HRESULT gdi_surface_private_setup(struct wined3d_surface *surface)
 {
-    HRESULT hr;
-
     TRACE("surface %p.\n", surface);
 
     if (surface->resource.usage & WINED3DUSAGE_OVERLAY)
@@ -1601,19 +1338,13 @@
         return WINED3DERR_INVALIDCALL;
     }
 
-    /* Sysmem textures have memory already allocated - release it,
-     * this avoids an unnecessary memcpy. */
-    hr = surface_create_dib_section(surface);
-    if (SUCCEEDED(hr))
-    {
-        wined3d_resource_free_sysmem(&surface->resource);
-        surface->resource.allocatedMemory = surface->dib.bitmap_data;
-    }
-
     /* We don't mind the nonpow2 stuff in GDI. */
     surface->pow2Width = surface->resource.width;
     surface->pow2Height = surface->resource.height;
 
+    if (surface->resource.format->flags & WINED3DFMT_FLAG_GETDC)
+        surface->resource.map_binding = WINED3D_LOCATION_DIB;
+
     return WINED3D_OK;
 }
 
@@ -1649,44 +1380,16 @@
         x11_copy_to_screen(surface->swapchain, NULL);
 }
 
-static void gdi_surface_map(struct wined3d_surface *surface, const RECT *rect, DWORD flags)
+static void gdi_surface_frontbuffer_updated(struct wined3d_surface *surface)
 {
-    TRACE("surface %p, rect %s, flags %#x.\n",
-            surface, wine_dbgstr_rect(rect), flags);
-
-    if (!(surface->flags & SFLAG_DIBSECTION))
-    {
-        HRESULT hr;
-
-        /* This happens on gdi surfaces if the application set a user pointer
-         * and resets it. Recreate the DIB section. */
-        if (FAILED(hr = surface_create_dib_section(surface)))
-        {
-            ERR("Failed to create dib section, hr %#x.\n", hr);
-            return;
-        }
-        wined3d_resource_free_sysmem(&surface->resource);
-        surface->resource.allocatedMemory = surface->dib.bitmap_data;
-    }
-}
-
-static void gdi_surface_unmap(struct wined3d_surface *surface)
-{
-    TRACE("surface %p.\n", surface);
-
-    /* Tell the swapchain to update the screen. */
-    if (surface->swapchain && surface == surface->swapchain->front_buffer)
-        x11_copy_to_screen(surface->swapchain, &surface->lockedRect);
-
-    memset(&surface->lockedRect, 0, sizeof(RECT));
+    x11_copy_to_screen(surface->swapchain, &surface->lockedRect);
 }
 
 static const struct wined3d_surface_ops gdi_surface_ops =
 {
     gdi_surface_private_setup,
     gdi_surface_realize_palette,
-    gdi_surface_map,
-    gdi_surface_unmap,
+    gdi_surface_frontbuffer_updated,
 };
 
 void surface_set_texture_name(struct wined3d_surface *surface, GLuint name, BOOL srgb)
@@ -1724,7 +1427,8 @@
 /* This call just downloads data, the caller is responsible for binding the
  * correct texture. */
 /* Context activation is done by the caller. */
-static void surface_download_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info)
+static void surface_download_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_bo_address *data)
 {
     const struct wined3d_format *format = surface->resource.format;
 
@@ -1735,35 +1439,29 @@
         return;
     }
 
+    if (data->buffer_object)
+    {
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, data->buffer_object));
+        checkGLcall("glBindBufferARB");
+    }
+
     if (format->flags & WINED3DFMT_FLAG_COMPRESSED)
     {
         TRACE("(%p) : Calling glGetCompressedTexImageARB level %d, format %#x, type %#x, data %p.\n",
                 surface, surface->texture_level, format->glFormat, format->glType,
-                surface->resource.allocatedMemory);
+                data->addr);
 
-        if (surface->flags & SFLAG_PBO)
-        {
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, surface->pbo));
-            checkGLcall("glBindBufferARB");
-            GL_EXTCALL(glGetCompressedTexImageARB(surface->texture_target, surface->texture_level, NULL));
-            checkGLcall("glGetCompressedTexImageARB");
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
-            checkGLcall("glBindBufferARB");
-        }
-        else
-        {
-            GL_EXTCALL(glGetCompressedTexImageARB(surface->texture_target,
-                    surface->texture_level, surface->resource.allocatedMemory));
-            checkGLcall("glGetCompressedTexImageARB");
-        }
+        GL_EXTCALL(glGetCompressedTexImageARB(surface->texture_target,
+                surface->texture_level, data->addr));
+        checkGLcall("glGetCompressedTexImageARB");
     }
     else
     {
         void *mem;
         GLenum gl_format = format->glFormat;
         GLenum gl_type = format->glType;
-        int src_pitch = 0;
-        int dst_pitch = 0;
+        UINT src_pitch = 0;
+        UINT dst_row_pitch, dst_slice_pitch;
 
         /* In case of P8 the index is stored in the alpha component if the primary render target uses P8. */
         if (format->id == WINED3DFMT_P8_UINT && swapchain_is_p8(surface->resource.device->swapchains[0]))
@@ -1776,36 +1474,24 @@
         {
             unsigned char alignment = surface->resource.device->surface_alignment;
             src_pitch = format->byte_count * surface->pow2Width;
-            dst_pitch = wined3d_surface_get_pitch(surface);
+            wined3d_resource_get_pitch(&surface->resource, &dst_row_pitch, &dst_slice_pitch);
             src_pitch = (src_pitch + alignment - 1) & ~(alignment - 1);
             mem = HeapAlloc(GetProcessHeap(), 0, src_pitch * surface->pow2Height);
+
+            if (data->buffer_object)
+                ERR("Attempting to download a SFLAG_NONPOW2 texture with a PBO\n");
         }
         else
         {
-            mem = surface->resource.allocatedMemory;
+            mem = data->addr;
         }
 
         TRACE("(%p) : Calling glGetTexImage level %d, format %#x, type %#x, data %p\n",
                 surface, surface->texture_level, gl_format, gl_type, mem);
 
-        if (surface->flags & SFLAG_PBO)
-        {
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, surface->pbo));
-            checkGLcall("glBindBufferARB");
-
-            gl_info->gl_ops.gl.p_glGetTexImage(surface->texture_target, surface->texture_level,
-                    gl_format, gl_type, NULL);
-            checkGLcall("glGetTexImage");
-
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
-            checkGLcall("glBindBufferARB");
-        }
-        else
-        {
-            gl_info->gl_ops.gl.p_glGetTexImage(surface->texture_target, surface->texture_level,
-                    gl_format, gl_type, mem);
-            checkGLcall("glGetTexImage");
-        }
+        gl_info->gl_ops.gl.p_glGetTexImage(surface->texture_target, surface->texture_level,
+                gl_format, gl_type, mem);
+        checkGLcall("glGetTexImage");
 
         if (surface->flags & SFLAG_NONPOW2)
         {
@@ -1852,7 +1538,7 @@
              * |444444444444444444|    \/
              * --------------------
              *
-             * this also means that any references to allocatedMemory should work with the data as if were a
+             * this also means that any references to system memory should work with the data as if were a
              * standard texture with a non-power2 width instead of texture boxed up to be a power2 texture.
              *
              * internally the texture is still stored in a boxed format so any references to textureName will
@@ -1862,151 +1548,71 @@
              * rendering. If an app does, the SFLAG_DYNLOCK flag will kick in and the memory copy won't be released,
              * and doesn't have to be re-read. */
             src_data = mem;
-            dst_data = surface->resource.allocatedMemory;
-            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_pitch);
+            dst_data = data->addr;
+            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_row_pitch);
             for (y = 0; y < surface->resource.height; ++y)
             {
-                memcpy(dst_data, src_data, dst_pitch);
+                memcpy(dst_data, src_data, dst_row_pitch);
                 src_data += src_pitch;
-                dst_data += dst_pitch;
+                dst_data += dst_row_pitch;
             }
 
             HeapFree(GetProcessHeap(), 0, mem);
         }
     }
-
-    /* Surface has now been downloaded */
-    surface->flags |= SFLAG_INSYSMEM;
-}
-
-/* This call just uploads data, the caller is responsible for binding the
- * correct texture. */
-/* Context activation is done by the caller. */
-static void surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
-        const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
-        BOOL srgb, const struct wined3d_bo_address *data)
-{
-    UINT update_w = src_rect->right - src_rect->left;
-    UINT update_h = src_rect->bottom - src_rect->top;
-
-    TRACE("surface %p, gl_info %p, format %s, src_rect %s, src_pitch %u, dst_point %s, srgb %#x, data {%#x:%p}.\n",
-            surface, gl_info, debug_d3dformat(format->id), wine_dbgstr_rect(src_rect), src_pitch,
-            wine_dbgstr_point(dst_point), srgb, data->buffer_object, data->addr);
-
-    if (surface->resource.map_count)
-    {
-        WARN("Uploading a surface that is currently mapped, setting SFLAG_PIN_SYSMEM.\n");
-        surface->flags |= SFLAG_PIN_SYSMEM;
-    }
-
-    if (format->flags & WINED3DFMT_FLAG_HEIGHT_SCALE)
-    {
-        update_h *= format->height_scale.numerator;
-        update_h /= format->height_scale.denominator;
-    }
-
-    if (data->buffer_object)
-    {
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, data->buffer_object));
-        checkGLcall("glBindBufferARB");
-    }
-
-    if (format->flags & WINED3DFMT_FLAG_COMPRESSED)
-    {
-        UINT row_length = wined3d_format_calculate_size(format, 1, update_w, 1, 1);
-        UINT row_count = (update_h + format->block_height - 1) / format->block_height;
-        const BYTE *addr = data->addr;
-        GLenum internal;
-
-        addr += (src_rect->top / format->block_height) * src_pitch;
-        addr += (src_rect->left / format->block_width) * format->block_byte_count;
-
-        if (srgb)
-            internal = format->glGammaInternal;
-        else if (surface->resource.usage & WINED3DUSAGE_RENDERTARGET && surface_is_offscreen(surface))
-            internal = format->rtInternal;
-        else
-            internal = format->glInternal;
-
-        TRACE("glCompressedTexSubImage2DARB, target %#x, level %d, x %d, y %d, w %d, h %d, "
-                "format %#x, image_size %#x, addr %p.\n", surface->texture_target, surface->texture_level,
-                dst_point->x, dst_point->y, update_w, update_h, internal, row_count * row_length, addr);
-
-        if (row_length == src_pitch)
-        {
-            GL_EXTCALL(glCompressedTexSubImage2DARB(surface->texture_target, surface->texture_level,
-                    dst_point->x, dst_point->y, update_w, update_h, internal, row_count * row_length, addr));
-        }
-        else
-        {
-            UINT row, y;
-
-            /* glCompressedTexSubImage2DARB() ignores pixel store state, so we
-             * can't use the unpack row length like below. */
-            for (row = 0, y = dst_point->y; row < row_count; ++row)
-            {
-                GL_EXTCALL(glCompressedTexSubImage2DARB(surface->texture_target, surface->texture_level,
-                        dst_point->x, y, update_w, format->block_height, internal, row_length, addr));
-                y += format->block_height;
-                addr += src_pitch;
-            }
-        }
-        checkGLcall("glCompressedTexSubImage2DARB");
-    }
-    else
-    {
-        const BYTE *addr = data->addr;
-
-        addr += src_rect->top * src_pitch;
-        addr += src_rect->left * format->byte_count;
-
-        TRACE("glTexSubImage2D, target %#x, level %d, x %d, y %d, w %d, h %d, format %#x, type %#x, addr %p.\n",
-                surface->texture_target, surface->texture_level, dst_point->x, dst_point->y,
-                update_w, update_h, format->glFormat, format->glType, addr);
-
-        gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_ROW_LENGTH, src_pitch / format->byte_count);
-        gl_info->gl_ops.gl.p_glTexSubImage2D(surface->texture_target, surface->texture_level,
-                dst_point->x, dst_point->y, update_w, update_h, format->glFormat, format->glType, addr);
-        gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
-        checkGLcall("glTexSubImage2D");
-    }
-
     if (data->buffer_object)
     {
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
         checkGLcall("glBindBufferARB");
     }
 
     if (wined3d_settings.strict_draw_ordering)
         gl_info->gl_ops.gl.p_glFlush();
+}
 
-    if (gl_info->quirks & WINED3D_QUIRK_FBO_TEX_UPDATE)
+static BOOL format_is_srgb(GLenum internal)
+{
+    switch (internal)
     {
-        struct wined3d_device *device = surface->resource.device;
-        unsigned int i;
+        case GL_SRGB_EXT:
+        case GL_SRGB8_EXT:
+        case GL_SRGB_ALPHA_EXT:
+        case GL_SRGB8_ALPHA8_EXT:
+        case GL_SLUMINANCE_ALPHA_EXT:
+        case GL_SLUMINANCE8_ALPHA8_EXT:
+        case GL_SLUMINANCE_EXT:
+        case GL_SLUMINANCE8_EXT:
+        case GL_COMPRESSED_SRGB_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_EXT:
+        case GL_COMPRESSED_SLUMINANCE_EXT:
+        case GL_COMPRESSED_SLUMINANCE_ALPHA_EXT:
+        case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
+            return TRUE;
 
-        for (i = 0; i < device->context_count; ++i)
-        {
-            context_surface_update(device->contexts[i], surface);
-        }
+        default:
+            return FALSE;
     }
 }
 
 static HRESULT d3dfmt_get_conv(const struct wined3d_surface *surface, BOOL need_alpha_ck, BOOL use_texturing,
-        struct wined3d_format *format, enum wined3d_conversion_type *conversion_type)
+        struct wined3d_format *format, const struct wined3d_format *src_format, enum wined3d_conversion_type *conversion_type)
 {
     BOOL colorkey_active = need_alpha_ck && (surface->CKeyFlags & WINEDDSD_CKSRCBLT);
     const struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     BOOL blit_supported = FALSE;
+    const struct wined3d_fb_state *fb = &device->state.fb;
 
     /* Copy the default values from the surface. Below we might perform fixups */
     /* TODO: get rid of color keying desc fixups by using e.g. a table. */
-    *format = *surface->resource.format;
+    *format = *src_format;
     *conversion_type = WINED3D_CT_NONE;
 
     /* Ok, now look if we have to do any conversion */
-    switch (surface->resource.format->id)
+    switch (src_format->id)
     {
         case WINED3DFMT_P8_UINT:
             /* Below the call to blit_supported is disabled for Wine 1.2
@@ -2030,7 +1636,7 @@
              * in which the main render target uses p8. Some games like GTA Vice City use P8 for texturing which
              * conflicts with this.
              */
-            if (!((blit_supported && device->fb.render_targets && surface == device->fb.render_targets[0]))
+            if (!((blit_supported && fb->render_targets && surface == fb->render_targets[0]))
                     || colorkey_active || !use_texturing)
             {
                 format->glFormat = GL_RGBA;
@@ -2120,115 +1726,440 @@
     return WINED3D_OK;
 }
 
-static BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
+static BOOL color_in_range(const struct wined3d_color_key *color_key, DWORD color)
 {
-    UINT width_mask, height_mask;
-
-    if (!rect->left && !rect->top
-            && rect->right == surface->resource.width
-            && rect->bottom == surface->resource.height)
-        return TRUE;
-
-    /* This assumes power of two block sizes, but NPOT block sizes would be
-     * silly anyway. */
-    width_mask = surface->resource.format->block_width - 1;
-    height_mask = surface->resource.format->block_height - 1;
-
-    if (!(rect->left & width_mask) && !(rect->top & height_mask)
-            && !(rect->right & width_mask) && !(rect->bottom & height_mask))
-        return TRUE;
-
-    return FALSE;
+    /* FIXME: Is this really how color keys are supposed to work? I think it
+     * makes more sense to compare the individual channels. */
+    return color >= color_key->color_space_low_value
+            && color <= color_key->color_space_high_value;
 }
 
-HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
-        struct wined3d_surface *src_surface, const RECT *src_rect)
-{
-    const struct wined3d_format *src_format;
-    const struct wined3d_format *dst_format;
-    const struct wined3d_gl_info *gl_info;
-    enum wined3d_conversion_type convert;
-    struct wined3d_context *context;
-    struct wined3d_bo_address data;
-    struct wined3d_format format;
-    UINT update_w, update_h;
-    UINT dst_w, dst_h;
-    RECT r, dst_rect;
-    UINT src_pitch;
-    POINT p;
 
-    TRACE("dst_surface %p, dst_point %s, src_surface %p, src_rect %s.\n",
-            dst_surface, wine_dbgstr_point(dst_point),
-            src_surface, wine_dbgstr_rect(src_rect));
+static HRESULT d3dfmt_convert_surface(const BYTE *src, BYTE *dst, UINT pitch, UINT width, UINT height,
+        UINT outpitch, enum wined3d_conversion_type conversion_type, struct wined3d_surface *surface)
+{
+    const BYTE *source;
+    BYTE *dest;
 
-    src_format = src_surface->resource.format;
-    dst_format = dst_surface->resource.format;
+    TRACE("src %p, dst %p, pitch %u, width %u, height %u, outpitch %u, conversion_type %#x, surface %p.\n",
+            src, dst, pitch, width, height, outpitch, conversion_type, surface);
 
-    if (src_format->id != dst_format->id)
+    switch (conversion_type)
     {
-        WARN("Source and destination surfaces should have the same format.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+        case WINED3D_CT_NONE:
+        {
+            memcpy(dst, src, pitch * height);
+            break;
+        }
 
-    if (!dst_point)
-    {
-        p.x = 0;
-        p.y = 0;
-        dst_point = &p;
-    }
-    else if (dst_point->x < 0 || dst_point->y < 0)
-    {
-        WARN("Invalid destination point.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+        case WINED3D_CT_PALETTED:
+        case WINED3D_CT_PALETTED_CK:
+        {
+            BYTE table[256][4];
+            unsigned int x, y;
 
-    if (!src_rect)
-    {
-        r.left = 0;
-        r.top = 0;
-        r.right = src_surface->resource.width;
-        r.bottom = src_surface->resource.height;
-        src_rect = &r;
-    }
-    else if (src_rect->left < 0 || src_rect->left >= src_rect->right
-            || src_rect->top < 0 || src_rect->top >= src_rect->bottom)
-    {
-        WARN("Invalid source rectangle.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+            d3dfmt_p8_init_palette(surface, table, (conversion_type == WINED3D_CT_PALETTED_CK));
 
-    dst_w = dst_surface->resource.width;
-    dst_h = dst_surface->resource.height;
+            for (y = 0; y < height; y++)
+            {
+                source = src + pitch * y;
+                dest = dst + outpitch * y;
+                /* This is an 1 bpp format, using the width here is fine */
+                for (x = 0; x < width; x++) {
+                    BYTE color = *source++;
+                    *dest++ = table[color][0];
+                    *dest++ = table[color][1];
+                    *dest++ = table[color][2];
+                    *dest++ = table[color][3];
+                }
+            }
+        }
+        break;
 
-    update_w = src_rect->right - src_rect->left;
-    update_h = src_rect->bottom - src_rect->top;
+        case WINED3D_CT_CK_565:
+        {
+            /* Converting the 565 format in 5551 packed to emulate color-keying.
 
-    if (update_w > dst_w || dst_point->x > dst_w - update_w
-            || update_h > dst_h || dst_point->y > dst_h - update_h)
-    {
-        WARN("Destination out of bounds.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+              Note : in all these conversion, it would be best to average the averaging
+                      pixels to get the color of the pixel that will be color-keyed to
+                      prevent 'color bleeding'. This will be done later on if ever it is
+                      too visible.
 
-    if ((src_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(src_surface, src_rect))
-    {
-        WARN("Source rectangle not block-aligned.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+              Note2: Nvidia documents say that their driver does not support alpha + color keying
+                     on the same surface and disables color keying in such a case
+            */
+            unsigned int x, y;
+            const WORD *Source;
+            WORD *Dest;
 
-    SetRect(&dst_rect, dst_point->x, dst_point->y, dst_point->x + update_w, dst_point->y + update_h);
-    if ((dst_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(dst_surface, &dst_rect))
-    {
-        WARN("Destination rectangle not block-aligned.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+            TRACE("Color keyed 565\n");
 
-    /* Use wined3d_surface_blt() instead of uploading directly if we need conversion. */
-    d3dfmt_get_conv(dst_surface, FALSE, TRUE, &format, &convert);
-    if (convert != WINED3D_CT_NONE || format.convert)
-        return wined3d_surface_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
+            for (y = 0; y < height; y++) {
+                Source = (const WORD *)(src + y * pitch);
+                Dest = (WORD *) (dst + y * outpitch);
+                for (x = 0; x < width; x++ ) {
+                    WORD color = *Source++;
+                    *Dest = ((color & 0xffc0) | ((color & 0x1f) << 1));
+                    if (!color_in_range(&surface->src_blt_color_key, color))
+                        *Dest |= 0x0001;
+                    Dest++;
+                }
+            }
+        }
+        break;
 
-    context = context_acquire(dst_surface->resource.device, NULL);
+        case WINED3D_CT_CK_5551:
+        {
+            /* Converting X1R5G5B5 format to R5G5B5A1 to emulate color-keying. */
+            unsigned int x, y;
+            const WORD *Source;
+            WORD *Dest;
+            TRACE("Color keyed 5551\n");
+            for (y = 0; y < height; y++) {
+                Source = (const WORD *)(src + y * pitch);
+                Dest = (WORD *) (dst + y * outpitch);
+                for (x = 0; x < width; x++ ) {
+                    WORD color = *Source++;
+                    *Dest = color;
+                    if (!color_in_range(&surface->src_blt_color_key, color))
+                        *Dest |= (1 << 15);
+                    else
+                        *Dest &= ~(1 << 15);
+                    Dest++;
+                }
+            }
+        }
+        break;
+
+        case WINED3D_CT_CK_RGB24:
+        {
+            /* Converting R8G8B8 format to R8G8B8A8 with color-keying. */
+            unsigned int x, y;
+            for (y = 0; y < height; y++)
+            {
+                source = src + pitch * y;
+                dest = dst + outpitch * y;
+                for (x = 0; x < width; x++) {
+                    DWORD color = ((DWORD)source[0] << 16) + ((DWORD)source[1] << 8) + (DWORD)source[2] ;
+                    DWORD dstcolor = color << 8;
+                    if (!color_in_range(&surface->src_blt_color_key, color))
+                        dstcolor |= 0xff;
+                    *(DWORD*)dest = dstcolor;
+                    source += 3;
+                    dest += 4;
+                }
+            }
+        }
+        break;
+
+        case WINED3D_CT_RGB32_888:
+        {
+            /* Converting X8R8G8B8 format to R8G8B8A8 with color-keying. */
+            unsigned int x, y;
+            for (y = 0; y < height; y++)
+            {
+                source = src + pitch * y;
+                dest = dst + outpitch * y;
+                for (x = 0; x < width; x++) {
+                    DWORD color = 0xffffff & *(const DWORD*)source;
+                    DWORD dstcolor = color << 8;
+                    if (!color_in_range(&surface->src_blt_color_key, color))
+                        dstcolor |= 0xff;
+                    *(DWORD*)dest = dstcolor;
+                    source += 4;
+                    dest += 4;
+                }
+            }
+        }
+        break;
+
+        case WINED3D_CT_CK_ARGB32:
+        {
+            unsigned int x, y;
+            for (y = 0; y < height; ++y)
+            {
+                source = src + pitch * y;
+                dest = dst + outpitch * y;
+                for (x = 0; x < width; ++x)
+                {
+                    DWORD color = *(const DWORD *)source;
+                    if (color_in_range(&surface->src_blt_color_key, color))
+                        color &= ~0xff000000;
+                    *(DWORD*)dest = color;
+                    source += 4;
+                    dest += 4;
+                }
+            }
+        }
+        break;
+
+        default:
+            ERR("Unsupported conversion type %#x.\n", conversion_type);
+    }
+    return WINED3D_OK;
+}
+
+/* This call just uploads data, the caller is responsible for binding the
+ * correct texture. */
+/* Context activation is done by the caller. */
+static BOOL surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_format *src_format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
+        BOOL srgb, const struct wined3d_bo_address *data)
+{
+    UINT update_w = src_rect->right - src_rect->left;
+    UINT update_h = src_rect->bottom - src_rect->top;
+    BYTE *mem, *conv_dst = NULL, *conv_src = data->addr;
+    enum wined3d_conversion_type convert;
+    DWORD conv_dst_pitch;
+    const struct wined3d_device *device = surface->resource.device;
+    struct wined3d_format conv_format;
+    BOOL adjust_initial_offset = TRUE;
+
+    TRACE("surface %p, gl_info %p, format %s, src_rect %s, src_pitch %u, dst_point %s, srgb %#x, data {%#x:%p}.\n",
+            surface, gl_info, debug_d3dformat(src_format->id), wine_dbgstr_rect(src_rect), src_pitch,
+            wine_dbgstr_point(dst_point), srgb, data->buffer_object, data->addr);
+
+    if (surface->resource.map_count)
+    {
+        WARN("Uploading a surface that is currently mapped, setting SFLAG_PIN_SYSMEM.\n");
+        surface->flags |= SFLAG_PIN_SYSMEM;
+    }
+
+    if (src_format->flags & WINED3DFMT_FLAG_HEIGHT_SCALE)
+    {
+        update_h *= src_format->height_scale.numerator;
+        update_h /= src_format->height_scale.denominator;
+    }
+
+    if (data->buffer_object)
+    {
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, data->buffer_object));
+        checkGLcall("glBindBufferARB");
+    }
+
+    d3dfmt_get_conv(surface, TRUE /* We need color keying */,
+            TRUE /* We will use textures */, &conv_format, src_format, &convert);
+    if (src_format->convert || convert != WINED3D_CT_NONE)
+    {
+        if (data->buffer_object)
+            ERR("Attempting to load a converted surface from a PBO.\n");
+        if (conv_format.flags & WINED3DFMT_FLAG_COMPRESSED)
+            ERR("Converting a compressed format.\n");
+
+        conv_src += src_rect->top * src_pitch;
+        conv_src += src_rect->left * src_format->byte_count;
+
+        /* Stick to the alignment for the converted surface too, makes it easier to load the surface */
+        conv_dst_pitch = update_w * conv_format.conv_byte_count;
+        conv_dst_pitch = (conv_dst_pitch + device->surface_alignment - 1) & ~(device->surface_alignment - 1);
+
+        if (!(conv_dst = HeapAlloc(GetProcessHeap(), 0, conv_dst_pitch * update_h)))
+        {
+            ERR("Out of memory (%u).\n", conv_dst_pitch * update_h);
+            return FALSE;
+        }
+
+        if (src_format->convert)
+            src_format->convert(conv_src, conv_dst, src_pitch, src_pitch * update_h,
+                    conv_dst_pitch, conv_dst_pitch * update_h, update_w, update_h, 1);
+        else
+            d3dfmt_convert_surface(conv_src, conv_dst, src_pitch,
+                    update_w, update_h, conv_dst_pitch, convert, surface);
+
+        conv_format.byte_count = conv_format.conv_byte_count;
+        src_pitch = conv_dst_pitch;
+        mem = conv_dst;
+        adjust_initial_offset = FALSE;
+    }
+    else
+    {
+        mem = data->addr;
+    }
+
+    if (conv_format.flags & WINED3DFMT_FLAG_COMPRESSED)
+    {
+        UINT row_length = wined3d_format_calculate_size(&conv_format, 1, update_w, 1, 1);
+        UINT row_count = (update_h + conv_format.block_height - 1) / conv_format.block_height;
+        GLenum internal;
+
+        if (adjust_initial_offset)
+        {
+            mem += (src_rect->top / conv_format.block_height) * src_pitch;
+            mem += (src_rect->left / conv_format.block_width) * conv_format.block_byte_count;
+        }
+
+        if (srgb)
+            internal = conv_format.glGammaInternal;
+        else if (surface->resource.usage & WINED3DUSAGE_RENDERTARGET && surface_is_offscreen(surface))
+            internal = conv_format.rtInternal;
+        else
+            internal = conv_format.glInternal;
+
+        TRACE("glCompressedTexSubImage2DARB, target %#x, level %d, x %d, y %d, w %d, h %d, "
+                "format %#x, image_size %#x, addr %p.\n", surface->texture_target, surface->texture_level,
+                dst_point->x, dst_point->y, update_w, update_h, internal, row_count * row_length, mem);
+
+        if (row_length == src_pitch)
+        {
+            GL_EXTCALL(glCompressedTexSubImage2DARB(surface->texture_target, surface->texture_level,
+                    dst_point->x, dst_point->y, update_w, update_h, internal, row_count * row_length, mem));
+        }
+        else
+        {
+            UINT row, y;
+
+            /* glCompressedTexSubImage2DARB() ignores pixel store state, so we
+             * can't use the unpack row length like below. */
+            for (row = 0, y = dst_point->y; row < row_count; ++row)
+            {
+                GL_EXTCALL(glCompressedTexSubImage2DARB(surface->texture_target, surface->texture_level,
+                        dst_point->x, y, update_w, conv_format.block_height, internal, row_length, mem));
+                y += conv_format.block_height;
+                mem += src_pitch;
+            }
+        }
+        checkGLcall("glCompressedTexSubImage2DARB");
+    }
+    else
+    {
+        if (adjust_initial_offset)
+        {
+            mem += src_rect->top * src_pitch;
+            mem += src_rect->left * conv_format.byte_count;
+        }
+
+        TRACE("glTexSubImage2D, target %#x, level %d, x %d, y %d, w %d, h %d, format %#x, type %#x, addr %p.\n",
+                surface->texture_target, surface->texture_level, dst_point->x, dst_point->y,
+                update_w, update_h, conv_format.glFormat, conv_format.glType, mem);
+
+        gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_ROW_LENGTH, src_pitch / conv_format.byte_count);
+        gl_info->gl_ops.gl.p_glTexSubImage2D(surface->texture_target, surface->texture_level,
+                dst_point->x, dst_point->y, update_w, update_h, conv_format.glFormat, conv_format.glType, mem);
+        gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+        checkGLcall("glTexSubImage2D");
+    }
+
+    if (data->buffer_object)
+    {
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+        checkGLcall("glBindBufferARB");
+    }
+
+    if (wined3d_settings.strict_draw_ordering)
+        gl_info->gl_ops.gl.p_glFlush();
+
+    if (gl_info->quirks & WINED3D_QUIRK_FBO_TEX_UPDATE)
+    {
+        struct wined3d_device *device = surface->resource.device;
+        unsigned int i;
+
+        for (i = 0; i < device->context_count; ++i)
+        {
+            context_surface_update(device->contexts[i], surface);
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, conv_dst);
+    return TRUE;
+}
+
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
+{
+    struct wined3d_box box;
+
+    if (!rect)
+        return wined3d_resource_check_block_align(&surface->resource, NULL);
+
+    box.left = rect->left;
+    box.top = rect->top;
+    box.front = 0;
+    box.right = rect->right;
+    box.bottom = rect->bottom;
+    box.back = 1;
+    return wined3d_resource_check_block_align(&surface->resource, &box);
+}
+
+HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
+        struct wined3d_surface *src_surface, const RECT *src_rect)
+{
+    const struct wined3d_format *src_format;
+    const struct wined3d_format *dst_format;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_bo_address data;
+    UINT update_w, update_h;
+    UINT dst_w, dst_h;
+    RECT r, dst_rect;
+    UINT src_row_pitch, src_slice_pitch;
+    POINT p;
+
+    TRACE("dst_surface %p, dst_point %s, src_surface %p, src_rect %s.\n",
+            dst_surface, wine_dbgstr_point(dst_point),
+            src_surface, wine_dbgstr_rect(src_rect));
+
+    src_format = src_surface->resource.format;
+    dst_format = dst_surface->resource.format;
+
+    if (src_format->id != dst_format->id)
+    {
+        WARN("Source and destination surfaces should have the same format.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!dst_point)
+    {
+        p.x = 0;
+        p.y = 0;
+        dst_point = &p;
+    }
+    else if (dst_point->x < 0 || dst_point->y < 0)
+    {
+        WARN("Invalid destination point.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!src_rect)
+    {
+        r.left = 0;
+        r.top = 0;
+        r.right = src_surface->resource.width;
+        r.bottom = src_surface->resource.height;
+        src_rect = &r;
+    }
+    else if (src_rect->left < 0 || src_rect->left >= src_rect->right
+            || src_rect->top < 0 || src_rect->top >= src_rect->bottom)
+    {
+        WARN("Invalid source rectangle.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    dst_w = dst_surface->resource.width;
+    dst_h = dst_surface->resource.height;
+
+    update_w = src_rect->right - src_rect->left;
+    update_h = src_rect->bottom - src_rect->top;
+
+    if (update_w > dst_w || dst_point->x > dst_w - update_w
+            || update_h > dst_h || dst_point->y > dst_h - update_h)
+    {
+        WARN("Destination out of bounds.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if ((src_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(src_surface, src_rect))
+    {
+        WARN("Source rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    SetRect(&dst_rect, dst_point->x, dst_point->y, dst_point->x + update_w, dst_point->y + update_h);
+    if ((dst_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(dst_surface, &dst_rect))
+    {
+        WARN("Destination rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    context = context_acquire(dst_surface->resource.device, NULL);
     gl_info = context->gl_info;
 
     /* Only load the surface for partial updates. For newly allocated texture
@@ -2237,21 +2168,20 @@
     if (update_w == dst_w && update_h == dst_h)
         surface_prepare_texture(dst_surface, context, FALSE);
     else
-        surface_load_location(dst_surface, SFLAG_INTEXTURE, NULL);
+        wined3d_resource_load_location(&dst_surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     surface_bind(dst_surface, context, FALSE);
 
-    data.buffer_object = src_surface->pbo;
-    data.addr = src_surface->resource.allocatedMemory;
-    src_pitch = wined3d_surface_get_pitch(src_surface);
+    wined3d_resource_get_memory(&src_surface->resource, src_surface->resource.locations, &data);
+    wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
 
-    surface_upload_data(dst_surface, gl_info, src_format, src_rect, src_pitch, dst_point, FALSE, &data);
+    surface_upload_data(dst_surface, gl_info, src_format, src_rect, src_row_pitch, dst_point, FALSE, &data);
 
     context_invalidate_active_texture(context);
 
     context_release(context);
 
-    surface_validate_location(dst_surface, SFLAG_INTEXTURE);
-    surface_invalidate_location(dst_surface, ~SFLAG_INTEXTURE);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 
     return WINED3D_OK;
 }
@@ -2262,6 +2192,7 @@
 static void surface_allocate_surface(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
         const struct wined3d_format *format, BOOL srgb)
 {
+    DWORD client_store_flag = srgb ? SFLAG_CLIENT : SFLAG_CLIENT_SRGB;
     BOOL disable_client_storage = FALSE;
     GLsizei width = surface->pow2Width;
     GLsizei height = surface->pow2Height;
@@ -2296,24 +2227,22 @@
 
     if (gl_info->supported[APPLE_CLIENT_STORAGE])
     {
-        if (surface->flags & (SFLAG_NONPOW2 | SFLAG_DIBSECTION | SFLAG_CONVERTED)
-                || !surface->resource.allocatedMemory)
+        /* CrossOver HACK: Do not enable client storage on compressed srgb
+         * surfaces, OS X doesn't like it. */
+        if (surface->flags & (SFLAG_NONPOW2 | SFLAG_CONVERTED)
+                || (format_is_srgb(internal) && (format->flags & WINED3DFMT_FLAG_COMPRESSED))
+                || !wined3d_resource_prepare_system_memory(&surface->resource))
         {
             /* In some cases we want to disable client storage.
              * SFLAG_NONPOW2 has a bigger opengl texture than the client memory, and different pitches
-             * SFLAG_DIBSECTION: Dibsections may have read / write protections on the memory. Avoid issues...
              * SFLAG_CONVERTED: The conversion destination memory is freed after loading the surface
-             * allocatedMemory == NULL: Not defined in the extension. Seems to disable client storage effectively
              */
             surface->flags &= ~SFLAG_CLIENT;
         }
         else
         {
-            surface->flags |= SFLAG_CLIENT;
+            surface->flags |= client_store_flag;
 
-            /* Point OpenGL to our allocated texture memory. Do not use
-             * resource.allocatedMemory here because it might point into a
-             * PBO. Instead use heap_memory. */
             mem = surface->resource.heap_memory;
 
             gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);
@@ -2444,30 +2373,47 @@
 /* Slightly inefficient way to handle multiple dirty rects but it works :) */
 void surface_add_dirty_rect(struct wined3d_surface *surface, const struct wined3d_box *dirty_rect)
 {
+    struct wined3d_device *device = surface->resource.device;
+    struct wined3d_context *context = NULL;
+    BOOL has_map_memory = FALSE;
     TRACE("surface %p, dirty_rect %p.\n", surface, dirty_rect);
 
-    if (!(surface->flags & SFLAG_INSYSMEM) && (surface->flags & SFLAG_INTEXTURE))
-        /* No partial locking for textures yet. */
-        surface_load_location(surface, SFLAG_INSYSMEM, NULL);
-
-    surface_validate_location(surface, SFLAG_INSYSMEM);
-    surface_invalidate_location(surface, ~SFLAG_INSYSMEM);
+    switch (surface->resource.map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            has_map_memory = !!surface->resource.buffer;
+            break;
+        case WINED3D_LOCATION_DIB:
+            has_map_memory = !!surface->resource.dib_memory;
+            break;
+        case WINED3D_LOCATION_SYSMEM:
+            has_map_memory = !!surface->resource.heap_memory;
+            break;
+        case WINED3D_LOCATION_USER:
+            has_map_memory = TRUE;
+    }
 
-    if (dirty_rect)
+    if (!has_map_memory)
     {
-        surface->dirtyRect.left = min(surface->dirtyRect.left, dirty_rect->left);
-        surface->dirtyRect.top = min(surface->dirtyRect.top, dirty_rect->top);
-        surface->dirtyRect.right = max(surface->dirtyRect.right, dirty_rect->right);
-        surface->dirtyRect.bottom = max(surface->dirtyRect.bottom, dirty_rect->bottom);
+        if (device->d3d_initialized)
+            context = context_acquire(device, NULL);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
     }
-    else
+
+    if (!(surface->resource.locations & surface->resource.map_binding)
+            && (surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB))
     {
-        surface->dirtyRect.left = 0;
-        surface->dirtyRect.top = 0;
-        surface->dirtyRect.right = surface->resource.width;
-        surface->dirtyRect.bottom = surface->resource.height;
+        if (!context && device->d3d_initialized)
+            context = context_acquire(device, NULL);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
     }
 
+    if (context)
+        context_release(context);
+
+    wined3d_resource_validate_location(&surface->resource, surface->resource.map_binding);
+    wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
+
     /* if the container is a texture then mark it dirty. */
     if (surface->container)
     {
@@ -2476,9 +2422,9 @@
     }
 }
 
-HRESULT surface_load(struct wined3d_surface *surface, BOOL srgb)
+HRESULT surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb)
 {
-    DWORD flag = srgb ? SFLAG_INSRGBTEX : SFLAG_INTEXTURE;
+    DWORD location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
     BOOL ck_changed;
 
     TRACE("surface %p, srgb %#x.\n", surface, srgb);
@@ -2501,13 +2447,13 @@
         /* To perform the color key conversion we need a sysmem copy of
          * the surface. Make sure we have it. */
 
-        surface_load_location(surface, SFLAG_INSYSMEM, NULL);
-        surface_invalidate_location(surface, ~SFLAG_INSYSMEM);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
         /* Switching color keying on / off may change the internal format. */
         if (ck_changed)
             surface_force_reload(surface);
     }
-    else if (!(surface->flags & flag))
+    else if (!(surface->resource.locations & location))
     {
         TRACE("Reloading because surface is dirty.\n");
     }
@@ -2517,8 +2463,7 @@
         return WINED3D_OK;
     }
 
-    /* No partial locking for textures yet. */
-    surface_load_location(surface, flag, NULL);
+    wined3d_resource_load_location(&surface->resource, context, location);
     surface_evict_sysmem(surface);
 
     return WINED3D_OK;
@@ -2624,11 +2569,8 @@
 
     if (!refcount)
     {
-        surface_cleanup(surface);
         surface->resource.parent_ops->wined3d_object_destroyed(surface->resource.parent);
-
-        TRACE("Destroyed surface %p.\n", surface);
-        HeapFree(GetProcessHeap(), 0, surface);
+        surface_cleanup(surface);
     }
 
     return refcount;
@@ -2646,18 +2588,16 @@
 
 void CDECL wined3d_surface_preload(struct wined3d_surface *surface)
 {
-    struct wined3d_context *context;
+    const struct wined3d_device *device = surface->resource.device;
     TRACE("surface %p.\n", surface);
 
-    if (!surface->resource.device->d3d_initialized)
+    if (!device->d3d_initialized)
     {
         ERR("D3D not initialized.\n");
         return;
     }
 
-    context = context_acquire(surface->resource.device, NULL);
-    surface_internal_preload(surface, context, SRGB_ANY);
-    context_release(context);
+    wined3d_cs_emit_surface_preload(device->cs, surface);
 }
 
 void * CDECL wined3d_surface_get_parent(const struct wined3d_surface *surface)
@@ -2732,6 +2672,14 @@
         return;
     }
 
+    if (wined3d_use_csmt(surface->resource.device))
+    {
+        struct wined3d_device *device = surface->resource.device;
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     if (surface->palette && (surface->resource.usage & WINED3DUSAGE_RENDERTARGET))
         surface->palette->flags &= ~WINEDDPCAPS_PRIMARYSURFACE;
 
@@ -2757,6 +2705,12 @@
         return WINED3DERR_INVALIDCALL;
     }
 
+    if (wined3d_use_csmt(surface->resource.device))
+    {
+        FIXME("waiting for cs\n");
+        surface->resource.device->cs->ops->finish(surface->resource.device->cs);
+    }
+
     /* Dirtify the surface, but only if a key was changed. */
     if (color_key)
     {
@@ -2815,35 +2769,6 @@
     return surface->palette;
 }
 
-DWORD CDECL wined3d_surface_get_pitch(const struct wined3d_surface *surface)
-{
-    const struct wined3d_format *format = surface->resource.format;
-    DWORD pitch;
-
-    TRACE("surface %p.\n", surface);
-
-    if (surface->pitch)
-        return surface->pitch;
-
-    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
-    {
-        /* Since compressed formats are block based, pitch means the amount of
-         * bytes to the next row of block rather than the next row of pixels. */
-        UINT row_block_count = (surface->resource.width + format->block_width - 1) / format->block_width;
-        pitch = row_block_count * format->block_byte_count;
-    }
-    else
-    {
-        unsigned char alignment = surface->resource.device->surface_alignment;
-        pitch = surface->resource.format->byte_count * surface->resource.width;  /* Bytes / row */
-        pitch = (pitch + alignment - 1) & ~(alignment - 1);
-    }
-
-    TRACE("Returning %u.\n", pitch);
-
-    return pitch;
-}
-
 HRESULT CDECL wined3d_surface_set_mem(struct wined3d_surface *surface, void *mem, UINT pitch)
 {
     TRACE("surface %p, mem %p.\n", surface, mem);
@@ -2860,56 +2785,50 @@
         ERR("Not supported on render targets.\n");
         return WINED3DERR_INVALIDCALL;
     }
+    /* Should not happen. This means ddraw/d3d9 created the surface incorrectly. */
+    if (surface->resource.pool != WINED3D_POOL_SYSTEM_MEM)
+        ERR("Called on non-sysmem surface.\n");
 
-    if (mem && mem != surface->resource.allocatedMemory)
+    if (mem && mem != surface->resource.user_memory)
     {
         /* Do I have to copy the old surface content? */
         if (surface->flags & SFLAG_DIBSECTION)
         {
             DeleteDC(surface->hDC);
             DeleteObject(surface->dib.DIBsection);
-            surface->dib.bitmap_data = NULL;
-            surface->resource.allocatedMemory = NULL;
+            surface->resource.dib_memory = NULL;
             surface->hDC = NULL;
             surface->flags &= ~SFLAG_DIBSECTION;
         }
         else if (!(surface->flags & SFLAG_USERPTR))
         {
             wined3d_resource_free_sysmem(&surface->resource);
+            surface->resource.map_heap_memory = NULL;
         }
-        surface->resource.allocatedMemory = mem;
+        surface->resource.user_memory = mem;
         surface->flags |= SFLAG_USERPTR;
+        surface->resource.map_binding = WINED3D_LOCATION_USER;
 
         /* Now the surface memory is most up do date. Invalidate drawable and texture. */
-        surface_validate_location(surface, SFLAG_INSYSMEM);
-        surface_invalidate_location(surface, ~SFLAG_INSYSMEM);
-
-        /* For client textures OpenGL has to be notified. */
-        if (surface->flags & SFLAG_CLIENT)
-            surface_release_client_storage(surface);
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_USER);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_USER);
     }
-    else if (surface->flags & SFLAG_USERPTR)
+    else if (!mem)
     {
         /* heap_memory should be NULL already. */
         if (surface->resource.heap_memory)
             ERR("User pointer surface has heap memory allocated.\n");
 
-        if (!mem)
-        {
-            surface->resource.allocatedMemory = NULL;
-            surface->flags &= ~(SFLAG_USERPTR | SFLAG_INSYSMEM);
-
-            if (surface->flags & SFLAG_CLIENT)
-                surface_release_client_storage(surface);
-
-            surface_prepare_system_memory(surface);
-        }
+        surface->resource.user_memory = NULL;
+        surface->flags &= ~SFLAG_USERPTR;
+        surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
-        surface_validate_location(surface, SFLAG_INSYSMEM);
-        surface_invalidate_location(surface, ~SFLAG_INSYSMEM);
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DISCARDED);
     }
 
-    surface->pitch = pitch;
+    surface->resource.custom_row_pitch = pitch;
+    surface->resource.custom_slice_pitch = pitch * surface->resource.height;
 
     return WINED3D_OK;
 }
@@ -2933,8 +2852,6 @@
     surface->overlay_destrect.right = x + w;
     surface->overlay_destrect.bottom = y + h;
 
-    surface_draw_overlay(surface);
-
     return WINED3D_OK;
 }
 
@@ -3043,8 +2960,6 @@
         surface->overlay_dest = NULL;
     }
 
-    surface_draw_overlay(surface);
-
     return WINED3D_OK;
 }
 
@@ -3064,19 +2979,23 @@
         return WINED3DERR_INVALIDCALL;
 
     if (device->d3d_initialized)
-        surface->resource.resource_ops->resource_unload(&surface->resource);
+    {
+        wined3d_cs_emit_evict_resource(device->cs, &surface->resource);
+        device->cs->ops->finish(device->cs);
+    }
 
     if (surface->flags & SFLAG_DIBSECTION)
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
-        surface->dib.bitmap_data = NULL;
+        surface->resource.dib_memory = NULL;
         surface->flags &= ~SFLAG_DIBSECTION;
     }
 
-    surface->flags &= ~(SFLAG_LOCATIONS | SFLAG_USERPTR);
-    surface->resource.allocatedMemory = NULL;
+    surface->flags &= ~SFLAG_USERPTR;
+    surface->resource.locations = 0;
     wined3d_resource_free_sysmem(&surface->resource);
+    surface->resource.map_heap_memory = NULL;
 
     surface->resource.width = width;
     surface->resource.height = height;
@@ -3105,8 +3024,14 @@
     surface->resource.multisample_quality = multisample_quality;
     surface->resource.size = resource_size;
 
-    if (!surface_init_sysmem(surface))
-        return E_OUTOFMEMORY;
+    wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+
+    if (device->d3d_initialized &&surface_use_pbo(surface))
+        surface->resource.map_binding = WINED3D_LOCATION_BUFFER;
+    else if (surface->flags & SFLAG_DIBSECTION)
+        surface->resource.map_binding = WINED3D_LOCATION_DIB;
+    else
+        surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
     return WINED3D_OK;
 }
@@ -3323,10 +3248,13 @@
  *****************************************************************************/
 static struct wined3d_surface *surface_convert_format(struct wined3d_surface *source, enum wined3d_format_id to_fmt)
 {
-    struct wined3d_map_desc src_map, dst_map;
+    void *dst_data = NULL, *src_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const struct d3dfmt_converter_desc *conv;
     struct wined3d_surface *ret = NULL;
     HRESULT hr;
+    struct wined3d_context *context = NULL;
+    struct wined3d_device *device = source->resource.device;
 
     conv = find_converter(source->resource.format->id, to_fmt);
     if (!conv)
@@ -3345,30 +3273,46 @@
         return NULL;
     }
 
-    memset(&src_map, 0, sizeof(src_map));
-    memset(&dst_map, 0, sizeof(dst_map));
+    wined3d_resource_get_pitch(&source->resource, &src_row_pitch, &src_slice_pitch);
+    wined3d_resource_get_pitch(&ret->resource, &dst_row_pitch, &dst_slice_pitch);
 
-    if (FAILED(hr = wined3d_surface_map(source, &src_map, NULL, WINED3D_MAP_READONLY)))
-    {
-        ERR("Failed to lock the source surface.\n");
-        wined3d_surface_decref(ret);
-        return NULL;
-    }
-    if (FAILED(hr = wined3d_surface_map(ret, &dst_map, NULL, WINED3D_MAP_READONLY)))
-    {
-        ERR("Failed to lock the destination surface.\n");
-        wined3d_surface_unmap(source);
-        wined3d_surface_decref(ret);
-        return NULL;
-    }
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
 
-    conv->convert(src_map.data, dst_map.data, src_map.row_pitch, dst_map.row_pitch,
+    wined3d_resource_load_location(&source->resource, context, source->resource.map_binding);
+    src_data = wined3d_resource_get_map_ptr(&source->resource, context, WINED3D_MAP_READONLY);
+    if (!src_data)
+        goto error;
+
+    if (!wined3d_resource_prepare_map_memory(&ret->resource, context))
+        goto error;
+    dst_data = wined3d_resource_get_map_ptr(&ret->resource, context, 0);
+    if (!dst_data)
+        goto error;
+
+    conv->convert(src_data, dst_data, src_row_pitch, dst_row_pitch,
             source->resource.width, source->resource.height);
 
-    wined3d_surface_unmap(ret);
-    wined3d_surface_unmap(source);
+    wined3d_resource_release_map_ptr(&ret->resource, context);
+    wined3d_resource_release_map_ptr(&source->resource, context);
+
+    if (context)
+        context_release(context);
 
     return ret;
+
+error:
+    ERR("Surface conversion failed.\n");
+
+    if (src_data)
+        wined3d_resource_release_map_ptr(&source->resource, context);
+    if (dst_data)
+        wined3d_resource_release_map_ptr(&ret->resource, context);
+    if (ret)
+        wined3d_surface_decref(ret);
+    if (context)
+        context_release(context);
+    return NULL;
 }
 
 static HRESULT _Blt_ColorFill(BYTE *buf, unsigned int width, unsigned int height,
@@ -3436,34 +3380,26 @@
 
 HRESULT CDECL wined3d_surface_unmap(struct wined3d_surface *surface)
 {
+    HRESULT hr;
+
     TRACE("surface %p.\n", surface);
 
-    if (!surface->resource.map_count)
-    {
-        WARN("Trying to unmap unmapped surface.\n");
-        return WINEDDERR_NOTLOCKED;
-    }
-    --surface->resource.map_count;
+    hr = wined3d_resource_unmap(&surface->resource);
+    if (FAILED(hr))
+        return hr;
 
-    surface->surface_ops->surface_unmap(surface);
+    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
 
-    return WINED3D_OK;
+    return hr;
 }
 
 HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
         struct wined3d_map_desc *map_desc, const RECT *rect, DWORD flags)
 {
+    struct wined3d_box box;
+    HRESULT hr;
     const struct wined3d_format *format = surface->resource.format;
 
-    TRACE("surface %p, map_desc %p, rect %s, flags %#x.\n",
-            surface, map_desc, wine_dbgstr_rect(rect), flags);
-
-    if (surface->resource.map_count)
-    {
-        WARN("Surface is already mapped.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
     if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && rect
             && !surface_check_block_align(surface, rect))
     {
@@ -3474,11 +3410,6 @@
             return WINED3DERR_INVALIDCALL;
     }
 
-    ++surface->resource.map_count;
-
-    if (!(surface->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
-        WARN("Trying to lock unlockable surface.\n");
-
     /* Performance optimization: Count how often a surface is mapped, if it is
      * mapped regularly do not throw away the system memory copy. This avoids
      * the need to download the surface from OpenGL all the time. The surface
@@ -3487,68 +3418,54 @@
     {
         if (++surface->lockCount > MAXLOCKCOUNT)
         {
-            TRACE("Surface is mapped regularly, not freeing the system memory copy any more.\n");
-            surface->flags |= SFLAG_DYNLOCK;
-        }
-    }
-
-    surface->surface_ops->surface_map(surface, rect, flags);
-
-    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
-        map_desc->row_pitch = surface->resource.width * format->byte_count;
-    else
-        map_desc->row_pitch = wined3d_surface_get_pitch(surface);
-    map_desc->slice_pitch = 0;
-
-    if (!rect)
-    {
-        map_desc->data = surface->resource.allocatedMemory;
-        surface->lockedRect.left = 0;
-        surface->lockedRect.top = 0;
-        surface->lockedRect.right = surface->resource.width;
-        surface->lockedRect.bottom = surface->resource.height;
-    }
-    else
-    {
-        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
-        {
-            /* Compressed textures are block based, so calculate the offset of
-             * the block that contains the top-left pixel of the locked rectangle. */
-            map_desc->data = surface->resource.allocatedMemory
-                    + ((rect->top / format->block_height) * map_desc->row_pitch)
-                    + ((rect->left / format->block_width) * format->block_byte_count);
+            TRACE("Surface is mapped regularly, not freeing the system memory copy any more.\n");
+            surface->flags |= SFLAG_DYNLOCK;
         }
-        else
-        {
-            map_desc->data = surface->resource.allocatedMemory
-                    + (map_desc->row_pitch * rect->top)
-                    + (rect->left * format->byte_count);
-        }
-        surface->lockedRect.left = rect->left;
-        surface->lockedRect.top = rect->top;
-        surface->lockedRect.right = rect->right;
-        surface->lockedRect.bottom = rect->bottom;
     }
 
-    TRACE("Locked rect %s.\n", wine_dbgstr_rect(&surface->lockedRect));
-    TRACE("Returning memory %p, pitch %u.\n", map_desc->data, map_desc->row_pitch);
+    if (rect)
+    {
+        box.left = rect->left;
+        box.top = rect->top;
+        box.front = 0;
+        box.right = rect->right;
+        box.bottom = rect->bottom;
+        box.back = 1;
+    }
 
-    return WINED3D_OK;
+    hr = wined3d_resource_map(&surface->resource, map_desc, rect ? &box : NULL, flags);
+    if (FAILED(hr))
+        return hr;
+
+    return hr;
 }
 
 HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
 {
-    struct wined3d_map_desc map;
-    HRESULT hr;
+    struct wined3d_device *device = surface->resource.device;
+    struct wined3d_context *context = NULL;
 
     TRACE("surface %p, dc %p.\n", surface, dc);
 
+    if (!(surface->resource.format->flags & WINED3DFMT_FLAG_GETDC))
+    {
+        WARN("Cannot use GetDC on a %s surface.\n", debug_d3dformat(surface->resource.format->id));
+        return WINED3DERR_INVALIDCALL;
+    }
+
     if (surface->flags & SFLAG_USERPTR)
     {
         ERR("Not supported on surfaces with application-provided memory.\n");
         return WINEDDERR_NODC;
     }
 
+    if (wined3d_use_csmt(device))
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     /* Give more detailed info for ddraw. */
     if (surface->flags & SFLAG_DCINUSE)
         return WINEDDERR_DCALREADYCREATED;
@@ -3560,38 +3477,22 @@
     /* Create a DIB section if there isn't a dc yet. */
     if (!surface->hDC)
     {
-        if (surface->flags & SFLAG_CLIENT)
-        {
-            surface_load_location(surface, SFLAG_INSYSMEM, NULL);
-            surface_release_client_storage(surface);
-        }
-        hr = surface_create_dib_section(surface);
-        if (FAILED(hr))
+        if (!wined3d_surface_prepare_dib(&surface->resource))
             return WINED3DERR_INVALIDCALL;
-
-        /* Use the DIB section from now on if we are not using a PBO. */
-        if (!(surface->flags & (SFLAG_PBO | SFLAG_PIN_SYSMEM)))
-        {
-            wined3d_resource_free_sysmem(&surface->resource);
-            surface->resource.allocatedMemory = surface->dib.bitmap_data;
-        }
+        if (!(surface->flags & SFLAG_PIN_SYSMEM)
+                && surface->resource.map_binding == WINED3D_LOCATION_SYSMEM)
+            surface->resource.map_binding = WINED3D_LOCATION_DIB;
     }
 
-    /* Map the surface. */
-    hr = wined3d_surface_map(surface, &map, NULL, 0);
-    if (FAILED(hr))
-    {
-        ERR("Map failed, hr %#x.\n", hr);
-        return hr;
-    }
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_DIB);
+    if (context)
+        context_release(context);
 
-    /* Sync the DIB with the PBO. This can't be done earlier because Map()
-     * activates the allocatedMemory. */
-    if (surface->flags & (SFLAG_PBO | SFLAG_PIN_SYSMEM))
-        memcpy(surface->dib.bitmap_data, surface->resource.allocatedMemory, surface->resource.size);
+    wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DIB);
 
-    if (surface->resource.format->id == WINED3DFMT_P8_UINT
-            || surface->resource.format->id == WINED3DFMT_P8_UINT_A8_UNORM)
+    if (surface->resource.format->flags & WINED3DFMT_FLAG_PALETTE)
     {
         /* GetDC on palettized formats is unsupported in D3D9, and the method
          * is missing in D3D8, so this should only be used for DX <=7
@@ -3628,6 +3529,7 @@
     }
 
     surface->flags |= SFLAG_DCINUSE;
+    surface->resource.map_count++;
 
     *dc = surface->hDC;
     TRACE("Returning dc %p.\n", *dc);
@@ -3649,13 +3551,7 @@
         return WINEDDERR_NODC;
     }
 
-    /* Copy the contents of the DIB over to the PBO. */
-    if ((surface->flags & (SFLAG_PBO | SFLAG_PIN_SYSMEM)) && surface->resource.allocatedMemory)
-        memcpy(surface->resource.allocatedMemory, surface->dib.bitmap_data, surface->resource.size);
-
-    /* We locked first, so unlock now. */
-    wined3d_surface_unmap(surface);
-
+    surface->resource.map_count--;
     surface->flags &= ~SFLAG_DCINUSE;
 
     return WINED3D_OK;
@@ -3663,6 +3559,8 @@
 
 HRESULT CDECL wined3d_surface_flip(struct wined3d_surface *surface, struct wined3d_surface *override, DWORD flags)
 {
+    struct wined3d_device *device = surface->resource.device;
+
     TRACE("surface %p, override %p, flags %#x.\n", surface, override, flags);
 
     if (flags)
@@ -3680,11 +3578,7 @@
         return WINEDDERR_NOTFLIPPABLE;
     }
 
-    flip_surface(surface, override);
-
-    /* Update overlays if they're visible. */
-    if ((surface->resource.usage & WINED3DUSAGE_OVERLAY) && surface->overlay_dest)
-        return surface_draw_overlay(surface);
+    wined3d_cs_emit_surface_flip(device->cs, surface, override);
 
     return WINED3D_OK;
 }
@@ -3706,7 +3600,7 @@
     {
         TRACE("(%p) : About to load surface\n", surface);
 
-        surface_load(surface, srgb == SRGB_SRGB);
+        surface_load(surface, context,srgb == SRGB_SRGB);
 
         if (surface->resource.pool == WINED3D_POOL_DEFAULT)
         {
@@ -3719,7 +3613,7 @@
 }
 
 /* Read the framebuffer back into the surface */
-static void read_from_framebuffer(struct wined3d_surface *surface, const RECT *rect, void *dest, UINT pitch)
+static void read_from_framebuffer(struct wined3d_surface *surface, struct wined3d_bo_address *data, UINT pitch)
 {
     struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info;
@@ -3730,11 +3624,11 @@
     BYTE *row, *top, *bottom;
     int i;
     BOOL bpp;
-    RECT local_rect;
     BOOL srcIsUpsideDown;
     GLint rowLen = 0;
     GLint skipPix = 0;
     GLint skipRow = 0;
+    BOOL bind_bo;
 
     context = context_acquire(device, surface);
     context_apply_blit_state(context, device);
@@ -3762,20 +3656,6 @@
         srcIsUpsideDown = FALSE;
     }
 
-    /* TODO: Get rid of the extra rectangle comparison and construction of a full surface rectangle */
-    if (!rect)
-    {
-        local_rect.left = 0;
-        local_rect.top = 0;
-        local_rect.right = surface->resource.width;
-        local_rect.bottom = surface->resource.height;
-    }
-    else
-    {
-        local_rect = *rect;
-    }
-    /* TODO: Get rid of the extra GetPitch call, LockRect does that too. Cache the pitch */
-
     switch (surface->resource.format->id)
     {
         case WINED3DFMT_P8_UINT:
@@ -3785,8 +3665,9 @@
                 /* In case of P8 render targets the index is stored in the alpha component */
                 fmt = GL_ALPHA;
                 type = GL_UNSIGNED_BYTE;
-                mem = dest;
+                mem = data->addr;
                 bpp = surface->resource.format->byte_count;
+                bind_bo = TRUE;
             }
             else
             {
@@ -3809,26 +3690,23 @@
                     return;
                 }
                 bpp = surface->resource.format->byte_count * 3;
+                bind_bo = FALSE;
             }
         }
         break;
 
         default:
-            mem = dest;
+            mem = data->addr;
             fmt = surface->resource.format->glFormat;
             type = surface->resource.format->glType;
             bpp = surface->resource.format->byte_count;
+            bind_bo = TRUE;
     }
 
-    if (surface->flags & SFLAG_PBO)
+    if (data->buffer_object && bind_bo)
     {
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, surface->pbo));
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, data->buffer_object));
         checkGLcall("glBindBufferARB");
-        if (mem)
-        {
-            ERR("mem not null for pbo -- unexpected\n");
-            mem = NULL;
-        }
     }
 
     /* Save old pixel store pack state */
@@ -3842,15 +3720,13 @@
     /* Setup pixel store pack state -- to glReadPixels into the correct place */
     gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, surface->resource.width);
     checkGLcall("glPixelStorei");
-    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, local_rect.left);
+    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
     checkGLcall("glPixelStorei");
-    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, local_rect.top);
+    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
     checkGLcall("glPixelStorei");
 
-    gl_info->gl_ops.gl.p_glReadPixels(local_rect.left,
-            !srcIsUpsideDown ? (surface->resource.height - local_rect.bottom) : local_rect.top,
-            local_rect.right - local_rect.left,
-            local_rect.bottom - local_rect.top,
+    gl_info->gl_ops.gl.p_glReadPixels(0, 0,
+            surface->resource.width, surface->resource.height,
             fmt, type, mem);
     checkGLcall("glReadPixels");
 
@@ -3862,32 +3738,23 @@
     gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, skipRow);
     checkGLcall("glPixelStorei");
 
-    if (surface->flags & SFLAG_PBO)
+    /* TODO: Merge this with the palettization loop below for P8 targets */
+    if(!srcIsUpsideDown)
     {
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
-        checkGLcall("glBindBufferARB");
+        UINT len;
 
-        /* Check if we need to flip the image. If we need to flip use glMapBufferARB
-         * to get a pointer to it and perform the flipping in software. This is a lot
-         * faster than calling glReadPixels for each line. In case we want more speed
-         * we should rerender it flipped in a FBO and read the data back from the FBO. */
-        if (!srcIsUpsideDown)
+        if (data->buffer_object)
         {
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-            checkGLcall("glBindBufferARB");
+            if (!bind_bo)
+                GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, data->buffer_object));
 
-            mem = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_READ_WRITE_ARB));
-            checkGLcall("glMapBufferARB");
+            mem = GL_EXTCALL(glMapBufferARB(GL_PIXEL_PACK_BUFFER_ARB, GL_READ_WRITE_ARB));
+            checkGLcall("Map PBO");
         }
-    }
 
-    /* TODO: Merge this with the palettization loop below for P8 targets */
-    if(!srcIsUpsideDown) {
-        UINT len, off;
         /* glReadPixels returns the image upside down, and there is no way to prevent this.
             Flip the lines in software */
-        len = (local_rect.right - local_rect.left) * bpp;
-        off = local_rect.left * bpp;
+        len = surface->resource.width * bpp;
 
         row = HeapAlloc(GetProcessHeap(), 0, len);
         if(!row) {
@@ -3897,25 +3764,30 @@
             return;
         }
 
-        top = mem + pitch * local_rect.top;
-        bottom = mem + pitch * (local_rect.bottom - 1);
-        for(i = 0; i < (local_rect.bottom - local_rect.top) / 2; i++) {
-            memcpy(row, top + off, len);
-            memcpy(top + off, bottom + off, len);
-            memcpy(bottom + off, row, len);
+        top = mem;
+        bottom = mem + pitch * (surface->resource.height - 1);
+        for(i = 0; i < surface->resource.height / 2; i++) {
+            memcpy(row, top, len);
+            memcpy(top, bottom, len);
+            memcpy(bottom, row, len);
             top += pitch;
             bottom -= pitch;
         }
         HeapFree(GetProcessHeap(), 0, row);
 
-        /* Unmap the temp PBO buffer */
-        if (surface->flags & SFLAG_PBO)
+        if (data->buffer_object)
         {
-            GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+            GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_PACK_BUFFER_ARB));
+            checkGLcall("Unmap PBO");
         }
     }
 
+    if (data->buffer_object)
+    {
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
+        checkGLcall("glBindBufferARB");
+    }
+
     /* For P8 textures we need to perform an inverse palette lookup. This is
      * done by searching for a palette index which matches the RGB value.
      * Note this isn't guaranteed to work when there are multiple entries for
@@ -3927,6 +3799,9 @@
         DWORD width = pitch / 3;
         int x, y, c;
 
+        if (data->buffer_object)
+            ERR("P8 repacking with a PBO.\n");
+
         if (surface->palette)
         {
             pal = surface->palette->palents;
@@ -3938,8 +3813,8 @@
             return;
         }
 
-        for(y = local_rect.top; y < local_rect.bottom; y++) {
-            for(x = local_rect.left; x < local_rect.right; x++) {
+        for(y = 0; y < surface->resource.height; y++) {
+            for(x = 0; x < surface->resource.width; x++) {
                 /*                      start              lines            pixels      */
                 const BYTE *blue = mem + y * pitch + x * (sizeof(BYTE) * 3);
                 const BYTE *green = blue  + 1;
@@ -3950,7 +3825,7 @@
                        *green == pal[c].peGreen &&
                        *blue  == pal[c].peBlue)
                     {
-                        *((BYTE *) dest + y * width + x) = c;
+                        *((BYTE *) data->addr + y * width + x) = c;
                         break;
                     }
                 }
@@ -4003,7 +3878,7 @@
 
     if (surface->flags & alloc_flag) return;
 
-    d3dfmt_get_conv(surface, TRUE, TRUE, &format, &convert);
+    d3dfmt_get_conv(surface, TRUE, TRUE, &format, surface->resource.format, &convert);
     if (convert != WINED3D_CT_NONE || format.convert)
         surface->flags |= SFLAG_CONVERTED;
     else surface->flags &= ~SFLAG_CONVERTED;
@@ -4062,14 +3937,6 @@
     }
 }
 
-static BOOL color_in_range(const struct wined3d_color_key *color_key, DWORD color)
-{
-    /* FIXME: Is this really how color keys are supposed to work? I think it
-     * makes more sense to compare the individual channels. */
-    return color >= color_key->color_space_low_value
-            && color <= color_key->color_space_high_value;
-}
-
 void d3dfmt_p8_init_palette(const struct wined3d_surface *surface, BYTE table[256][4], BOOL colorkey)
 {
     const struct wined3d_device *device = surface->resource.device;
@@ -4088,205 +3955,41 @@
     {
         FIXME("No palette set.\n");
         if (index_in_alpha)
-        {
-            /* Guarantees that memory representation remains correct after sysmem<->texture transfers even if
-             * there's no palette at this time. */
-            for (i = 0; i < 256; i++) table[i][3] = i;
-        }
-    }
-    else
-    {
-        TRACE("Using surface palette %p\n", pal);
-        /* Get the surface's palette */
-        for (i = 0; i < 256; ++i)
-        {
-            table[i][0] = pal->palents[i].peRed;
-            table[i][1] = pal->palents[i].peGreen;
-            table[i][2] = pal->palents[i].peBlue;
-
-            /* When index_in_alpha is set the palette index is stored in the
-             * alpha component. In case of a readback we can then read
-             * GL_ALPHA. Color keying is handled in surface_blt_special() using a
-             * GL_ALPHA_TEST using GL_NOT_EQUAL. In case of index_in_alpha the
-             * color key itself is passed to glAlphaFunc in other cases the
-             * alpha component of pixels that should be masked away is set to 0. */
-            if (index_in_alpha)
-                table[i][3] = i;
-            else if (colorkey && color_in_range(&surface->src_blt_color_key, i))
-                table[i][3] = 0x00;
-            else if (pal->flags & WINEDDPCAPS_ALPHA)
-                table[i][3] = pal->palents[i].peFlags;
-            else
-                table[i][3] = 0xff;
-        }
-    }
-}
-
-static HRESULT d3dfmt_convert_surface(const BYTE *src, BYTE *dst, UINT pitch, UINT width, UINT height,
-        UINT outpitch, enum wined3d_conversion_type conversion_type, struct wined3d_surface *surface)
-{
-    const BYTE *source;
-    BYTE *dest;
-
-    TRACE("src %p, dst %p, pitch %u, width %u, height %u, outpitch %u, conversion_type %#x, surface %p.\n",
-            src, dst, pitch, width, height, outpitch, conversion_type, surface);
-
-    switch (conversion_type)
-    {
-        case WINED3D_CT_NONE:
-        {
-            memcpy(dst, src, pitch * height);
-            break;
-        }
-
-        case WINED3D_CT_PALETTED:
-        case WINED3D_CT_PALETTED_CK:
-        {
-            BYTE table[256][4];
-            unsigned int x, y;
-
-            d3dfmt_p8_init_palette(surface, table, (conversion_type == WINED3D_CT_PALETTED_CK));
-
-            for (y = 0; y < height; y++)
-            {
-                source = src + pitch * y;
-                dest = dst + outpitch * y;
-                /* This is an 1 bpp format, using the width here is fine */
-                for (x = 0; x < width; x++) {
-                    BYTE color = *source++;
-                    *dest++ = table[color][0];
-                    *dest++ = table[color][1];
-                    *dest++ = table[color][2];
-                    *dest++ = table[color][3];
-                }
-            }
-        }
-        break;
-
-        case WINED3D_CT_CK_565:
-        {
-            /* Converting the 565 format in 5551 packed to emulate color-keying.
-
-              Note : in all these conversion, it would be best to average the averaging
-                      pixels to get the color of the pixel that will be color-keyed to
-                      prevent 'color bleeding'. This will be done later on if ever it is
-                      too visible.
-
-              Note2: Nvidia documents say that their driver does not support alpha + color keying
-                     on the same surface and disables color keying in such a case
-            */
-            unsigned int x, y;
-            const WORD *Source;
-            WORD *Dest;
-
-            TRACE("Color keyed 565\n");
-
-            for (y = 0; y < height; y++) {
-                Source = (const WORD *)(src + y * pitch);
-                Dest = (WORD *) (dst + y * outpitch);
-                for (x = 0; x < width; x++ ) {
-                    WORD color = *Source++;
-                    *Dest = ((color & 0xffc0) | ((color & 0x1f) << 1));
-                    if (!color_in_range(&surface->src_blt_color_key, color))
-                        *Dest |= 0x0001;
-                    Dest++;
-                }
-            }
-        }
-        break;
-
-        case WINED3D_CT_CK_5551:
-        {
-            /* Converting X1R5G5B5 format to R5G5B5A1 to emulate color-keying. */
-            unsigned int x, y;
-            const WORD *Source;
-            WORD *Dest;
-            TRACE("Color keyed 5551\n");
-            for (y = 0; y < height; y++) {
-                Source = (const WORD *)(src + y * pitch);
-                Dest = (WORD *) (dst + y * outpitch);
-                for (x = 0; x < width; x++ ) {
-                    WORD color = *Source++;
-                    *Dest = color;
-                    if (!color_in_range(&surface->src_blt_color_key, color))
-                        *Dest |= (1 << 15);
-                    else
-                        *Dest &= ~(1 << 15);
-                    Dest++;
-                }
-            }
-        }
-        break;
-
-        case WINED3D_CT_CK_RGB24:
-        {
-            /* Converting R8G8B8 format to R8G8B8A8 with color-keying. */
-            unsigned int x, y;
-            for (y = 0; y < height; y++)
-            {
-                source = src + pitch * y;
-                dest = dst + outpitch * y;
-                for (x = 0; x < width; x++) {
-                    DWORD color = ((DWORD)source[0] << 16) + ((DWORD)source[1] << 8) + (DWORD)source[2] ;
-                    DWORD dstcolor = color << 8;
-                    if (!color_in_range(&surface->src_blt_color_key, color))
-                        dstcolor |= 0xff;
-                    *(DWORD*)dest = dstcolor;
-                    source += 3;
-                    dest += 4;
-                }
-            }
-        }
-        break;
-
-        case WINED3D_CT_RGB32_888:
-        {
-            /* Converting X8R8G8B8 format to R8G8B8A8 with color-keying. */
-            unsigned int x, y;
-            for (y = 0; y < height; y++)
-            {
-                source = src + pitch * y;
-                dest = dst + outpitch * y;
-                for (x = 0; x < width; x++) {
-                    DWORD color = 0xffffff & *(const DWORD*)source;
-                    DWORD dstcolor = color << 8;
-                    if (!color_in_range(&surface->src_blt_color_key, color))
-                        dstcolor |= 0xff;
-                    *(DWORD*)dest = dstcolor;
-                    source += 4;
-                    dest += 4;
-                }
-            }
-        }
-        break;
-
-        case WINED3D_CT_CK_ARGB32:
-        {
-            unsigned int x, y;
-            for (y = 0; y < height; ++y)
-            {
-                source = src + pitch * y;
-                dest = dst + outpitch * y;
-                for (x = 0; x < width; ++x)
-                {
-                    DWORD color = *(const DWORD *)source;
-                    if (color_in_range(&surface->src_blt_color_key, color))
-                        color &= ~0xff000000;
-                    *(DWORD*)dest = color;
-                    source += 4;
-                    dest += 4;
-                }
-            }
+        {
+            /* Guarantees that memory representation remains correct after sysmem<->texture transfers even if
+             * there's no palette at this time. */
+            for (i = 0; i < 256; i++) table[i][3] = i;
         }
-        break;
+    }
+    else
+    {
+        TRACE("Using surface palette %p\n", pal);
+        /* Get the surface's palette */
+        for (i = 0; i < 256; ++i)
+        {
+            table[i][0] = pal->palents[i].peRed;
+            table[i][1] = pal->palents[i].peGreen;
+            table[i][2] = pal->palents[i].peBlue;
 
-        default:
-            ERR("Unsupported conversion type %#x.\n", conversion_type);
+            /* When index_in_alpha is set the palette index is stored in the
+             * alpha component. In case of a readback we can then read
+             * GL_ALPHA. Color keying is handled in surface_blt_special() using a
+             * GL_ALPHA_TEST using GL_NOT_EQUAL. In case of index_in_alpha the
+             * color key itself is passed to glAlphaFunc in other cases the
+             * alpha component of pixels that should be masked away is set to 0. */
+            if (index_in_alpha)
+                table[i][3] = i;
+            else if (colorkey && color_in_range(&surface->src_blt_color_key, i))
+                table[i][3] = 0x00;
+            else if (pal->flags & WINEDDPCAPS_ALPHA)
+                table[i][3] = pal->palents[i].peFlags;
+            else
+                table[i][3] = 0xff;
+        }
     }
-    return WINED3D_OK;
 }
 
-void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back)
+void surface_flip(struct wined3d_surface *front, struct wined3d_surface *back)
 {
     /* Flip the surface contents */
     /* Flip the DC */
@@ -4306,26 +4009,19 @@
 
     /* Flip the surface data */
     {
-        void* tmp;
+        void *tmp;
 
-        tmp = front->dib.bitmap_data;
-        front->dib.bitmap_data = back->dib.bitmap_data;
-        back->dib.bitmap_data = tmp;
-
-        tmp = front->resource.allocatedMemory;
-        front->resource.allocatedMemory = back->resource.allocatedMemory;
-        back->resource.allocatedMemory = tmp;
+        tmp = front->resource.dib_memory;
+        front->resource.dib_memory = back->resource.dib_memory;
+        back->resource.dib_memory = tmp;
 
         tmp = front->resource.heap_memory;
         front->resource.heap_memory = back->resource.heap_memory;
         back->resource.heap_memory = tmp;
-    }
 
-    /* Flip the PBO */
-    {
-        GLuint tmp_pbo = front->pbo;
-        front->pbo = back->pbo;
-        back->pbo = tmp_pbo;
+        tmp = front->resource.map_heap_memory;
+        front->resource.map_heap_memory = back->resource.map_heap_memory;
+        back->resource.map_heap_memory = tmp;
     }
 
     /* Flip the opengl texture */
@@ -4356,6 +4052,10 @@
         DWORD tmp_flags = back->flags;
         back->flags = front->flags;
         front->flags = tmp_flags;
+
+        tmp_flags = back->resource.locations;
+        back->resource.locations = front->resource.locations;
+        front->resource.locations = tmp_flags;
     }
 }
 
@@ -4450,6 +4150,12 @@
                  */
                 LONG col;
 
+                if (!cxgames_hacks.enable_slow_blit)
+                {
+                    ERR("Slow pixel per pixel copy disabled, aborting.\n");
+                    break;
+                }
+
                 for (col = dst_rect.left; col < dst_rect.right; ++col)
                 {
                     gl_info->gl_ops.gl.p_glCopyTexSubImage2D(dst_surface->texture_target, dst_surface->texture_level,
@@ -4471,8 +4177,8 @@
 
     /* The texture is now most up to date - If the surface is a render target
      * and has a drawable, this path is never entered. */
-    surface_validate_location(dst_surface, SFLAG_INTEXTURE);
-    surface_invalidate_location(dst_surface, ~SFLAG_INTEXTURE);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 }
 
 /* Uses the hardware to stretch and flip the image */
@@ -4540,7 +4246,7 @@
         checkGLcall("glEnable(texture_target)");
 
         /* For now invalidate the texture copy of the back buffer. Drawable and sysmem copy are untouched */
-        src_surface->flags &= ~SFLAG_INTEXTURE;
+        wined3d_resource_invalidate_location(&src_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
     }
 
     /* Make sure that the top pixel is always above the bottom pixel, and keep a separate upside down flag
@@ -4737,15 +4443,17 @@
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
-    if (wined3d_settings.strict_draw_ordering)
+    if (wined3d_use_csmt(device))
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering)
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
 
     /* The texture is now most up to date - If the surface is a render target
      * and has a drawable, this path is never entered. */
-    surface_validate_location(dst_surface, SFLAG_INTEXTURE);
-    surface_invalidate_location(dst_surface, ~SFLAG_INTEXTURE);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 }
 
 /* Front buffer coordinates are always full screen coordinates, but our GL
@@ -4837,7 +4545,9 @@
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
+    if (wined3d_use_csmt(device))
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
             || (dst_surface->swapchain && dst_surface->swapchain->front_buffer == dst_surface))
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
@@ -4867,6 +4577,7 @@
     struct wined3d_device *device = dst_surface->resource.device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+    const struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, blt_fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
@@ -4898,8 +4609,8 @@
 
     /* Early sort out of cases where no render target is used */
     if (!dst_swapchain && !src_swapchain
-            && src_surface != device->fb.render_targets[0]
-            && dst_surface != device->fb.render_targets[0])
+            && src_surface != fb->render_targets[0]
+            && dst_surface != fb->render_targets[0])
     {
         TRACE("No surface is render target, not using hardware blit.\n");
         return WINED3DERR_INVALIDCALL;
@@ -4928,23 +4639,22 @@
     if (dst_swapchain)
     {
         /* Handled with regular texture -> swapchain blit */
-        if (src_surface == device->fb.render_targets[0])
+        if (src_surface == fb->render_targets[0])
             TRACE("Blit from active render target to a swapchain\n");
     }
-    else if (src_swapchain && dst_surface == device->fb.render_targets[0])
+    else if (src_swapchain && dst_surface == fb->render_targets[0])
     {
         FIXME("Implement blit from a swapchain to the active render target\n");
         return WINED3DERR_INVALIDCALL;
     }
 
-    if ((src_swapchain || src_surface == device->fb.render_targets[0]) && !dst_swapchain)
+    if ((src_swapchain || src_surface == fb->render_targets[0]) && !dst_swapchain)
     {
         /* Blit from render target to texture */
         BOOL stretchx;
 
         /* P8 read back is not implemented */
-        if (src_surface->resource.format->id == WINED3DFMT_P8_UINT
-                || dst_surface->resource.format->id == WINED3DFMT_P8_UINT)
+        if (src_surface->resource.format->flags & WINED3DFMT_FLAG_PALETTE)
         {
             TRACE("P8 read back not supported by frame buffer to texture blit\n");
             return WINED3DERR_INVALIDCALL;
@@ -5034,8 +4744,8 @@
         src_surface->CKeyFlags = oldCKeyFlags;
         src_surface->src_blt_color_key = old_blt_key;
 
-        surface_validate_location(dst_surface, dst_surface->draw_binding);
-        surface_invalidate_location(dst_surface, ~dst_surface->draw_binding);
+        wined3d_resource_validate_location(&dst_surface->resource, dst_surface->draw_binding);
+        wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->draw_binding);
 
         return WINED3D_OK;
     }
@@ -5110,11 +4820,10 @@
 {
     TRACE("surface %p, new location %#x, w %u, h %u.\n", surface, location, w, h);
 
-    if (location & ~(SFLAG_LOCATIONS | SFLAG_DISCARDED))
-        FIXME("Invalid location (%#x) specified.\n", location);
-
-    if (((surface->flags & SFLAG_INTEXTURE) && !(location & SFLAG_INTEXTURE))
-            || (!(surface->flags & SFLAG_INTEXTURE) && (location & SFLAG_INTEXTURE)))
+    if (((surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+            && !(location & WINED3D_LOCATION_TEXTURE_RGB))
+            || (!(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+            && (location & WINED3D_LOCATION_TEXTURE_RGB)))
     {
         if (surface->container)
         {
@@ -5125,8 +4834,7 @@
 
     surface->ds_current_size.cx = w;
     surface->ds_current_size.cy = h;
-    surface->flags &= ~(SFLAG_LOCATIONS | SFLAG_DISCARDED);
-    surface->flags |= location;
+    surface->resource.locations = location;
 }
 
 /* Context activation is done by the caller. */
@@ -5141,7 +4849,7 @@
     /* TODO: Make this work for modes other than FBO */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO) return;
 
-    if (!(surface->flags & location))
+    if (!(surface->resource.locations & location))
     {
         w = surface->ds_current_size.cx;
         h = surface->ds_current_size.cy;
@@ -5167,40 +4875,40 @@
         return;
     }
 
-    if (surface->flags & SFLAG_DISCARDED)
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
     {
         TRACE("Surface was discarded, no need copy data.\n");
         switch (location)
         {
-            case SFLAG_INTEXTURE:
+            case WINED3D_LOCATION_TEXTURE_RGB:
                 surface_prepare_texture(surface, context, FALSE);
                 break;
-            case SFLAG_INRB_MULTISAMPLE:
+            case WINED3D_LOCATION_RB_MULTISAMPLE:
                 surface_prepare_rb(surface, gl_info, TRUE);
                 break;
-            case SFLAG_INDRAWABLE:
+            case WINED3D_LOCATION_DRAWABLE:
                 /* Nothing to do */
                 break;
             default:
                 FIXME("Unhandled location %#x\n", location);
         }
-        surface->flags &= ~SFLAG_DISCARDED;
-        surface->flags |= location;
+        surface->resource.locations &= ~WINED3D_LOCATION_DISCARDED;
+        surface->resource.locations |= location;
         surface->ds_current_size.cx = surface->resource.width;
         surface->ds_current_size.cy = surface->resource.height;
         return;
     }
 
-    if (!(surface->flags & SFLAG_LOCATIONS))
+    if (!surface->resource.locations)
     {
         FIXME("No up to date depth stencil location.\n");
-        surface->flags |= location;
+        surface->resource.locations |= location;
         surface->ds_current_size.cx = surface->resource.width;
         surface->ds_current_size.cy = surface->resource.height;
         return;
     }
 
-    if (location == SFLAG_INTEXTURE)
+    if (location == WINED3D_LOCATION_TEXTURE_RGB)
     {
         GLint old_binding = 0;
         GLenum bind_target;
@@ -5220,7 +4928,7 @@
         /* Note that we use depth_blt here as well, rather than glCopyTexImage2D
          * directly on the FBO texture. That's because we need to flip. */
         context_apply_fbo_state_blit(context, GL_FRAMEBUFFER,
-                context->swapchain->front_buffer, NULL, SFLAG_INDRAWABLE);
+                context->swapchain->front_buffer, NULL, WINED3D_LOCATION_DRAWABLE);
         if (surface->texture_target == GL_TEXTURE_RECTANGLE_ARB)
         {
             gl_info->gl_ops.gl.p_glGetIntegerv(GL_TEXTURE_BINDING_RECTANGLE_ARB, &old_binding);
@@ -5249,7 +4957,7 @@
         gl_info->gl_ops.gl.p_glBindTexture(bind_target, old_binding);
 
         context_apply_fbo_state_blit(context, GL_FRAMEBUFFER,
-                NULL, surface, SFLAG_INTEXTURE);
+                NULL, surface, WINED3D_LOCATION_TEXTURE_RGB);
         context_set_draw_buffer(context, GL_NONE);
 
         /* Do the actual blit */
@@ -5258,22 +4966,26 @@
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_use_csmt(device))
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
-    else if (location == SFLAG_INDRAWABLE)
+    else if (location == WINED3D_LOCATION_DRAWABLE)
     {
         TRACE("Copying depth texture to onscreen depth buffer.\n");
 
         context_apply_fbo_state_blit(context, GL_FRAMEBUFFER,
-                context->swapchain->front_buffer, NULL, SFLAG_INDRAWABLE);
+                context->swapchain->front_buffer, NULL, WINED3D_LOCATION_DRAWABLE);
         surface_depth_blt(surface, context, surface->texture_name,
                 0, surface->pow2Height - h, w, h, surface->texture_target);
         checkGLcall("depth_blt");
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_use_csmt(device))
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -5281,110 +4993,63 @@
         ERR("Invalid location (%#x) specified.\n", location);
     }
 
-    surface->flags |= location;
+    surface->resource.locations |= location;
     surface->ds_current_size.cx = surface->resource.width;
     surface->ds_current_size.cy = surface->resource.height;
 }
 
-void surface_validate_location(struct wined3d_surface *surface, DWORD location)
-{
-    struct wined3d_surface *overlay;
-
-    TRACE("surface %p, location %s.\n", surface, debug_surflocation(location & SFLAG_LOCATIONS));
-
-    surface->flags |= (location & SFLAG_LOCATIONS);
-
-    /* Redraw emulated overlays, if any. */
-    if (location & SFLAG_INDRAWABLE && !list_empty(&surface->overlays))
-    {
-        LIST_FOR_EACH_ENTRY(overlay, &surface->overlays, struct wined3d_surface, overlay_entry)
-        {
-            surface_draw_overlay(overlay);
-        }
-    }
-}
-
-void surface_invalidate_location(struct wined3d_surface *surface, DWORD location)
-{
-    TRACE("surface %p, location %s.\n", surface, debug_surflocation(location & SFLAG_LOCATIONS));
-
-    if ((location & (SFLAG_INTEXTURE | SFLAG_INSRGBTEX)) && surface->container)
-        wined3d_texture_set_dirty(surface->container);
-    surface->flags &= ~(location & SFLAG_LOCATIONS);
-
-    if (!(surface->flags & SFLAG_LOCATIONS))
-        ERR("Surface %p does not have any up to date location.\n", surface);
-}
-
-static DWORD resource_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case SFLAG_INSYSMEM:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case SFLAG_INDRAWABLE:
-        case SFLAG_INSRGBTEX:
-        case SFLAG_INTEXTURE:
-        case SFLAG_INRB_MULTISAMPLE:
-        case SFLAG_INRB_RESOLVED:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
-}
-
 static void surface_load_sysmem(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info, const RECT *rect)
+        struct wined3d_context *context, DWORD dst_location)
 {
-    surface_prepare_system_memory(surface);
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    struct wined3d_bo_address dst;
 
-    if (surface->flags & (SFLAG_INRB_MULTISAMPLE | SFLAG_INRB_RESOLVED))
-        surface_load_location(surface, SFLAG_INTEXTURE, NULL);
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+    wined3d_resource_get_memory(&surface->resource, dst_location, &dst);
 
     /* Download the surface to system memory. */
-    if (surface->flags & (SFLAG_INTEXTURE | SFLAG_INSRGBTEX))
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
     {
-        struct wined3d_device *device = surface->resource.device;
-        struct wined3d_context *context;
-
-        /* TODO: Use already acquired context when possible. */
-        context = context_acquire(device, NULL);
-
-        surface_bind_and_dirtify(surface, context, !(surface->flags & SFLAG_INTEXTURE));
-        surface_download_data(surface, gl_info);
-
-        context_release(context);
-
+        surface_bind_and_dirtify(surface, context, !(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB));
+        surface_download_data(surface, gl_info, &dst);
         return;
     }
 
-    if (surface->flags & SFLAG_INDRAWABLE)
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
     {
-        read_from_framebuffer(surface, rect, surface->resource.allocatedMemory,
-                wined3d_surface_get_pitch(surface));
+        UINT row_pitch, slice_pitch;
+        wined3d_resource_get_pitch(&surface->resource, &row_pitch, &slice_pitch);
+
+        read_from_framebuffer(surface, &dst, row_pitch);
+
         return;
     }
 
-    FIXME("Can't load surface %p with location flags %#x into sysmem.\n",
-            surface, surface->flags & SFLAG_LOCATIONS);
+    FIXME("Can't load surface %p with location flags %s into sysmem.\n",
+            surface, wined3d_debug_location(surface->resource.locations));
 }
 
 static HRESULT surface_load_drawable(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info, const RECT *rect)
+        struct wined3d_context *context)
 {
     RECT r;
 
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        return WINED3D_OK;
+    }
+
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO && surface_is_offscreen(surface))
     {
-        ERR("Trying to load offscreen surface into SFLAG_INDRAWABLE.\n");
+        ERR("Trying to load offscreen surface into WINED3D_LOCATION_DRAWABLE.\n");
         return WINED3DERR_INVALIDCALL;
     }
 
-    surface_get_rect(surface, rect, &r);
-    surface_load_location(surface, SFLAG_INTEXTURE, NULL);
+    surface_get_rect(surface, NULL, &r);
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     surface_blt_to_drawable(surface->resource.device,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
 
@@ -5392,51 +5057,58 @@
 }
 
 static HRESULT surface_load_texture(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info, const RECT *rect, BOOL srgb)
+        struct wined3d_context *context, BOOL srgb)
 {
     RECT src_rect = {0, 0, surface->resource.width, surface->resource.height};
     struct wined3d_device *device = surface->resource.device;
-    enum wined3d_conversion_type convert;
-    struct wined3d_context *context;
-    UINT width, src_pitch, dst_pitch;
+    UINT src_row_pitch, src_slice_pitch;
     struct wined3d_bo_address data;
-    struct wined3d_format format;
     POINT dst_point = {0, 0};
-    BYTE *mem;
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    static const DWORD sysmem_locations = WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER
+            | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
+
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        surface_prepare_texture(surface, context, srgb);
+        return WINED3D_OK;
+    }
 
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
             && surface_is_offscreen(surface)
-            && (surface->flags & SFLAG_INDRAWABLE))
+            && (surface->resource.locations & WINED3D_LOCATION_DRAWABLE))
     {
         surface_load_fb_texture(surface, srgb);
 
         return WINED3D_OK;
     }
 
-    if (surface->flags & (SFLAG_INSRGBTEX | SFLAG_INTEXTURE)
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB)
             && (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB)
             && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
     {
         if (srgb)
-            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, SFLAG_INTEXTURE,
-                    &src_rect, surface, SFLAG_INSRGBTEX, &src_rect);
+            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_RGB,
+                    &src_rect, surface, WINED3D_LOCATION_TEXTURE_SRGB, &src_rect);
         else
-            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, SFLAG_INSRGBTEX,
-                    &src_rect, surface, SFLAG_INTEXTURE, &src_rect);
+            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_SRGB,
+                    &src_rect, surface, WINED3D_LOCATION_TEXTURE_RGB, &src_rect);
 
         return WINED3D_OK;
     }
 
-    if (surface->flags & (SFLAG_INRB_MULTISAMPLE | SFLAG_INRB_RESOLVED)
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED)
             && (!srgb || (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB))
             && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
     {
-        DWORD src_location = surface->flags & SFLAG_INRB_RESOLVED ? SFLAG_INRB_RESOLVED : SFLAG_INRB_MULTISAMPLE;
-        DWORD dst_location = srgb ? SFLAG_INSRGBTEX : SFLAG_INTEXTURE;
+        DWORD src_location = surface->resource.locations & WINED3D_LOCATION_RB_RESOLVED
+                ? WINED3D_LOCATION_RB_RESOLVED : WINED3D_LOCATION_RB_MULTISAMPLE;
+        DWORD dst_location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
         RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
         surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, src_location,
@@ -5446,39 +5118,35 @@
     }
 
     /* Upload from system memory */
-
-    d3dfmt_get_conv(surface, TRUE /* We need color keying */,
-            TRUE /* We will use textures */, &format, &convert);
-
     if (srgb)
     {
-        if ((surface->flags & (SFLAG_INTEXTURE | SFLAG_INSYSMEM)) == SFLAG_INTEXTURE)
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | surface->resource.map_binding))
+                == WINED3D_LOCATION_TEXTURE_RGB)
         {
             /* Performance warning... */
             FIXME("Downloading RGB surface %p to reload it as sRGB.\n", surface);
-            surface_load_location(surface, SFLAG_INSYSMEM, rect);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         }
     }
     else
     {
-        if ((surface->flags & (SFLAG_INSRGBTEX | SFLAG_INSYSMEM)) == SFLAG_INSRGBTEX)
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_SRGB | surface->resource.map_binding))
+                == WINED3D_LOCATION_TEXTURE_SRGB)
         {
             /* Performance warning... */
             FIXME("Downloading sRGB surface %p to reload it as RGB.\n", surface);
-            surface_load_location(surface, SFLAG_INSYSMEM, rect);
+            wined3d_resource_load_location(&surface->resource, NULL, surface->resource.map_binding);
         }
     }
 
-    if (!(surface->flags & SFLAG_INSYSMEM))
+    if (!(surface->resource.locations & sysmem_locations))
     {
-        WARN("Trying to load a texture from sysmem, but SFLAG_INSYSMEM is not set.\n");
+        WARN("Trying to load a texture from sysmem, but no sysmem location is valid.\n");
         /* Lets hope we get it from somewhere... */
-        surface_load_location(surface, SFLAG_INSYSMEM, rect);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
     }
 
-    /* TODO: Use already acquired context when possible. */
-    context = context_acquire(device, NULL);
-
     surface_prepare_texture(surface, context, srgb);
     surface_bind_and_dirtify(surface, context, srgb);
 
@@ -5489,72 +5157,9 @@
     }
     else surface->flags &= ~SFLAG_GLCKEY;
 
-    width = surface->resource.width;
-    src_pitch = wined3d_surface_get_pitch(surface);
-
-    /* Don't use PBOs for converted surfaces. During PBO conversion we look at
-     * SFLAG_CONVERTED but it isn't set (yet) in all cases it is getting
-     * called. */
-    if ((convert != WINED3D_CT_NONE || format.convert) && (surface->flags & SFLAG_PBO))
-    {
-        TRACE("Removing the pbo attached to surface %p.\n", surface);
-        surface_remove_pbo(surface, gl_info);
-    }
-
-    if (format.convert)
-    {
-        /* This code is entered for texture formats which need a fixup. */
-        UINT height = surface->resource.height;
-
-        /* Stick to the alignment for the converted surface too, makes it easier to load the surface */
-        dst_pitch = width * format.conv_byte_count;
-        dst_pitch = (dst_pitch + device->surface_alignment - 1) & ~(device->surface_alignment - 1);
-
-        if (!(mem = HeapAlloc(GetProcessHeap(), 0, dst_pitch * height)))
-        {
-            ERR("Out of memory (%u).\n", dst_pitch * height);
-            context_release(context);
-            return E_OUTOFMEMORY;
-        }
-        format.convert(surface->resource.allocatedMemory, mem, src_pitch, src_pitch * height,
-                dst_pitch, dst_pitch * height, width, height, 1);
-        format.byte_count = format.conv_byte_count;
-        src_pitch = dst_pitch;
-    }
-    else if (convert != WINED3D_CT_NONE && surface->resource.allocatedMemory)
-    {
-        /* This code is only entered for color keying fixups */
-        UINT height = surface->resource.height;
-
-        /* Stick to the alignment for the converted surface too, makes it easier to load the surface */
-        dst_pitch = width * format.conv_byte_count;
-        dst_pitch = (dst_pitch + device->surface_alignment - 1) & ~(device->surface_alignment - 1);
-
-        if (!(mem = HeapAlloc(GetProcessHeap(), 0, dst_pitch * height)))
-        {
-            ERR("Out of memory (%u).\n", dst_pitch * height);
-            context_release(context);
-            return E_OUTOFMEMORY;
-        }
-        d3dfmt_convert_surface(surface->resource.allocatedMemory, mem, src_pitch,
-                width, height, dst_pitch, convert, surface);
-        format.byte_count = format.conv_byte_count;
-        src_pitch = dst_pitch;
-    }
-    else
-    {
-        mem = surface->resource.allocatedMemory;
-    }
-
-    data.buffer_object = surface->pbo;
-    data.addr = mem;
-    surface_upload_data(surface, gl_info, &format, &src_rect, src_pitch, &dst_point, srgb, &data);
-
-    context_release(context);
-
-    /* Don't delete PBO memory. */
-    if ((mem != surface->resource.allocatedMemory) && !(surface->flags & SFLAG_PBO))
-        HeapFree(GetProcessHeap(), 0, mem);
+    wined3d_resource_get_pitch(&surface->resource, &src_row_pitch, &src_slice_pitch);
+    wined3d_resource_get_memory(&surface->resource, surface->resource.locations, &data);
+    surface_upload_data(surface, gl_info, surface->resource.format, &src_rect, src_row_pitch, &dst_point, srgb, &data);
 
     return WINED3D_OK;
 }
@@ -5563,88 +5168,72 @@
 {
     RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
-    if (!(surface->flags & SFLAG_INRB_MULTISAMPLE))
-        ERR("Trying to resolve multisampled surface %p, but location SFLAG_INRB_MULTISAMPLE not current.\n", surface);
+    if (!(surface->resource.locations & WINED3D_LOCATION_RB_MULTISAMPLE))
+        ERR("Trying to resolve multisampled surface %p, but location WINED3D_LOCATION_RB_MULTISAMPLE not current.\n",
+                surface);
 
     surface_blt_fbo(surface->resource.device, WINED3D_TEXF_POINT,
-            surface, SFLAG_INRB_MULTISAMPLE, &rect, surface, SFLAG_INRB_RESOLVED, &rect);
+            surface, WINED3D_LOCATION_RB_MULTISAMPLE, &rect, surface, WINED3D_LOCATION_RB_RESOLVED, &rect);
 }
 
-HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location, const RECT *rect)
+static void wined3d_surface_load_location(struct wined3d_resource *resource, struct wined3d_context *context,
+        DWORD location)
 {
-    struct wined3d_device *device = surface->resource.device;
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_surface *surface = surface_from_resource(resource);
     HRESULT hr;
 
-    TRACE("surface %p, location %s, rect %s.\n", surface, debug_surflocation(location), wine_dbgstr_rect(rect));
+    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
 
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
-        if (location == SFLAG_INTEXTURE && surface->flags & SFLAG_INDRAWABLE)
+        if (location == WINED3D_LOCATION_TEXTURE_RGB &&
+                surface->resource.locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_DISCARDED))
         {
-            struct wined3d_context *context = context_acquire(device, NULL);
             surface_load_ds_location(surface, context, location);
-            context_release(context);
-            return WINED3D_OK;
+            return;
         }
-        else if (location & surface->flags && surface->draw_binding != SFLAG_INDRAWABLE)
+        else if (location & surface->resource.locations && surface->draw_binding != WINED3D_LOCATION_DRAWABLE)
         {
             /* Already up to date, nothing to do. */
-            return WINED3D_OK;
+            return;
         }
         else
         {
             FIXME("Unimplemented copy from %s to %s for depth/stencil buffers.\n",
-                    debug_surflocation(surface->flags & SFLAG_LOCATIONS), debug_surflocation(location));
-            return WINED3DERR_INVALIDCALL;
+                    wined3d_debug_location(surface->resource.locations), wined3d_debug_location(location));
+            return;
         }
     }
 
-    if (surface->flags & location)
-    {
-        TRACE("Location already up to date.\n");
-
-        if (location == SFLAG_INSYSMEM && !(surface->flags & SFLAG_PBO)
-                && surface_need_pbo(surface, gl_info))
-            surface_load_pbo(surface, gl_info);
-
-        return WINED3D_OK;
-    }
-
-    if (WARN_ON(d3d_surface))
-    {
-        DWORD required_access = resource_access_from_location(location);
-        if ((surface->resource.access_flags & required_access) != required_access)
-            WARN("Operation requires %#x access, but surface only has %#x.\n",
-                    required_access, surface->resource.access_flags);
-    }
-
-    if (!(surface->flags & SFLAG_LOCATIONS))
+    if (!surface->resource.locations)
     {
         ERR("Surface %p does not have any up to date location.\n", surface);
         surface->flags |= SFLAG_LOST;
-        return WINED3DERR_DEVICELOST;
+        return;
     }
 
     switch (location)
     {
-        case SFLAG_INSYSMEM:
-            surface_load_sysmem(surface, gl_info, rect);
+        case WINED3D_LOCATION_BUFFER:
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER:
+        case WINED3D_LOCATION_DIB:
+            surface_load_sysmem(surface, context, location);
             break;
 
-        case SFLAG_INDRAWABLE:
-            if (FAILED(hr = surface_load_drawable(surface, gl_info, rect)))
-                return hr;
+        case WINED3D_LOCATION_DRAWABLE:
+            if (FAILED(hr = surface_load_drawable(surface, context)))
+                return;
             break;
 
-        case SFLAG_INRB_RESOLVED:
+        case WINED3D_LOCATION_RB_RESOLVED:
             surface_multisample_resolve(surface);
             break;
 
-        case SFLAG_INTEXTURE:
-        case SFLAG_INSRGBTEX:
-            if (FAILED(hr = surface_load_texture(surface, gl_info, rect, location == SFLAG_INSRGBTEX)))
-                return hr;
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+            if (FAILED(hr = surface_load_texture(surface, context, location == WINED3D_LOCATION_TEXTURE_SRGB)))
+                return;
             break;
 
         default:
@@ -5652,15 +5241,12 @@
             break;
     }
 
-    if (!rect)
-    {
-        surface->flags |= location;
+    surface->resource.locations |= location;
 
-        if (location != SFLAG_INSYSMEM && (surface->flags & SFLAG_INSYSMEM))
-            surface_evict_sysmem(surface);
-    }
+    if (location != WINED3D_LOCATION_SYSMEM && (surface->resource.locations & WINED3D_LOCATION_SYSMEM))
+        surface_evict_sysmem(surface);
 
-    return WINED3D_OK;
+    return;
 }
 
 BOOL surface_is_offscreen(const struct wined3d_surface *surface)
@@ -5946,21 +5532,36 @@
     int bpp, srcheight, srcwidth, dstheight, dstwidth, width;
     const struct wined3d_format *src_format, *dst_format;
     struct wined3d_surface *orig_src = src_surface;
-    struct wined3d_map_desc dst_map, src_map;
+    void *src_data = NULL, *dst_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const BYTE *sbase = NULL;
     HRESULT hr = WINED3D_OK;
     const BYTE *sbuf;
     BYTE *dbuf;
     int x, y;
+    struct wined3d_device *device = dst_surface->resource.device;
+    struct wined3d_context *context = NULL;
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
             flags, fx, debug_d3dtexturefiltertype(filter));
 
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(&dst_surface->resource, context))
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+    wined3d_resource_load_location(&dst_surface->resource, context, dst_surface->resource.map_binding);
+
     if (src_surface == dst_surface)
     {
-        wined3d_surface_map(dst_surface, &dst_map, NULL, 0);
-        src_map = dst_map;
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        src_data = dst_data;
+        src_row_pitch = dst_row_pitch;
         src_format = dst_surface->resource.format;
         dst_format = src_format;
     }
@@ -5969,6 +5570,12 @@
         dst_format = dst_surface->resource.format;
         if (src_surface)
         {
+            if (!wined3d_resource_prepare_map_memory(&src_surface->resource, context))
+            {
+                hr = E_OUTOFMEMORY;
+                goto error;
+            }
+
             if (dst_surface->resource.format->id != src_surface->resource.format->id)
             {
                 src_surface = surface_convert_format(src_surface, dst_format->id);
@@ -5979,7 +5586,9 @@
                     goto release;
                 }
             }
-            wined3d_surface_map(src_surface, &src_map, NULL, WINED3D_MAP_READONLY);
+            wined3d_resource_load_location(&src_surface->resource, context, src_surface->resource.map_binding);
+            wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
+            src_data = wined3d_resource_get_map_ptr(&src_surface->resource, context, 0);
             src_format = src_surface->resource.format;
         }
         else
@@ -5987,7 +5596,8 @@
             src_format = dst_format;
         }
 
-        wined3d_surface_map(dst_surface, &dst_map, dst_rect, 0);
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
     }
 
     bpp = dst_surface->resource.format->byte_count;
@@ -5998,15 +5608,12 @@
     width = (dst_rect->right - dst_rect->left) * bpp;
 
     if (src_surface)
-        sbase = (BYTE *)src_map.data
-                + ((src_rect->top / src_format->block_height) * src_map.row_pitch)
+        sbase = (BYTE *)src_data
+                + ((src_rect->top / src_format->block_height) * src_row_pitch)
                 + ((src_rect->left / src_format->block_width) * src_format->block_byte_count);
-    if (src_surface != dst_surface)
-        dbuf = dst_map.data;
-    else
-        dbuf = (BYTE *)dst_map.data
-                + ((dst_rect->top / dst_format->block_height) * dst_map.row_pitch)
-                + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
+    dbuf = (BYTE *)dst_data
+            + ((dst_rect->top / dst_format->block_height) * dst_row_pitch)
+            + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
 
     if (src_format->flags & dst_format->flags & WINED3DFMT_FLAG_BLOCKS)
     {
@@ -6041,7 +5648,7 @@
         }
 
         hr = surface_cpu_blt_compressed(sbase, dbuf,
-                src_map.row_pitch, dst_map.row_pitch, dstwidth, dstheight,
+                src_row_pitch, dst_row_pitch, dstwidth, dstheight,
                 src_format, flags, fx);
         goto release;
     }
@@ -6049,7 +5656,7 @@
     /* First, all the 'source-less' blits */
     if (flags & WINEDDBLT_COLORFILL)
     {
-        hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, fx->u5.dwFillColor);
+        hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, fx->u5.dwFillColor);
         flags &= ~WINEDDBLT_COLORFILL;
     }
 
@@ -6063,12 +5670,12 @@
         switch (fx->dwROP)
         {
             case BLACKNESS:
-                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, 0);
+                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, 0);
                 break;
             case 0xaa0029: /* No-op */
                 break;
             case WHITENESS:
-                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, ~0U);
+                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, ~0U);
                 break;
             case SRCCOPY: /* Well, we do that below? */
                 break;
@@ -6119,19 +5726,19 @@
                         for (y = 0; y < dstheight; ++y)
                         {
                             memcpy(dbuf, sbuf, width);
-                            sbuf += src_map.row_pitch;
-                            dbuf += dst_map.row_pitch;
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
                         }
                     }
                     else if (dst_rect->top > src_rect->top)
                     {
                         /* Copy from bottom upwards. */
-                        sbuf += src_map.row_pitch * dstheight;
-                        dbuf += dst_map.row_pitch * dstheight;
+                        sbuf += src_row_pitch * dstheight;
+                        dbuf += dst_row_pitch * dstheight;
                         for (y = 0; y < dstheight; ++y)
                         {
-                            sbuf -= src_map.row_pitch;
-                            dbuf -= dst_map.row_pitch;
+                            sbuf -= src_row_pitch;
+                            dbuf -= dst_row_pitch;
                             memcpy(dbuf, sbuf, width);
                         }
                     }
@@ -6141,8 +5748,8 @@
                         for (y = 0; y < dstheight; ++y)
                         {
                             memmove(dbuf, sbuf, width);
-                            sbuf += src_map.row_pitch;
-                            dbuf += dst_map.row_pitch;
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
                         }
                     }
                 }
@@ -6151,9 +5758,9 @@
                     /* Stretching in y direction only. */
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
-                        sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
                         memcpy(dbuf, sbuf, width);
-                        dbuf += dst_map.row_pitch;
+                        dbuf += dst_row_pitch;
                     }
                 }
             }
@@ -6163,13 +5770,13 @@
                 int last_sy = -1;
                 for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                 {
-                    sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                    sbuf = sbase + (sy >> 16) * src_row_pitch;
 
                     if ((sy >> 16) == (last_sy >> 16))
                     {
                         /* This source row is the same as last source row -
                          * Copy the already stretched row. */
-                        memcpy(dbuf, dbuf - dst_map.row_pitch, width);
+                        memcpy(dbuf, dbuf - dst_row_pitch, width);
                     }
                     else
                     {
@@ -6216,14 +5823,14 @@
                         }
 #undef STRETCH_ROW
                     }
-                    dbuf += dst_map.row_pitch;
+                    dbuf += dst_row_pitch;
                     last_sy = sy;
                 }
             }
         }
         else
         {
-            LONG dstyinc = dst_map.row_pitch, dstxinc = bpp;
+            LONG dstyinc = dst_row_pitch, dstxinc = bpp;
             DWORD keylow = 0xffffffff, keyhigh = 0, keymask = 0xffffffff;
             DWORD destkeylow = 0x0, destkeyhigh = 0xffffffff, destkeymask = 0xffffffff;
             if (flags & (WINEDDBLT_KEYSRC | WINEDDBLT_KEYDEST | WINEDDBLT_KEYSRCOVERRIDE | WINEDDBLT_KEYDESTOVERRIDE))
@@ -6273,7 +5880,7 @@
                 LONG tmpxy;
                 dTopLeft     = dbuf;
                 dTopRight    = dbuf + ((dstwidth - 1) * bpp);
-                dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_map.row_pitch);
+                dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_row_pitch);
                 dBottomRight = dBottomLeft + ((dstwidth - 1) * bpp);
 
                 if (fx->dwDDFX & WINEDDBLTFX_ARITHSTRETCHY)
@@ -6356,7 +5963,7 @@
     type *d = (type *)dbuf, *dx, tmp; \
     for (y = sy = 0; y < dstheight; ++y, sy += yinc) \
     { \
-        s = (const type *)(sbase + (sy >> 16) * src_map.row_pitch); \
+        s = (const type *)(sbase + (sy >> 16) * src_row_pitch); \
         dx = d; \
         for (x = sx = 0; x < dstwidth; ++x, sx += xinc) \
         { \
@@ -6389,7 +5996,7 @@
                     BYTE *d = dbuf, *dx;
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
-                        sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
                         dx = d;
                         for (x = sx = 0; x < dstwidth; ++x, sx+= xinc)
                         {
@@ -6420,166 +6027,107 @@
         }
     }
 
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->resource.map_binding);
+    if (dst_surface->container)
+        wined3d_texture_set_dirty(dst_surface->container);
+
 error:
     if (flags && FIXME_ON(d3d_surface))
     {
         FIXME("\tUnsupported flags: %#x.\n", flags);
     }
 
-release:
-    wined3d_surface_unmap(dst_surface);
-    if (src_surface && src_surface != dst_surface)
-        wined3d_surface_unmap(src_surface);
-    /* Release the converted surface, if any. */
-    if (src_surface && src_surface != orig_src)
-        wined3d_surface_decref(src_surface);
-
-    return hr;
-}
-
-static HRESULT cpu_blit_color_fill(struct wined3d_device *device, struct wined3d_surface *dst_surface,
-        const RECT *dst_rect, const struct wined3d_color *color)
-{
-    static const RECT src_rect;
-    WINEDDBLTFX BltFx;
-
-    memset(&BltFx, 0, sizeof(BltFx));
-    BltFx.dwSize = sizeof(BltFx);
-    BltFx.u5.dwFillColor = wined3d_format_convert_from_float(dst_surface, color);
-    return surface_cpu_blt(dst_surface, dst_rect, NULL, &src_rect,
-            WINEDDBLT_COLORFILL, &BltFx, WINED3D_TEXF_POINT);
-}
-
-static HRESULT cpu_blit_depth_fill(struct wined3d_device *device,
-        struct wined3d_surface *surface, const RECT *rect, float depth)
-{
-    FIXME("Depth filling not implemented by cpu_blit.\n");
-    return WINED3DERR_INVALIDCALL;
-}
-
-const struct blit_shader cpu_blit =  {
-    cpu_blit_alloc,
-    cpu_blit_free,
-    cpu_blit_set,
-    cpu_blit_unset,
-    cpu_blit_supported,
-    cpu_blit_color_fill,
-    cpu_blit_depth_fill,
-};
-
-HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
-        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
-        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
-{
-    struct wined3d_swapchain *src_swapchain, *dst_swapchain;
-    struct wined3d_device *device = dst_surface->resource.device;
-    DWORD src_ds_flags, dst_ds_flags;
-    RECT src_rect, dst_rect;
-    BOOL scale, convert;
-
-    static const DWORD simple_blit = WINEDDBLT_ASYNC
-            | WINEDDBLT_COLORFILL
-            | WINEDDBLT_WAIT
-            | WINEDDBLT_DEPTHFILL
-            | WINEDDBLT_DONOTWAIT;
-
-    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
-            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
-            flags, fx, debug_d3dtexturefiltertype(filter));
-    TRACE("Usage is %s.\n", debug_d3dusage(dst_surface->resource.usage));
-
-    if (fx)
-    {
-        TRACE("dwSize %#x.\n", fx->dwSize);
-        TRACE("dwDDFX %#x.\n", fx->dwDDFX);
-        TRACE("dwROP %#x.\n", fx->dwROP);
-        TRACE("dwDDROP %#x.\n", fx->dwDDROP);
-        TRACE("dwRotationAngle %#x.\n", fx->dwRotationAngle);
-        TRACE("dwZBufferOpCode %#x.\n", fx->dwZBufferOpCode);
-        TRACE("dwZBufferLow %#x.\n", fx->dwZBufferLow);
-        TRACE("dwZBufferHigh %#x.\n", fx->dwZBufferHigh);
-        TRACE("dwZBufferBaseDest %#x.\n", fx->dwZBufferBaseDest);
-        TRACE("dwZDestConstBitDepth %#x.\n", fx->dwZDestConstBitDepth);
-        TRACE("lpDDSZBufferDest %p.\n", fx->u1.lpDDSZBufferDest);
-        TRACE("dwZSrcConstBitDepth %#x.\n", fx->dwZSrcConstBitDepth);
-        TRACE("lpDDSZBufferSrc %p.\n", fx->u2.lpDDSZBufferSrc);
-        TRACE("dwAlphaEdgeBlendBitDepth %#x.\n", fx->dwAlphaEdgeBlendBitDepth);
-        TRACE("dwAlphaEdgeBlend %#x.\n", fx->dwAlphaEdgeBlend);
-        TRACE("dwReserved %#x.\n", fx->dwReserved);
-        TRACE("dwAlphaDestConstBitDepth %#x.\n", fx->dwAlphaDestConstBitDepth);
-        TRACE("lpDDSAlphaDest %p.\n", fx->u3.lpDDSAlphaDest);
-        TRACE("dwAlphaSrcConstBitDepth %#x.\n", fx->dwAlphaSrcConstBitDepth);
-        TRACE("lpDDSAlphaSrc %p.\n", fx->u4.lpDDSAlphaSrc);
-        TRACE("lpDDSPattern %p.\n", fx->u5.lpDDSPattern);
-        TRACE("ddckDestColorkey {%#x, %#x}.\n",
-                fx->ddckDestColorkey.color_space_low_value,
-                fx->ddckDestColorkey.color_space_high_value);
-        TRACE("ddckSrcColorkey {%#x, %#x}.\n",
-                fx->ddckSrcColorkey.color_space_low_value,
-                fx->ddckSrcColorkey.color_space_high_value);
-    }
-
-    if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+release:
+    if (dst_data)
     {
-        WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
-        return WINEDDERR_SURFACEBUSY;
+        wined3d_resource_release_map_ptr(&dst_surface->resource, context);
+
+        if (dst_surface->swapchain && dst_surface == dst_surface->swapchain->front_buffer)
+            dst_surface->surface_ops->surface_frontbuffer_updated(dst_surface);
     }
+    if (src_surface && src_surface != dst_surface && src_data)
+        wined3d_resource_release_map_ptr(&src_surface->resource, context);
+    /* Release the converted surface, if any. */
+    if (src_surface && src_surface != orig_src)
+        wined3d_surface_decref(src_surface);
+    if (context)
+        context_release(context);
 
-    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
+    return hr;
+}
 
-    if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
-            || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
-            || dst_rect.top > dst_surface->resource.height || dst_rect.top < 0
-            || dst_rect.right > dst_surface->resource.width || dst_rect.right < 0
-            || dst_rect.bottom > dst_surface->resource.height || dst_rect.bottom < 0)
-    {
-        WARN("The application gave us a bad destination rectangle.\n");
-        return WINEDDERR_INVALIDRECT;
-    }
+static HRESULT cpu_blit_color_fill(struct wined3d_device *device, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, const struct wined3d_color *color)
+{
+    static const RECT src_rect;
+    WINEDDBLTFX BltFx;
 
-    if (src_surface)
-    {
-        surface_get_rect(src_surface, src_rect_in, &src_rect);
+    memset(&BltFx, 0, sizeof(BltFx));
+    BltFx.dwSize = sizeof(BltFx);
+    BltFx.u5.dwFillColor = wined3d_format_convert_from_float(dst_surface, color);
+    return surface_cpu_blt(dst_surface, dst_rect, NULL, &src_rect,
+            WINEDDBLT_COLORFILL, &BltFx, WINED3D_TEXF_POINT);
+}
 
-        if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
-                || src_rect.left > src_surface->resource.width || src_rect.left < 0
-                || src_rect.top > src_surface->resource.height || src_rect.top < 0
-                || src_rect.right > src_surface->resource.width || src_rect.right < 0
-                || src_rect.bottom > src_surface->resource.height || src_rect.bottom < 0)
-        {
-            WARN("Application gave us bad source rectangle for Blt.\n");
-            return WINEDDERR_INVALIDRECT;
-        }
+static HRESULT cpu_blit_depth_fill(struct wined3d_device *device,
+        struct wined3d_surface *surface, const RECT *rect, float depth)
+{
+    FIXME("Depth filling not implemented by cpu_blit.\n");
+    return WINED3DERR_INVALIDCALL;
+}
+
+static void surface_download_to_surface(struct wined3d_surface *dst, struct wined3d_surface *src)
+{
+    struct wined3d_device *device = dst->resource.device;
+    struct wined3d_context *context = context_acquire(device, NULL);
+    struct wined3d_bo_address data;
+
+    if (src->resource.locations & WINED3D_LOCATION_TEXTURE_SRGB)
+    {
+        surface_bind_and_dirtify(src, context, TRUE);
     }
     else
     {
-        memset(&src_rect, 0, sizeof(src_rect));
+        surface_bind_and_dirtify(src, context, FALSE);
+        wined3d_resource_load_location(&src->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     }
 
-    if (!fx || !(fx->dwDDFX))
-        flags &= ~WINEDDBLT_DDFX;
+    wined3d_resource_prepare_map_memory(&dst->resource, context);
+    /* We always write to the full surface */
+    wined3d_resource_validate_location(&dst->resource, dst->resource.map_binding);
+    wined3d_resource_get_memory(&dst->resource, dst->resource.map_binding, &data);
 
-    if (flags & WINEDDBLT_WAIT)
-        flags &= ~WINEDDBLT_WAIT;
+    surface_download_data(src, context->gl_info, &data);
 
-    if (flags & WINEDDBLT_ASYNC)
-    {
-        static unsigned int once;
+    wined3d_resource_invalidate_location(&dst->resource, ~dst->resource.map_binding);
 
-        if (!once++)
-            FIXME("Can't handle WINEDDBLT_ASYNC flag.\n");
-        flags &= ~WINEDDBLT_ASYNC;
-    }
+    context_release(context);
+}
 
-    /* WINEDDBLT_DONOTWAIT appeared in DX7. */
-    if (flags & WINEDDBLT_DONOTWAIT)
-    {
-        static unsigned int once;
+const struct blit_shader cpu_blit =  {
+    cpu_blit_alloc,
+    cpu_blit_free,
+    cpu_blit_set,
+    cpu_blit_unset,
+    cpu_blit_supported,
+    cpu_blit_color_fill,
+    cpu_blit_depth_fill,
+};
 
-        if (!once++)
-            FIXME("Can't handle WINEDDBLT_DONOTWAIT flag.\n");
-        flags &= ~WINEDDBLT_DONOTWAIT;
-    }
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+    struct wined3d_device *device = dst_surface->resource.device;
+    DWORD src_ds_flags, dst_ds_flags;
+    BOOL scale, convert;
+
+    static const DWORD simple_blit = WINEDDBLT_ASYNC
+            | WINEDDBLT_COLORFILL
+            | WINEDDBLT_WAIT
+            | WINEDDBLT_DEPTHFILL
+            | WINEDDBLT_DONOTWAIT;
 
     if (!device->d3d_initialized)
     {
@@ -6621,8 +6169,8 @@
     }
 
     scale = src_surface
-            && (src_rect.right - src_rect.left != dst_rect.right - dst_rect.left
-            || src_rect.bottom - src_rect.top != dst_rect.bottom - dst_rect.top);
+            && (src_rect->right - src_rect->left != dst_rect->right - dst_rect->left
+            || src_rect->bottom - src_rect->top != dst_rect->bottom - dst_rect->top);
     convert = src_surface && src_surface->resource.format->id != dst_surface->resource.format->id;
 
     dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
@@ -6640,30 +6188,24 @@
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->u5.dwFillDepth, &depth))
-                return WINED3DERR_INVALIDCALL;
+                return;
 
-            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, &dst_rect, depth)))
-                return WINED3D_OK;
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return;
         }
         else
         {
-            if (src_ds_flags != dst_ds_flags)
-            {
-                WARN("Rejecting depth / stencil blit between incompatible formats.\n");
-                return WINED3DERR_INVALIDCALL;
-            }
-
-            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_surface->draw_binding, &src_rect,
-                    dst_surface, dst_surface->draw_binding, &dst_rect)))
-                return WINED3D_OK;
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_surface->draw_binding, src_rect,
+                    dst_surface, dst_surface->draw_binding, dst_rect)))
+                return;
         }
     }
     else
     {
         /* In principle this would apply to depth blits as well, but we don't
          * implement those in the CPU blitter at the moment. */
-        if ((dst_surface->flags & SFLAG_INSYSMEM)
-                && (!src_surface || (src_surface->flags & SFLAG_INSYSMEM)))
+        if ((dst_surface->resource.locations & WINED3D_LOCATION_SYSMEM)
+                && (!src_surface || (src_surface->resource.locations & WINED3D_LOCATION_SYSMEM)))
         {
             if (scale)
                 TRACE("Not doing sysmem blit because of scaling.\n");
@@ -6682,15 +6224,16 @@
             if (!surface_convert_color_to_float(dst_surface, fx->u5.dwFillColor, &color))
                 goto fallback;
 
-            if (SUCCEEDED(surface_color_fill(dst_surface, &dst_rect, &color)))
-                return WINED3D_OK;
+            if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+                return;
         }
         else
         {
             TRACE("Color blit.\n");
 
             /* Upload */
-            if ((src_surface->flags & SFLAG_INSYSMEM) && !(dst_surface->flags & SFLAG_INSYSMEM))
+            if ((src_surface->resource.locations & WINED3D_LOCATION_SYSMEM)
+                    && !(dst_surface->resource.locations & WINED3D_LOCATION_SYSMEM))
             {
                 if (scale)
                     TRACE("Not doing upload because of scaling.\n");
@@ -6698,16 +6241,38 @@
                     TRACE("Not doing upload because of format conversion.\n");
                 else
                 {
-                    POINT dst_point = {dst_rect.left, dst_rect.top};
+                    POINT dst_point = {dst_rect->left, dst_rect->top};
 
-                    if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, &src_rect)))
+                    if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, src_rect)))
                     {
                         if (!surface_is_offscreen(dst_surface))
-                            surface_load_location(dst_surface, dst_surface->draw_binding, NULL);
-                        return WINED3D_OK;
+                        {
+                            struct wined3d_context *context = context_acquire(device, NULL);
+                            wined3d_resource_load_location(&dst_surface->resource,
+                                    context, dst_surface->draw_binding);
+                            context_release(context);
+                        }
+                        return;
                     }
                 }
             }
+            else if (src_surface->resource.pool != WINED3D_POOL_SYSTEM_MEM
+                    && src_surface->resource.pool != WINED3D_POOL_SCRATCH
+                    && dst_surface->resource.pool == WINED3D_POOL_SYSTEM_MEM)
+            {
+                if (scale)
+                    TRACE("Not doing download because of scaling.\n");
+                else if (convert)
+                    TRACE("Not doing download because of format conversion.\n");
+                else if (!surface_is_full_rect(src_surface, src_rect)
+                        || !surface_is_full_rect(dst_surface, dst_rect))
+                    FIXME("Not doing download because of size mismatch.\n");
+                else
+                {
+                    surface_download_to_surface(dst_surface, src_surface);
+                    return;
+                }
+            }
 
             /* Use present for back -> front blits. The idea behind this is
              * that present is potentially faster than a blit, in particular
@@ -6729,47 +6294,188 @@
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, NULL, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
-                return WINED3D_OK;
+                return;
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
-                    &src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
-                    &dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
             {
                 TRACE("Using FBO blit.\n");
 
                 surface_blt_fbo(device, filter,
-                        src_surface, src_surface->draw_binding, &src_rect,
-                        dst_surface, dst_surface->draw_binding, &dst_rect);
-                surface_validate_location(dst_surface, dst_surface->draw_binding);
-                surface_invalidate_location(dst_surface, ~dst_surface->draw_binding);
+                        src_surface, src_surface->draw_binding, src_rect,
+                        dst_surface, dst_surface->draw_binding, dst_rect);
+                wined3d_resource_validate_location(&dst_surface->resource, dst_surface->draw_binding);
+                wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->draw_binding);
 
-                return WINED3D_OK;
+                return;
             }
 
             if (arbfp_blit.blit_supported(&device->adapter->gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
-                    &src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
-                    &dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
             {
                 TRACE("Using arbfp blit.\n");
 
-                if (SUCCEEDED(arbfp_blit_surface(device, filter, src_surface, &src_rect, dst_surface, &dst_rect)))
-                    return WINED3D_OK;
+                if (SUCCEEDED(arbfp_blit_surface(device, filter, src_surface, src_rect, dst_surface, dst_rect)))
+                    return;
             }
         }
     }
 
 fallback:
     /* Special cases for render targets. */
-    if (SUCCEEDED(surface_blt_special(dst_surface, &dst_rect, src_surface, &src_rect, flags, fx, filter)))
-        return WINED3D_OK;
+    if ((dst_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
+            || (src_surface && (src_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)))
+    {
+        if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+            return;
+    }
 
 cpu:
 
     /* For the rest call the X11 surface implementation. For render targets
      * this should be implemented OpenGL accelerated in surface_blt_special(),
      * other blits are rather rare. */
-    return surface_cpu_blt(dst_surface, &dst_rect, src_surface, &src_rect, flags, fx, filter);
+    surface_cpu_blt(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter);
+    return;
+}
+
+HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_device *device = dst_surface->resource.device;
+    RECT src_rect, dst_rect;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_surface->resource.usage));
+
+    if (fx)
+    {
+        TRACE("dwSize %#x.\n", fx->dwSize);
+        TRACE("dwDDFX %#x.\n", fx->dwDDFX);
+        TRACE("dwROP %#x.\n", fx->dwROP);
+        TRACE("dwDDROP %#x.\n", fx->dwDDROP);
+        TRACE("dwRotationAngle %#x.\n", fx->dwRotationAngle);
+        TRACE("dwZBufferOpCode %#x.\n", fx->dwZBufferOpCode);
+        TRACE("dwZBufferLow %#x.\n", fx->dwZBufferLow);
+        TRACE("dwZBufferHigh %#x.\n", fx->dwZBufferHigh);
+        TRACE("dwZBufferBaseDest %#x.\n", fx->dwZBufferBaseDest);
+        TRACE("dwZDestConstBitDepth %#x.\n", fx->dwZDestConstBitDepth);
+        TRACE("lpDDSZBufferDest %p.\n", fx->u1.lpDDSZBufferDest);
+        TRACE("dwZSrcConstBitDepth %#x.\n", fx->dwZSrcConstBitDepth);
+        TRACE("lpDDSZBufferSrc %p.\n", fx->u2.lpDDSZBufferSrc);
+        TRACE("dwAlphaEdgeBlendBitDepth %#x.\n", fx->dwAlphaEdgeBlendBitDepth);
+        TRACE("dwAlphaEdgeBlend %#x.\n", fx->dwAlphaEdgeBlend);
+        TRACE("dwReserved %#x.\n", fx->dwReserved);
+        TRACE("dwAlphaDestConstBitDepth %#x.\n", fx->dwAlphaDestConstBitDepth);
+        TRACE("lpDDSAlphaDest %p.\n", fx->u3.lpDDSAlphaDest);
+        TRACE("dwAlphaSrcConstBitDepth %#x.\n", fx->dwAlphaSrcConstBitDepth);
+        TRACE("lpDDSAlphaSrc %p.\n", fx->u4.lpDDSAlphaSrc);
+        TRACE("lpDDSPattern %p.\n", fx->u5.lpDDSPattern);
+        TRACE("ddckDestColorkey {%#x, %#x}.\n",
+                fx->ddckDestColorkey.color_space_low_value,
+                fx->ddckDestColorkey.color_space_high_value);
+        TRACE("ddckSrcColorkey {%#x, %#x}.\n",
+                fx->ddckSrcColorkey.color_space_low_value,
+                fx->ddckSrcColorkey.color_space_high_value);
+    }
+
+    if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+    {
+        /* TODO: Separate application maps from internal maps */
+        if (!wined3d_use_csmt(device))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+
+        wined3d_cs_emit_glfinish(dst_surface->resource.device->cs);
+        dst_surface->resource.device->cs->ops->finish(dst_surface->resource.device->cs);
+
+        if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
+
+    if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
+            || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
+            || dst_rect.top > dst_surface->resource.height || dst_rect.top < 0
+            || dst_rect.right > dst_surface->resource.width || dst_rect.right < 0
+            || dst_rect.bottom > dst_surface->resource.height || dst_rect.bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_surface)
+    {
+        DWORD src_ds_flags, dst_ds_flags;
+
+        surface_get_rect(src_surface, src_rect_in, &src_rect);
+
+        if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
+                || src_rect.left > src_surface->resource.width || src_rect.left < 0
+                || src_rect.top > src_surface->resource.height || src_rect.top < 0
+                || src_rect.right > src_surface->resource.width || src_rect.right < 0
+                || src_rect.bottom > src_surface->resource.height || src_rect.bottom < 0)
+        {
+            WARN("Application gave us bad source rectangle for Blt.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+
+        dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        src_ds_flags = src_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        if (src_ds_flags != dst_ds_flags)
+        {
+            WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+
+    }
+    else
+    {
+        memset(&src_rect, 0, sizeof(src_rect));
+    }
+
+    if (!fx || !(fx->dwDDFX))
+        flags &= ~WINEDDBLT_DDFX;
+
+    if (flags & WINEDDBLT_WAIT)
+        flags &= ~WINEDDBLT_WAIT;
+
+    if (flags & WINEDDBLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_ASYNC flag.\n");
+        flags &= ~WINEDDBLT_ASYNC;
+    }
+
+    /* WINEDDBLT_DONOTWAIT appeared in DX7. */
+    if (flags & WINEDDBLT_DONOTWAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_DONOTWAIT flag.\n");
+        flags &= ~WINEDDBLT_DONOTWAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, &dst_rect, src_surface, &src_rect,
+            flags, fx, filter);
+
+    return WINED3D_OK;
 }
 
 static HRESULT surface_init(struct wined3d_surface *surface, UINT alignment, UINT width, UINT height,
@@ -6847,6 +6553,8 @@
         return hr;
     }
 
+    surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
+
     /* "Standalone" surface. */
     surface_set_container(surface, NULL);
 
@@ -6861,23 +6569,18 @@
     if (lockable || format_id == WINED3DFMT_D16_LOCKABLE)
         surface->resource.access_flags |= WINED3D_RESOURCE_ACCESS_CPU;
 
-    /* I'm not sure if this qualifies as a hack or as an optimization. It
-     * seems reasonable to assume that lockable render targets will get
-     * locked, so we might as well set SFLAG_DYNLOCK right at surface
-     * creation. However, the other reason we want to do this is that several
-     * ddraw applications access surface memory while the surface isn't
-     * mapped. The SFLAG_DYNLOCK behaviour of keeping SYSMEM around for
-     * future locks prevents these from crashing. */
-    if (lockable && (usage & WINED3DUSAGE_RENDERTARGET))
-        surface->flags |= SFLAG_DYNLOCK;
-
-    /* Mark the texture as dirty so that it gets loaded first time around. */
-    surface_add_dirty_rect(surface, NULL);
+    if (surface->resource.heap_memory)
+    {
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_SYSMEM);
+    }
+    else
+    {
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DISCARDED);
+    }
     list_init(&surface->renderbuffers);
 
-    TRACE("surface %p, memory %p, size %u\n",
-            surface, surface->resource.allocatedMemory, surface->resource.size);
-
     /* Call the private setup routine */
     hr = surface->surface_ops->surface_private_setup(surface);
     if (FAILED(hr))
@@ -6887,16 +6590,6 @@
         return hr;
     }
 
-    /* Similar to lockable rendertargets above, creating the DIB section
-     * during surface initialization prevents the sysmem pointer from changing
-     * after a wined3d_surface_getdc() call. */
-    if ((usage & WINED3DUSAGE_OWNDC) && !surface->hDC
-            && SUCCEEDED(surface_create_dib_section(surface)))
-    {
-        wined3d_resource_free_sysmem(&surface->resource);
-        surface->resource.allocatedMemory = surface->dib.bitmap_data;
-    }
-
     return hr;
 }
 
@@ -6922,7 +6615,7 @@
             multisample_quality, device, usage, format_id, pool, flags, parent, parent_ops)))
     {
         WARN("Failed to initialize surface, returning %#x.\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
+        /* The command stream takes care of freeing the memory. */
         return hr;
     }
 
diff -Naur a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
--- a/dlls/wined3d/swapchain.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/swapchain.c	2013-11-07 21:40:10.000000000 +0000
@@ -83,7 +83,7 @@
     {
         TRACE("Destroying backup wined3d window %p, dc %p.\n", swapchain->backup_wnd, swapchain->backup_dc);
 
-        ReleaseDC(swapchain->backup_wnd, swapchain->backup_dc);
+        wined3d_release_dc(swapchain->backup_wnd, swapchain->backup_dc);
         DestroyWindow(swapchain->backup_wnd);
     }
 }
@@ -297,19 +297,20 @@
 
     if (gl_info->fbo_ops.glBlitFramebuffer && is_identity_fixup(backbuffer->resource.format->color_fixup))
     {
-        DWORD location = SFLAG_INTEXTURE;
+        DWORD location = WINED3D_LOCATION_TEXTURE_RGB;
 
         if (backbuffer->resource.multisample_type)
         {
-            location = SFLAG_INRB_RESOLVED;
-            surface_load_location(backbuffer, location, NULL);
+            location = WINED3D_LOCATION_RB_RESOLVED;
+            wined3d_resource_load_location(&backbuffer->resource, context, location);
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, backbuffer, NULL, location);
         gl_info->gl_ops.gl.p_glReadBuffer(GL_COLOR_ATTACHMENT0);
         context_check_fbo_status(context, GL_READ_FRAMEBUFFER);
 
-        context_apply_fbo_state_blit(context, GL_DRAW_FRAMEBUFFER, swapchain->front_buffer, NULL, SFLAG_INDRAWABLE);
+        context_apply_fbo_state_blit(context, GL_DRAW_FRAMEBUFFER,
+                swapchain->front_buffer, NULL, WINED3D_LOCATION_DRAWABLE);
         context_set_draw_buffer(context, GL_BACK);
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
@@ -351,7 +352,8 @@
         if (is_complex_fixup(backbuffer->resource.format->color_fixup))
             gl_filter = GL_NEAREST;
 
-        context_apply_fbo_state_blit(context2, GL_FRAMEBUFFER, swapchain->front_buffer, NULL, SFLAG_INDRAWABLE);
+        context_apply_fbo_state_blit(context2, GL_FRAMEBUFFER, swapchain->front_buffer,
+                NULL, WINED3D_LOCATION_DRAWABLE);
         context_bind_texture(context2, backbuffer->texture_target, backbuffer->texture_name);
 
         /* Set up the texture. The surface is not in a wined3d_texture
@@ -406,10 +408,10 @@
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
-        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
 {
     struct wined3d_surface *back_buffer = swapchain->back_buffers[0];
-    const struct wined3d_fb_state *fb = &swapchain->device->fb;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     RECT src_rect, dst_rect;
@@ -425,49 +427,6 @@
 
     gl_info = context->gl_info;
 
-    /* Render the cursor onto the back buffer, using our nifty directdraw blitting code :-) */
-    if (swapchain->device->bCursorVisible &&
-        swapchain->device->cursorTexture &&
-        !swapchain->device->hardwareCursor)
-    {
-        struct wined3d_surface cursor;
-        RECT destRect =
-        {
-            swapchain->device->xScreenSpace - swapchain->device->xHotSpot,
-            swapchain->device->yScreenSpace - swapchain->device->yHotSpot,
-            swapchain->device->xScreenSpace + swapchain->device->cursorWidth - swapchain->device->xHotSpot,
-            swapchain->device->yScreenSpace + swapchain->device->cursorHeight - swapchain->device->yHotSpot,
-        };
-        TRACE("Rendering the cursor. Creating fake surface at %p\n", &cursor);
-        /* Build a fake surface to call the Blitting code. It is not possible to use the interface passed by
-         * the application because we are only supposed to copy the information out. Using a fake surface
-         * allows us to use the Blitting engine and avoid copying the whole texture -> render target blitting code.
-         */
-        memset(&cursor, 0, sizeof(cursor));
-        cursor.resource.ref = 1;
-        cursor.resource.device = swapchain->device;
-        cursor.resource.pool = WINED3D_POOL_SCRATCH;
-        cursor.resource.format = wined3d_get_format(gl_info, WINED3DFMT_B8G8R8A8_UNORM);
-        cursor.resource.type = WINED3D_RTYPE_SURFACE;
-        cursor.texture_name = swapchain->device->cursorTexture;
-        cursor.texture_target = GL_TEXTURE_2D;
-        cursor.texture_level = 0;
-        cursor.resource.width = swapchain->device->cursorWidth;
-        cursor.resource.height = swapchain->device->cursorHeight;
-        /* The cursor must have pow2 sizes */
-        cursor.pow2Width = cursor.resource.width;
-        cursor.pow2Height = cursor.resource.height;
-        /* The surface is in the texture */
-        cursor.flags |= SFLAG_INTEXTURE;
-        /* DDBLT_KEYSRC will cause BltOverride to enable the alpha test with GL_NOTEQUAL, 0.0,
-         * which is exactly what we want :-)
-         */
-        if (swapchain->desc.windowed)
-            MapWindowPoints(NULL, swapchain->win_handle, (POINT *)&destRect, 2);
-        wined3d_surface_blt(back_buffer, &destRect, &cursor, NULL, WINEDDBLT_KEYSRC,
-                NULL, WINED3D_TEXF_POINT);
-    }
-
     if (swapchain->device->logo_surface)
     {
         struct wined3d_surface *src_surface = swapchain->device->logo_surface;
@@ -519,14 +478,14 @@
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
-        surface_load_location(back_buffer, SFLAG_INTEXTURE, NULL);
-        surface_invalidate_location(back_buffer, SFLAG_INDRAWABLE);
+        wined3d_resource_load_location(&back_buffer->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_invalidate_location(&back_buffer->resource, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
         swapchain_update_draw_bindings(swapchain);
     }
     else
     {
-        surface_load_location(back_buffer, back_buffer->draw_binding, NULL);
+        wined3d_resource_load_location(&back_buffer->resource, context, back_buffer->draw_binding);
     }
 
     if (swapchain->render_to_fbo)
@@ -543,8 +502,8 @@
         swapchain_blit(swapchain, context, &src_rect, &dst_rect);
     }
 
-    if (swapchain->num_contexts > 1)
-        gl_info->gl_ops.gl.p_glFinish();
+    if (swapchain->num_contexts > 1 && !wined3d_use_csmt(swapchain->device))
+        gl_info->gl_ops.gl.p_glFlush();
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc); /* TODO: cycle through the swapchain buffers */
@@ -566,59 +525,35 @@
         }
     }
 
-    if (!swapchain->render_to_fbo && ((swapchain->front_buffer->flags & SFLAG_INSYSMEM)
-            || (back_buffer->flags & SFLAG_INSYSMEM)))
+    wined3d_resource_validate_location(&swapchain->front_buffer->resource, WINED3D_LOCATION_DRAWABLE);
+    wined3d_resource_invalidate_location(&swapchain->front_buffer->resource, ~WINED3D_LOCATION_DRAWABLE);
+    switch (swapchain->desc.swap_effect)
     {
-        /* Both memory copies of the surfaces are ok, flip them around too instead of dirtifying
-         * Doesn't work with render_to_fbo because we're not flipping
-         */
-        struct wined3d_surface *front = swapchain->front_buffer;
+        case WINED3D_SWAP_EFFECT_DISCARD:
+            wined3d_resource_validate_location(&back_buffer->resource, WINED3D_LOCATION_DISCARDED);
+            break;
 
-        if (front->resource.size == back_buffer->resource.size)
-        {
-            flip_surface(front, back_buffer);
+        case WINED3D_SWAP_EFFECT_FLIP:
+            wined3d_resource_validate_location(&back_buffer->resource, back_buffer->draw_binding);
+            wined3d_resource_invalidate_location(&back_buffer->resource, ~back_buffer->draw_binding);
+            break;
 
-            /* Tell the front buffer surface that is has been modified. However,
-             * the other locations were preserved during that, so keep the flags.
-             * This serves to update the emulated overlay, if any. */
-            surface_validate_location(front, SFLAG_INDRAWABLE);
-        }
-        else
-        {
-            surface_validate_location(front, SFLAG_INDRAWABLE);
-            surface_invalidate_location(front, ~SFLAG_INDRAWABLE);
-            surface_validate_location(back_buffer, SFLAG_INDRAWABLE);
-            surface_invalidate_location(back_buffer, ~SFLAG_INDRAWABLE);
-        }
-    }
-    else
-    {
-        surface_validate_location(swapchain->front_buffer, SFLAG_INDRAWABLE);
-        surface_invalidate_location(swapchain->front_buffer, ~SFLAG_INDRAWABLE);
-        /* If the swapeffect is DISCARD, the back buffer is undefined. That means the SYSMEM
-         * and INTEXTURE copies can keep their old content if they have any defined content.
-         * If the swapeffect is COPY, the content remains the same. If it is FLIP however,
-         * the texture / sysmem copy needs to be reloaded from the drawable
-         */
-        if (swapchain->desc.swap_effect == WINED3D_SWAP_EFFECT_FLIP)
-        {
-            surface_validate_location(back_buffer, back_buffer->draw_binding);
-            surface_invalidate_location(back_buffer, ~back_buffer->draw_binding);
-        }
+        default:
+            break;
     }
 
-    if (fb->depth_stencil)
+    if (depth_stencil)
     {
         if (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
-                || fb->depth_stencil->flags & SFLAG_DISCARD)
+                || depth_stencil->flags & SFLAG_DISCARD)
         {
-            surface_modify_ds_location(fb->depth_stencil, SFLAG_DISCARDED,
-                    fb->depth_stencil->resource.width,
-                    fb->depth_stencil->resource.height);
-            if (fb->depth_stencil == swapchain->device->onscreen_depth_stencil)
+            surface_modify_ds_location(depth_stencil, WINED3D_LOCATION_DISCARDED,
+                    depth_stencil->resource.width,
+                    depth_stencil->resource.height);
+            if (depth_stencil == swapchain->device->cs->onscreen_depth_stencil)
             {
-                wined3d_surface_decref(swapchain->device->onscreen_depth_stencil);
-                swapchain->device->onscreen_depth_stencil = NULL;
+                wined3d_surface_decref(swapchain->device->cs->onscreen_depth_stencil);
+                swapchain->device->cs->onscreen_depth_stencil = NULL;
             }
         }
     }
@@ -677,7 +612,8 @@
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
-        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
 {
     struct wined3d_surface *front, *back;
 
@@ -704,9 +640,9 @@
     {
         void *tmp;
 
-        tmp = front->dib.bitmap_data;
-        front->dib.bitmap_data = back->dib.bitmap_data;
-        back->dib.bitmap_data = tmp;
+        tmp = front->resource.dib_memory;
+        front->resource.dib_memory = back->resource.dib_memory;
+        back->resource.dib_memory = tmp;
 
         tmp = front->resource.allocatedMemory;
         front->resource.allocatedMemory = back->resource.allocatedMemory;
@@ -746,6 +682,7 @@
 
 void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain)
 {
+    const struct wined3d_gl_info *gl_info = &swapchain->device->adapter->gl_info;
     RECT client_rect;
 
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
@@ -768,7 +705,8 @@
             swapchain->desc.multisample_type,
             swapchain->desc.multisample_quality);
 
-    if (!wined3d_settings.always_offscreen && !swapchain->desc.multisample_type
+    if (!(wined3d_settings.always_offscreen || (gl_info->quirks & WINED3D_CX_QUIRK_RENDER_TO_FBO))
+            && !swapchain->desc.multisample_type
             && swapchain->desc.backbuffer_width == client_rect.right
             && swapchain->desc.backbuffer_height == client_rect.bottom)
     {
@@ -781,6 +719,68 @@
     swapchain->render_to_fbo = TRUE;
 }
 
+HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    unsigned int i;
+    static const enum wined3d_format_id formats[] =
+    {
+        WINED3DFMT_D24_UNORM_S8_UINT,
+        WINED3DFMT_D32_UNORM,
+        WINED3DFMT_R24_UNORM_X8_TYPELESS,
+        WINED3DFMT_D16_UNORM,
+        WINED3DFMT_S1_UINT_D15_UNORM
+    };
+
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to create the context array.\n");
+        return E_OUTOFMEMORY;
+    }
+    swapchain->num_contexts = 1;
+
+    /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+     * You are able to add a depth + stencil surface at a later stage when you need it.
+     * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+     * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+     * context, need torecreate shaders, textures and other resources.
+     *
+     * The context manager already takes care of the state problem and for the other tasks code from Reset
+     * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+     * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+     * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+     * issue needs to be fixed. */
+    for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+    {
+        swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
+        swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
+        if (swapchain->context[0]) break;
+        TRACE("Depth stencil format %s is not supported, trying next format\n",
+                debug_d3dformat(formats[i]));
+    }
+
+    if (!swapchain->context[0])
+    {
+        WARN("Failed to create context.\n");
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        swapchain->context = NULL;
+        return WINED3DERR_NOTAVAILABLE;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && (!swapchain->desc.enable_auto_depth_stencil
+            || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+    {
+        FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+    }
+    context_release(swapchain->context[0]);
+
+    return WINED3D_OK;
+}
+
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -876,8 +876,8 @@
     surface_set_swapchain(swapchain->front_buffer, swapchain);
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
-        surface_validate_location(swapchain->front_buffer, SFLAG_INDRAWABLE);
-        surface_invalidate_location(swapchain->front_buffer, ~SFLAG_INDRAWABLE);
+        wined3d_resource_validate_location(&swapchain->front_buffer->resource, WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_invalidate_location(&swapchain->front_buffer->resource, ~WINED3D_LOCATION_DRAWABLE);
     }
 
     /* MSDN says we're only allowed a single fullscreen swapchain per device,
@@ -905,60 +905,9 @@
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
-        static const enum wined3d_format_id formats[] =
-        {
-            WINED3DFMT_D24_UNORM_S8_UINT,
-            WINED3DFMT_D32_UNORM,
-            WINED3DFMT_R24_UNORM_X8_TYPELESS,
-            WINED3DFMT_D16_UNORM,
-            WINED3DFMT_S1_UINT_D15_UNORM
-        };
-
-        const struct wined3d_gl_info *gl_info = &adapter->gl_info;
-
-        swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-        if (!swapchain->context)
-        {
-            ERR("Failed to create the context array.\n");
-            hr = E_OUTOFMEMORY;
+        hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+        if (FAILED(hr))
             goto err;
-        }
-        swapchain->num_contexts = 1;
-
-        /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
-         * You are able to add a depth + stencil surface at a later stage when you need it.
-         * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
-         * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
-         * context, need torecreate shaders, textures and other resources.
-         *
-         * The context manager already takes care of the state problem and for the other tasks code from Reset
-         * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
-         * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
-         * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
-         * issue needs to be fixed. */
-        for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
-        {
-            swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
-            swapchain->context[0] = context_create(swapchain, swapchain->front_buffer, swapchain->ds_format);
-            if (swapchain->context[0]) break;
-            TRACE("Depth stencil format %s is not supported, trying next format\n",
-                  debug_d3dformat(formats[i]));
-        }
-
-        if (!swapchain->context[0])
-        {
-            WARN("Failed to create context.\n");
-            hr = WINED3DERR_NOTAVAILABLE;
-            goto err;
-        }
-
-        if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
-                && (!desc->enable_auto_depth_stencil
-                || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
-        {
-            FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
-        }
-        context_release(swapchain->context[0]);
     }
 
     if (swapchain->desc.backbuffer_count > 0)
diff -Naur a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/texture.c	2013-11-07 21:40:10.000000000 +0000
@@ -64,6 +64,8 @@
     {
         ERR("Failed to allocate sub-resource array.\n");
         resource_cleanup(&texture->resource);
+        if (wined3d_use_csmt(texture->resource.device))
+            texture->resource.device->cs->ops->finish(texture->resource.device->cs);
         return E_OUTOFMEMORY;
     }
 
@@ -117,13 +119,28 @@
     resource_unload(&texture->resource);
 }
 
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture)
+{
+    wined3d_texture_unload(texture);
+    HeapFree(GetProcessHeap(), 0, texture->sub_resources);
+    HeapFree(GetProcessHeap(), 0, texture);
+}
+
 static void wined3d_texture_cleanup(struct wined3d_texture *texture)
 {
     UINT sub_count = texture->level_count * texture->layer_count;
     UINT i;
+    struct wined3d_device *device = texture->resource.device;
 
     TRACE("texture %p.\n", texture);
 
+    /* Because sub_resource_cleanup interferes with GL resources */
+    if (wined3d_use_csmt(device))
+    {
+        FIXME("Waiting for cs.\n");
+        device->cs->ops->finish(device->cs);
+    }
+
     for (i = 0; i < sub_count; ++i)
     {
         struct wined3d_resource *sub_resource = texture->sub_resources[i];
@@ -132,9 +149,8 @@
             texture->texture_ops->texture_sub_resource_cleanup(sub_resource);
     }
 
-    wined3d_texture_unload(texture);
-    HeapFree(GetProcessHeap(), 0, texture->sub_resources);
     resource_cleanup(&texture->resource);
+    wined3d_cs_emit_texture_cleanup(device->cs, texture);
 }
 
 void wined3d_texture_set_dirty(struct wined3d_texture *texture)
@@ -452,9 +468,10 @@
 
     if (!refcount)
     {
+        void *parent = texture->resource.parent;
+        const struct wined3d_parent_ops *parent_ops = texture->resource.parent_ops;
         wined3d_texture_cleanup(texture);
-        texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
-        HeapFree(GetProcessHeap(), 0, texture);
+        parent_ops->wined3d_object_destroyed(parent);
     }
 
     return refcount;
@@ -479,10 +496,9 @@
 
 void CDECL wined3d_texture_preload(struct wined3d_texture *texture)
 {
-    struct wined3d_context *context;
-    context = context_acquire(texture->resource.device, NULL);
-    texture->texture_ops->texture_preload(texture, context, SRGB_ANY);
-    context_release(context);
+    const struct wined3d_device *device = texture->resource.device;
+
+    wined3d_cs_emit_texture_preload(device->cs, texture);
 }
 
 void * CDECL wined3d_texture_get_parent(const struct wined3d_texture *texture)
@@ -511,6 +527,13 @@
 
     if (texture->lod != lod)
     {
+        if (wined3d_use_csmt(texture->resource.device))
+        {
+            struct wined3d_device *device = texture->resource.device;
+            FIXME("Waiting for cs.\n");
+            device->cs->ops->finish(device->cs);
+        }
+
         texture->lod = lod;
 
         texture->texture_rgb.states[WINED3DTEXSTA_MAXMIPLEVEL] = ~0U;
@@ -702,7 +725,7 @@
     /* Reload the surfaces if the texture is marked dirty. */
     for (i = 0; i < sub_count; ++i)
     {
-        surface_load(surface_from_resource(texture->sub_resources[i]), srgb_mode);
+        surface_load(surface_from_resource(texture->sub_resources[i]), context, srgb_mode);
     }
     texture->flags |= flag;
 }
@@ -755,9 +778,23 @@
     texture2d_sub_resource_cleanup,
 };
 
+/* Context activation is done by the caller. */
+static void wined3d_texture_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Should not be called on textures.\n");
+}
+
+static void wined3d_texture_changed(struct wined3d_resource *resource)
+{
+    ERR("Should not be called on textures.\n");
+}
+
 static const struct wined3d_resource_ops texture2d_resource_ops =
 {
     texture2d_unload,
+    wined3d_texture_load_location,
+    wined3d_texture_changed,
 };
 
 static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wined3d_resource_desc *desc,
@@ -774,12 +811,14 @@
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[ARB_TEXTURE_CUBE_MAP] && desc->pool != WINED3D_POOL_SCRATCH)
     {
         WARN("(%p) : Tried to create not supported cube texture.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -789,12 +828,14 @@
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -822,6 +863,7 @@
             else
             {
                 WARN("Attempted to create a NPOT cube texture (edge length %u) without GL support.\n", desc->width);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -831,9 +873,18 @@
             desc, device, parent, parent_ops, &texture2d_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
+    if ((gl_info->quirks & WINED3D_CX_QUIRK_COMPRESSED_CUBE_MIP)
+            && (texture->resource.format->flags & WINED3DFMT_FLAG_FILTERING)
+            && (texture->resource.format->flags & WINED3DFMT_FLAG_COMPRESSED))
+    {
+        WARN("Not using mipmapping on compressed cube textures due to driver bug.\n");
+        texture->min_mip_lookup = minMipLookup_noMip;
+    }
+
     texture->pow2_matrix[0] = 1.0f;
     texture->pow2_matrix[5] = 1.0f;
     texture->pow2_matrix[10] = 1.0f;
@@ -895,6 +946,7 @@
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -925,6 +977,7 @@
                 else
                 {
                     WARN("Attempted to create a mipmapped NPOT texture without unconditional NPOT support.\n");
+                    HeapFree(GetProcessHeap(), 0, texture);
                     return WINED3DERR_INVALIDCALL;
                 }
             }
@@ -937,12 +990,14 @@
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -958,6 +1013,7 @@
             desc, device, parent, parent_ops, &texture2d_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -1121,9 +1177,11 @@
     texture3d_sub_resource_cleanup,
 };
 
+/* Context activation is done by the caller. */
 static const struct wined3d_resource_ops texture3d_resource_ops =
 {
     texture3d_unload,
+    wined3d_texture_load_location,
 };
 
 static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct wined3d_resource_desc *desc,
@@ -1139,12 +1197,14 @@
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[EXT_TEXTURE3D])
     {
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1154,12 +1214,14 @@
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -1194,6 +1256,7 @@
             {
                 WARN("Attempted to create a NPOT volume texture (%u, %u, %u) without GL support.\n",
                         desc->width, desc->height, desc->depth);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -1203,6 +1266,7 @@
             desc, device, parent, parent_ops, &texture3d_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -1264,7 +1328,6 @@
     if (FAILED(hr = texture_init(object, desc, level_count, surface_flags, device, parent, parent_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
         *texture = NULL;
         return hr;
     }
@@ -1294,7 +1357,6 @@
     if (FAILED(hr = volumetexture_init(object, desc, level_count, device, parent, parent_ops)))
     {
         WARN("Failed to initialize volumetexture, returning %#x\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
         *texture = NULL;
         return hr;
     }
@@ -1325,7 +1387,6 @@
     if (FAILED(hr = cubetexture_init(object, desc, level_count, surface_flags, device, parent, parent_ops)))
     {
         WARN("Failed to initialize cubetexture, returning %#x\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
         *texture = NULL;
         return hr;
     }
diff -Naur a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
--- a/dlls/wined3d/utils.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/utils.c	2013-11-07 21:40:10.000000000 +0000
@@ -183,6 +183,8 @@
     {WINED3DFMT_R16G16B16A16_FLOAT, WINED3DFMT_FLAG_FLOAT},
     {WINED3DFMT_D32_FLOAT,          WINED3DFMT_FLAG_FLOAT},
     {WINED3DFMT_S8_UINT_D24_FLOAT,  WINED3DFMT_FLAG_FLOAT},
+    {WINED3DFMT_P8_UINT,            WINED3DFMT_FLAG_PALETTE},
+    {WINED3DFMT_P8_UINT_A8_UNORM,   WINED3DFMT_FLAG_PALETTE},
 };
 
 struct wined3d_format_block_info
@@ -2794,19 +2796,6 @@
     TRACE("\tW: %s%s\n", debug_fixup_channel_source(fixup.w_source), fixup.w_sign_fixup ? ", SIGN_FIXUP" : "");
 }
 
-const char *debug_surflocation(DWORD flag) {
-    char buf[128];
-
-    buf[0] = 0;
-    if (flag & SFLAG_INSYSMEM) strcat(buf, " | SFLAG_INSYSMEM");                    /* 17 */
-    if (flag & SFLAG_INDRAWABLE) strcat(buf, " | SFLAG_INDRAWABLE");                /* 19 */
-    if (flag & SFLAG_INTEXTURE) strcat(buf, " | SFLAG_INTEXTURE");                  /* 18 */
-    if (flag & SFLAG_INSRGBTEX) strcat(buf, " | SFLAG_INSRGBTEX");                  /* 18 */
-    if (flag & SFLAG_INRB_MULTISAMPLE) strcat(buf, " | SFLAG_INRB_MULTISAMPLE");    /* 25 */
-    if (flag & SFLAG_INRB_RESOLVED) strcat(buf, " | SFLAG_INRB_RESOLVED");          /* 22 */
-    return wine_dbg_sprintf("%s", buf[0] ? buf + 3 : "0");
-}
-
 BOOL is_invalid_op(const struct wined3d_state *state, int stage,
         enum wined3d_texture_op op, DWORD arg1, DWORD arg2, DWORD arg3)
 {
@@ -2927,7 +2916,7 @@
                 * check for pixel shaders, and the shader has to undo the default gl divide.
                 *
                 * A more serious problem occurs if the app passes 4 coordinates in, and the
-                * 4th is != 1.0(opengl default). This would have to be fixed in drawStridedSlow
+                * 4th is != 1.0(opengl default). This would have to be fixed in draw_strided_slow
                 * or a replacement shader. */
                 default:
                     mat[3] = mat[7] = mat[11] = 0; mat[15] = 1;
@@ -3227,7 +3216,7 @@
     unsigned int i;
     DWORD ttff;
     DWORD cop, aop, carg0, carg1, carg2, aarg0, aarg1, aarg2;
-    const struct wined3d_surface *rt = state->fb->render_targets[0];
+    const struct wined3d_surface *rt = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct wined3d_d3d_info *d3d_info = context->d3d_info;
 
@@ -3278,7 +3267,9 @@
                         break;
                 }
             }
-        } else {
+        }
+        else
+        {
             settings->op[i].color_fixup = COLOR_FIXUP_IDENTITY;
             settings->op[i].tex_type = tex_1d;
         }
@@ -3791,7 +3782,7 @@
 
 const char *wined3d_debug_location(DWORD location)
 {
-    char buf[200];
+    char buf[300];
 
     buf[0] = '\0';
 #define LOCATION_TO_STR(u) if (location & u) { strcat(buf, " | "#u); location &= ~u; }
@@ -3800,6 +3791,11 @@
     LOCATION_TO_STR(WINED3D_LOCATION_BUFFER);
     LOCATION_TO_STR(WINED3D_LOCATION_TEXTURE_RGB);
     LOCATION_TO_STR(WINED3D_LOCATION_TEXTURE_SRGB);
+    LOCATION_TO_STR(WINED3D_LOCATION_DRAWABLE);
+    LOCATION_TO_STR(WINED3D_LOCATION_RB_MULTISAMPLE);
+    LOCATION_TO_STR(WINED3D_LOCATION_RB_RESOLVED);
+    LOCATION_TO_STR(WINED3D_LOCATION_USER);
+    LOCATION_TO_STR(WINED3D_LOCATION_DIB);
 #undef LOCATION_TO_STR
     if (location) FIXME("Unrecognized location flag(s) %#x.\n", location);
 
@@ -3852,3 +3848,17 @@
 
     sprintf(s, "%s%d.%08de%+03d", sign, x, frac, exponent);
 }
+
+void wined3d_release_dc(HWND window, HDC dc)
+{
+    /* You'd figure ReleaseDC() would fail if the DC doesn't match the window.
+     * However, that's not what actually happens, and there are user32 tests
+     * that confirm ReleaseDC() with the wrong window is supposed to succeed.
+     * So explicitly check that the DC belongs to the window, since we want to
+     * avoid releasing a DC that belongs to some other window if the original
+     * window was already destroyed. */
+    if (WindowFromDC(dc) != window)
+        WARN("DC %p does not belong to window %p.\n", dc, window);
+    else if (!ReleaseDC(window, dc))
+        ERR("Failed to release device context %p, last error %#x.\n", dc, GetLastError());
+}
diff -Naur a/dlls/wined3d/vertexdeclaration.c b/dlls/wined3d/vertexdeclaration.c
--- a/dlls/wined3d/vertexdeclaration.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/vertexdeclaration.c	2013-11-07 21:40:10.000000000 +0000
@@ -48,6 +48,12 @@
     return refcount;
 }
 
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration)
+{
+    HeapFree(GetProcessHeap(), 0, declaration->elements);
+    HeapFree(GetProcessHeap(), 0, declaration);
+}
+
 ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration *declaration)
 {
     ULONG refcount = InterlockedDecrement(&declaration->ref);
@@ -56,9 +62,9 @@
 
     if (!refcount)
     {
-        HeapFree(GetProcessHeap(), 0, declaration->elements);
+        const struct wined3d_device *device = declaration->device;
         declaration->parent_ops->wined3d_object_destroyed(declaration->parent);
-        HeapFree(GetProcessHeap(), 0, declaration);
+        wined3d_cs_emit_vertex_declaration_destroy(device->cs, declaration);
     }
 
     return refcount;
diff -Naur a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
--- a/dlls/wined3d/volume.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/volume.c	2013-11-07 21:40:10.000000000 +0000
@@ -57,19 +57,6 @@
     volume->container = container;
 }
 
-static BOOL volume_prepare_system_memory(struct wined3d_volume *volume)
-{
-    if (volume->resource.heap_memory)
-        return TRUE;
-
-    if (!wined3d_resource_allocate_sysmem(&volume->resource))
-    {
-        ERR("Failed to allocate system memory.\n");
-        return FALSE;
-    }
-    return TRUE;
-}
-
 /* Context activation is done by the caller. */
 static void wined3d_volume_allocate_texture(struct wined3d_volume *volume,
         const struct wined3d_context *context, BOOL srgb)
@@ -79,7 +66,7 @@
     void *mem = NULL;
 
     if (gl_info->supported[APPLE_CLIENT_STORAGE] && !format->convert
-            && volume_prepare_system_memory(volume))
+            && wined3d_resource_prepare_system_memory(&volume->resource))
     {
         TRACE("Enabling GL_UNPACK_CLIENT_STORAGE_APPLE for volume %p\n", volume);
         gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);
@@ -101,31 +88,6 @@
     }
 }
 
-static void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch,
-        UINT *slice_pitch)
-{
-    const struct wined3d_format *format = volume->resource.format;
-
-    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
-    {
-        /* Since compressed formats are block based, pitch means the amount of
-         * bytes to the next row of block rather than the next row of pixels. */
-        UINT row_block_count = (volume->resource.width + format->block_width - 1) / format->block_width;
-        UINT slice_block_count = (volume->resource.height + format->block_height - 1) / format->block_height;
-        *row_pitch = row_block_count * format->block_byte_count;
-        *slice_pitch = *row_pitch * slice_block_count;
-    }
-    else
-    {
-        unsigned char alignment = volume->resource.device->surface_alignment;
-        *row_pitch = format->byte_count * volume->resource.width;  /* Bytes / row */
-        *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
-        *slice_pitch = *row_pitch * volume->resource.height;
-    }
-
-    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
-}
-
 /* Context activation is done by the caller. */
 void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wined3d_context *context,
         const struct wined3d_bo_address *data)
@@ -156,7 +118,7 @@
         dst_row_pitch = (dst_row_pitch + alignment - 1) & ~(alignment - 1);
         dst_slice_pitch = dst_row_pitch * height;
 
-        wined3d_volume_get_pitch(volume, &src_row_pitch, &src_slice_pitch);
+        wined3d_resource_get_pitch(&volume->resource, &src_row_pitch, &src_slice_pitch);
 
         mem = HeapAlloc(GetProcessHeap(), 0, dst_slice_pitch * depth);
         format->convert(data->addr, mem, src_row_pitch, src_slice_pitch,
@@ -184,20 +146,6 @@
         HeapFree(GetProcessHeap(), 0, mem);
 }
 
-static void wined3d_volume_validate_location(struct wined3d_volume *volume, DWORD location)
-{
-    TRACE("Volume %p, setting %s.\n", volume, wined3d_debug_location(location));
-    volume->locations |= location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
-}
-
-void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location)
-{
-    TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
-    volume->locations &= ~location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
-}
-
 /* Context activation is done by the caller. */
 static void wined3d_volume_download_data(struct wined3d_volume *volume,
         const struct wined3d_context *context, const struct wined3d_bo_address *data)
@@ -233,28 +181,8 @@
 static void wined3d_volume_evict_sysmem(struct wined3d_volume *volume)
 {
     wined3d_resource_free_sysmem(&volume->resource);
-    wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_SYSMEM);
-}
-
-static DWORD volume_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case WINED3D_LOCATION_DISCARDED:
-            return 0;
-
-        case WINED3D_LOCATION_SYSMEM:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case WINED3D_LOCATION_BUFFER:
-        case WINED3D_LOCATION_TEXTURE_RGB:
-        case WINED3D_LOCATION_TEXTURE_SRGB:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
+    volume->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
 }
 
 /* Context activation is done by the caller. */
@@ -296,20 +224,16 @@
 
     return TRUE;
 }
+
 /* Context activation is done by the caller. */
-static void wined3d_volume_load_location(struct wined3d_volume *volume,
+static void wined3d_volume_load_location(struct wined3d_resource *resource,
         struct wined3d_context *context, DWORD location)
 {
-    DWORD required_access = volume_access_from_location(location);
+    struct wined3d_volume *volume = volume_from_resource(resource);
+    DWORD required_access = wined3d_resource_access_from_location(location);
 
     TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
-        wined3d_debug_location(volume->locations));
-
-    if ((volume->locations & location) == location)
-    {
-        TRACE("Location(s) already up to date.\n");
-        return;
-    }
+        wined3d_debug_location(volume->resource.locations));
 
     if ((volume->resource.access_flags & required_access) != required_access)
     {
@@ -328,35 +252,35 @@
                     && !(volume->flags & WINED3D_VFLAG_SRGB_ALLOCATED)))
                 ERR("Trying to load (s)RGB texture without prior allocation.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
+                wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
             }
-            else if (volume->locations & WINED3D_LOCATION_SYSMEM)
+            else if (volume->resource.locations & WINED3D_LOCATION_SYSMEM)
             {
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_BUFFER)
+            else if (volume->resource.locations & WINED3D_LOCATION_BUFFER)
             {
-                struct wined3d_bo_address data = {volume->pbo, NULL};
+                struct wined3d_bo_address data = {volume->resource.buffer->name, NULL};
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, TRUE);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_SRGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_SRGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, FALSE);
             }
             else
             {
-                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->locations));
+                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, location);
+            wined3d_resource_validate_location(&volume->resource, location);
 
             if (wined3d_volume_can_evict(volume))
                 wined3d_volume_evict_sysmem(volume);
@@ -367,16 +291,11 @@
             if (!volume->resource.heap_memory)
                 ERR("Trying to load WINED3D_LOCATION_SYSMEM without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
-            {
-                TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
-            }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     volume_bind_and_dirtify(volume, context, FALSE);
                 else
                     volume_bind_and_dirtify(volume, context, TRUE);
@@ -387,26 +306,21 @@
             else
             {
                 FIXME("Implement WINED3D_LOCATION_SYSMEM loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
             break;
 
         case WINED3D_LOCATION_BUFFER:
-            if (!volume->pbo || !(volume->flags & WINED3D_VFLAG_PBO))
+            if (!volume->resource.buffer || volume->resource.map_binding != WINED3D_LOCATION_BUFFER)
                 ERR("Trying to load WINED3D_LOCATION_BUFFER without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
-                TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
-            }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
-            {
-                struct wined3d_bo_address data = {volume->pbo, NULL};
+                struct wined3d_bo_address data = {volume->resource.buffer->name, NULL};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     volume_bind_and_dirtify(volume, context, FALSE);
                 else
                     volume_bind_and_dirtify(volume, context, TRUE);
@@ -416,15 +330,15 @@
             else
             {
                 FIXME("Implement WINED3D_LOCATION_BUFFER loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_BUFFER);
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_BUFFER);
             break;
 
         default:
             FIXME("Implement %s loading from %s.\n", wined3d_debug_location(location),
-                    wined3d_debug_location(volume->locations));
+                    wined3d_debug_location(volume->resource.locations));
     }
 }
 
@@ -441,7 +355,7 @@
             volume->flags |= WINED3D_VFLAG_SRGB_ALLOCATED;
         }
 
-        wined3d_volume_load_location(volume, context, WINED3D_LOCATION_TEXTURE_SRGB);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_TEXTURE_SRGB);
     }
     else
     {
@@ -451,39 +365,10 @@
             volume->flags |= WINED3D_VFLAG_ALLOCATED;
         }
 
-        wined3d_volume_load_location(volume, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     }
 }
 
-/* Context activation is done by the caller. */
-static void wined3d_volume_prepare_pbo(struct wined3d_volume *volume, struct wined3d_context *context)
-{
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    if (volume->pbo)
-        return;
-
-    GL_EXTCALL(glGenBuffersARB(1, &volume->pbo));
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-    GL_EXTCALL(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->resource.size, NULL, GL_STREAM_DRAW_ARB));
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-    checkGLcall("Create PBO");
-
-    TRACE("Created PBO %u for volume %p.\n", volume->pbo, volume);
-}
-
-static void wined3d_volume_free_pbo(struct wined3d_volume *volume)
-{
-    struct wined3d_context *context = context_acquire(volume->resource.device, NULL);
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    TRACE("Deleting PBO %u belonging to volume %p.\n", volume->pbo, volume);
-    GL_EXTCALL(glDeleteBuffersARB(1, &volume->pbo));
-    checkGLcall("glDeleteBuffersARB");
-    volume->pbo = 0;
-    context_release(context);
-}
-
 static void volume_unload(struct wined3d_resource *resource)
 {
     struct wined3d_volume *volume = volume_from_resource(resource);
@@ -495,27 +380,18 @@
 
     TRACE("texture %p.\n", resource);
 
-    if (volume_prepare_system_memory(volume))
+    if (wined3d_resource_prepare_system_memory(&volume->resource))
     {
         context = context_acquire(device, NULL);
-        wined3d_volume_load_location(volume, context, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_SYSMEM);
         context_release(context);
-        wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_SYSMEM);
     }
     else
     {
         ERR("Out of memory when unloading volume %p.\n", volume);
-        wined3d_volume_validate_location(volume, WINED3D_LOCATION_DISCARDED);
-        wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_DISCARDED);
-    }
-
-    if (volume->pbo)
-    {
-        /* Should not happen because only dynamic default pool volumes
-         * have a buffer, and those are not evicted by device_evit_managed_resources
-         * and must be freed before a non-ex device reset. */
-        ERR("Unloading a volume with a buffer\n");
-        wined3d_volume_free_pbo(volume);
+        wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_DISCARDED);
     }
 
     /* The texture name is managed by the container. */
@@ -542,6 +418,11 @@
     return refcount;
 }
 
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume)
+{
+    HeapFree(GetProcessHeap(), 0, volume);
+}
+
 ULONG CDECL wined3d_volume_decref(struct wined3d_volume *volume)
 {
     ULONG refcount;
@@ -558,12 +439,12 @@
 
     if (!refcount)
     {
-        if (volume->pbo)
-            wined3d_volume_free_pbo(volume);
+        struct wined3d_device *device = volume->resource.device;
 
         resource_cleanup(&volume->resource);
+
         volume->resource.parent_ops->wined3d_object_destroyed(volume->resource.parent);
-        HeapFree(GetProcessHeap(), 0, volume);
+        wined3d_cs_emit_volume_cleanup(device->cs, volume);
     }
 
     return refcount;
@@ -598,34 +479,6 @@
     return &volume->resource;
 }
 
-static BOOL volume_check_block_align(const struct wined3d_volume *volume,
-        const struct wined3d_box *box)
-{
-    UINT width_mask, height_mask;
-    const struct wined3d_format *format = volume->resource.format;
-
-    if (!box)
-        return TRUE;
-
-    /* This assumes power of two block sizes, but NPOT block sizes would be
-     * silly anyway.
-     *
-     * This also assumes that the format's block depth is 1. */
-    width_mask = format->block_width - 1;
-    height_mask = format->block_height - 1;
-
-    if (box->left & width_mask)
-        return FALSE;
-    if (box->top & height_mask)
-        return FALSE;
-    if (box->right & width_mask && box->right != volume->resource.width)
-        return FALSE;
-    if (box->bottom & height_mask && box->bottom != volume->resource.height)
-        return FALSE;
-
-    return TRUE;
-}
-
 static BOOL wined3d_volume_check_box_dimensions(const struct wined3d_volume *volume,
         const struct wined3d_box *box)
 {
@@ -651,149 +504,33 @@
 HRESULT CDECL wined3d_volume_map(struct wined3d_volume *volume,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
-    struct wined3d_device *device = volume->resource.device;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    BYTE *base_memory;
+    HRESULT hr;
     const struct wined3d_format *format = volume->resource.format;
 
-    TRACE("volume %p, map_desc %p, box %p, flags %#x.\n",
-            volume, map_desc, box, flags);
-
     map_desc->data = NULL;
     if (!(volume->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
     {
         WARN("Volume %p is not CPU accessible.\n", volume);
         return WINED3DERR_INVALIDCALL;
     }
-    if (volume->resource.map_count)
-    {
-        WARN("Volume is already mapped.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
     if (!wined3d_volume_check_box_dimensions(volume, box))
     {
         WARN("Map box is invalid.\n");
         return WINED3DERR_INVALIDCALL;
     }
-    if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && !volume_check_block_align(volume, box))
+    if ((format->flags & WINED3DFMT_FLAG_BLOCKS) &&
+            !wined3d_resource_check_block_align(&volume->resource, box))
     {
         WARN("Map box is misaligned for %ux%u blocks.\n",
                 format->block_width, format->block_height);
         return WINED3DERR_INVALIDCALL;
     }
 
-    flags = wined3d_resource_sanitize_map_flags(&volume->resource, flags);
-
-    if (volume->flags & WINED3D_VFLAG_PBO)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-
-        wined3d_volume_prepare_pbo(volume, context);
-        if (flags & WINED3D_MAP_DISCARD)
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_BUFFER);
-        else
-            wined3d_volume_load_location(volume, context, WINED3D_LOCATION_BUFFER);
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-
-        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-        {
-            GLbitfield mapflags = wined3d_resource_gl_map_flags(flags);
-            mapflags &= ~GL_MAP_FLUSH_EXPLICIT_BIT;
-            base_memory = GL_EXTCALL(glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB,
-                    0, volume->resource.size, mapflags));
-        }
-        else
-        {
-            GLenum access = wined3d_resource_gl_legacy_map_flags(flags);
-            base_memory = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, access));
-        }
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Map PBO");
-
-        context_release(context);
-    }
-    else
-    {
-        if (!volume_prepare_system_memory(volume))
-        {
-            WARN("Out of memory.\n");
-            map_desc->data = NULL;
-            return E_OUTOFMEMORY;
-        }
-
-        if (flags & WINED3D_MAP_DISCARD)
-        {
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
-        }
-        else if (!(volume->locations & WINED3D_LOCATION_SYSMEM))
-        {
-            context = context_acquire(device, NULL);
-            wined3d_volume_load_location(volume, context, WINED3D_LOCATION_SYSMEM);
-            context_release(context);
-        }
-        base_memory = volume->resource.heap_memory;
-    }
-
-    TRACE("Base memory pointer %p.\n", base_memory);
-
-    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
-    {
-        map_desc->row_pitch = volume->resource.width * format->byte_count;
-        map_desc->slice_pitch = map_desc->row_pitch * volume->resource.height;
-    }
-    else
-    {
-        wined3d_volume_get_pitch(volume, &map_desc->row_pitch, &map_desc->slice_pitch);
-    }
-
-    if (!box)
-    {
-        TRACE("No box supplied - all is ok\n");
-        map_desc->data = base_memory;
-    }
-    else
-    {
-        TRACE("Lock Box (%p) = l %u, t %u, r %u, b %u, fr %u, ba %u\n",
-                box, box->left, box->top, box->right, box->bottom, box->front, box->back);
-
-        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
-        {
-            /* Compressed textures are block based, so calculate the offset of
-             * the block that contains the top-left pixel of the locked rectangle. */
-            map_desc->data = base_memory
-                    + (box->front * map_desc->slice_pitch)
-                    + ((box->top / format->block_height) * map_desc->row_pitch)
-                    + ((box->left / format->block_width) * format->block_byte_count);
-        }
-        else
-        {
-            map_desc->data = base_memory
-                    + (map_desc->slice_pitch * box->front)
-                    + (map_desc->row_pitch * box->top)
-                    + (box->left * volume->resource.format->byte_count);
-        }
-    }
-
-    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
-    {
-        wined3d_texture_set_dirty(volume->container);
-
-        if (volume->flags & WINED3D_VFLAG_PBO)
-            wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_BUFFER);
-        else
-            wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_SYSMEM);
-    }
-
-    volume->resource.map_count++;
-
-    TRACE("Returning memory %p, row pitch %d, slice pitch %d.\n",
-            map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
+    hr = wined3d_resource_map(&volume->resource, map_desc, box, flags);
+    if (FAILED(hr))
+        return hr;
 
-    return WINED3D_OK;
+    return hr;
 }
 
 struct wined3d_volume * CDECL wined3d_volume_from_resource(struct wined3d_resource *resource)
@@ -803,36 +540,25 @@
 
 HRESULT CDECL wined3d_volume_unmap(struct wined3d_volume *volume)
 {
-    TRACE("volume %p.\n", volume);
-
-    if (!volume->resource.map_count)
-    {
-        WARN("Trying to unlock an unlocked volume %p.\n", volume);
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (volume->flags & WINED3D_VFLAG_PBO)
-    {
-        struct wined3d_device *device = volume->resource.device;
-        struct wined3d_context *context = context_acquire(device, NULL);
-        const struct wined3d_gl_info *gl_info = context->gl_info;
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-        GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Unmap PBO");
+    if (volume->resource.unmap_dirtify)
+        wined3d_texture_set_dirty(volume->container);
 
-        context_release(context);
-    }
+    return wined3d_resource_unmap(&volume->resource);
+}
 
-    volume->resource.map_count--;
+static void wined3d_volume_changed(struct wined3d_resource *resource)
+{
+    struct wined3d_volume *volume = volume_from_resource(resource);
 
-    return WINED3D_OK;
+    if (volume->container)
+        wined3d_texture_set_dirty(volume->container);
 }
 
 static const struct wined3d_resource_ops volume_resource_ops =
 {
     volume_unload,
+    wined3d_volume_load_location,
+    wined3d_volume_changed,
 };
 
 static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_device *device, UINT width,
@@ -870,14 +596,16 @@
     }
 
     volume->texture_level = level;
-    volume->locations = WINED3D_LOCATION_DISCARDED;
+    volume->resource.locations = WINED3D_LOCATION_DISCARDED;
+    volume->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
     if (pool == WINED3D_POOL_DEFAULT && usage & WINED3DUSAGE_DYNAMIC
             && gl_info->supported[ARB_PIXEL_BUFFER_OBJECT]
             && !format->convert)
     {
         wined3d_resource_free_sysmem(&volume->resource);
-        volume->flags |= WINED3D_VFLAG_PBO;
+        volume->resource.map_binding = WINED3D_LOCATION_BUFFER;
+        volume->resource.map_heap_memory = NULL;
     }
 
     return WINED3D_OK;
diff -Naur a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
--- a/dlls/wined3d/wined3d.spec	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/wined3d.spec	2013-11-07 21:40:10.000000000 +0000
@@ -177,6 +177,7 @@
 @ cdecl wined3d_resource_get_parent(ptr)
 @ cdecl wined3d_resource_get_private_data(ptr ptr ptr ptr)
 @ cdecl wined3d_resource_set_private_data(ptr ptr ptr long long)
+@ cdecl wined3d_resource_get_pitch(ptr ptr ptr)
 
 @ cdecl wined3d_rendertarget_view_create(ptr ptr ptr)
 @ cdecl wined3d_rendertarget_view_decref(ptr)
@@ -214,7 +215,6 @@
 @ cdecl wined3d_surface_get_overlay_position(ptr ptr ptr)
 @ cdecl wined3d_surface_get_palette(ptr)
 @ cdecl wined3d_surface_get_parent(ptr)
-@ cdecl wined3d_surface_get_pitch(ptr)
 @ cdecl wined3d_surface_get_priority(ptr)
 @ cdecl wined3d_surface_get_render_target_data(ptr ptr)
 @ cdecl wined3d_surface_get_resource(ptr)
diff -Naur a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
--- a/dlls/wined3d/wined3d_main.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/wined3d_main.c	2013-11-07 21:40:10.000000000 +0000
@@ -72,7 +72,7 @@
  * where appropriate. */
 struct wined3d_settings wined3d_settings =
 {
-    TRUE,           /* Use of GLSL enabled by default */
+    GLSL_AUTO,      /* GLSL autodetect by default */
     ORM_FBO,        /* Use FBOs to do offscreen rendering */
     PCI_VENDOR_NONE,/* PCI Vendor ID */
     PCI_DEVICE_NONE,/* PCI Device ID */
@@ -85,6 +85,21 @@
     ~0U,            /* No GS shader model limit by default. */
     ~0U,            /* No PS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+    TRUE,           /* No multithreaded CS by default. */
+};
+
+/* CXGames hacks, not in the main wined3d configuration settings */
+struct cxgames_hacks cxgames_hacks =
+{
+    FALSE,                      /* enable_slow_blit */
+    CLIENTSTORAGE_ENABLE,       /* allow_apple_client_storage */
+    0,                          /* max_vertex_blend_matrices */
+    FALSE,                      /* safe_vs_consts */
+    0,                          /* fixed_vs_constants_limit */
+    NULL,                       /* No extensions disabled by default */
+    FALSE,                      /* Use the absolute value of the POW arguments in ARB */
+    FALSE,                      /* INTZ not blacklisted by default */
+    WINED3D_MAPBUF_STATIC_NV,   /* Don't use glMapBuffer on dynamic buffers with NV threading */
 };
 
 struct wined3d * CDECL wined3d_create(UINT version, DWORD flags)
@@ -195,6 +210,12 @@
             if (RegOpenKeyA( tmpkey, appname, &appkey )) appkey = 0;
             RegCloseKey( tmpkey );
         }
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"disabled"))
+        {
+            TRACE("Disabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = FALSE;
+        }
     }
 
     if (hkey || appkey)
@@ -205,7 +226,33 @@
             {
                 ERR_(winediag)("The GLSL shader backend has been disabled. You get to keep all the pieces if it breaks.\n");
                 TRACE("Use of GL Shading Language disabled\n");
-                wined3d_settings.glslRequested = FALSE;
+                wined3d_settings.glslRequested = GLSL_DISABLED;
+            }
+            if (!strcmp(buffer,"enabled"))
+            {
+                TRACE("Use of GL Shading Language enabled\n");
+                wined3d_settings.glslRequested = GLSL_ENABLED;
+            }
+        }
+        if ( !get_config_key( hkey, appkey, "hl2_disable_glsl", buffer, size) )
+        {
+            /* This allows disabling GLSL for single HL2 mods(they all use hl2.exe).
+             * It is important that this key is evaluated *after* the UseGLS one,
+             * otherwise the useGLSL key may overwrite decisions made here
+             */
+            char *token;
+            LPSTR cmdline;
+            cmdline = GetCommandLineA();
+            TRACE("Checking command line for disabling GLSL per HL2 mod\n");
+            token = strtok(buffer, ";");
+            while(token) {
+                TRACE("Looking for \"%s\"\n", token);
+                if(strstr(cmdline, token)) {
+                    TRACE("Disabling GLSL for this HL2 mod\n");
+                    wined3d_settings.glslRequested = GLSL_DISABLED;
+                    break;
+                }
+                token = strtok(NULL, ";");
             }
         }
         if ( !get_config_key( hkey, appkey, "OffscreenRenderingMode", buffer, size) )
@@ -264,6 +311,14 @@
             else
                 ERR("VideoMemorySize is %i but must be >0\n", TmpVideoMemorySize);
         }
+        if ( !get_config_key( hkey, appkey, "enable_slow_blit", buffer, size) )
+        {
+            if (!strcmp(buffer,"enable"))
+            {
+                TRACE("Enabling slow pixel per pixel blits\n");
+                cxgames_hacks.enable_slow_blit = TRUE;
+            }
+        }
         if ( !get_config_key( hkey, appkey, "WineLogo", buffer, size) )
         {
             size_t len = strlen(buffer) + 1;
@@ -286,6 +341,44 @@
             TRACE("Enforcing strict draw ordering.\n");
             wined3d_settings.strict_draw_ordering = TRUE;
         }
+        if ( !get_config_key( hkey, appkey, "allow_apple_client_storage", buffer, size) )
+        {
+            if (!strcmp(buffer,"disable"))
+            {
+                TRACE("Disabling GL_APPLE_CLIENT_STORAGE.\n");
+                cxgames_hacks.allow_apple_client_storage = CLIENTSTORAGE_DISABLE;
+            }
+            else if(!strcmp(buffer,"disable_nvidia_gf7"))
+            {
+                TRACE("Disabling GL_APPLE_CLIENT_STORAGE on non-gf8 nvidia cards.\n");
+                cxgames_hacks.allow_apple_client_storage = CLIENTSTORAGE_DISABLE_NVIDIA_GF7;
+            }
+        }
+        if (!get_config_key_dword(hkey, appkey, "MaxVertexBlendMatrices", &tmpvalue))
+        {
+            TRACE("Using %u for MaxVertexBlendMatrices.\n", tmpvalue);
+            cxgames_hacks.max_vertex_blend_matrices = tmpvalue;
+        }
+        if ( !get_config_key( hkey, appkey, "SafeVsConsts", buffer, size) )
+        {
+            if (!strcmp(buffer,"enable"))
+            {
+                TRACE("Advertising only always available shader constants\n");
+                cxgames_hacks.safe_vs_consts = TRUE;
+            }
+        }
+        /* CodeWeavers HACK bug 10104 - Allow a registry key to dictate the number of vertex constants. */
+        if (!get_config_key(hkey, appkey, "fixed_vs_constants_limit", buffer, size))
+        {
+            int constants = atoi(buffer);
+            if (constants >= 0)
+            {
+                cxgames_hacks.fixed_vs_constants_limit = constants;
+                TRACE("Fixing # of GLSL vs constants at %d.\n", constants);
+            }
+            else
+                ERR("fixed_vs_constants_limit must be >= 0.\n");
+        }
         if (!get_config_key(hkey, appkey, "AlwaysOffscreen", buffer, size)
                 && !strcmp(buffer,"disabled"))
         {
@@ -304,6 +397,58 @@
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+        /* CodeWeavers Hack bug 5501 - Allow registry disabling of OpenGL extensions. */
+        if (!get_config_key(hkey, appkey, "DisabledExtensions", buffer, size))
+        {
+            size_t size = strlen(buffer) + 1;
+            cxgames_hacks.disabled_extensions = HeapAlloc(GetProcessHeap(), 0, size);
+            if (cxgames_hacks.disabled_extensions)
+                memcpy(cxgames_hacks.disabled_extensions, buffer, size);
+        }
+        if (!get_config_key( hkey, appkey, "pow_abs", buffer, size) )
+        {
+            if (!strcmp(buffer,"disabled"))
+            {
+                TRACE("Disabling the ABS operator on POW src arguments in ARB.\n");
+                cxgames_hacks.no_pow_abs = TRUE;
+            }
+        }
+        if (!get_config_key(hkey, appkey, "NoINTZ", buffer, size))
+        {
+            if (!strcmp(buffer, "enabled"))
+            {
+                TRACE("Disabling INTZ support.\n");
+                cxgames_hacks.no_intz = TRUE;
+            }
+        }
+        if (!get_config_key(hkey, appkey, "AllowGlMapBuffer", buffer, size))
+        {
+            if (!strcmp(buffer, "always"))
+            {
+                TRACE("Always using glMapBuffer if possible.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_ALWAYS;
+            }
+            else if (!strcmp(buffer, "static"))
+            {
+                TRACE("Using glMapBuffer only for static buffers.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_STATIC;
+            }
+            else if (!strcmp(buffer, "never"))
+            {
+                TRACE("Never using glMapBuffer.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_NEVER;
+            }
+            else if (!strcmp(buffer, "never_nv"))
+            {
+                TRACE("Never using glMapBuffer if NVidia's threaded optimizations are used.\n");
+                cxgames_hacks.allow_glmapbuffer = WINED3D_MAPBUF_NEVER_NV;
+            }
+            else
+            {
+                TRACE("Using glMapBuffer only for static buffers\n");
+                TRACE("if NVidia's threaded optimizations are used.\n");
+            }
+        }
     }
 
     if (appkey) RegCloseKey( appkey );
@@ -336,6 +481,7 @@
     HeapFree(GetProcessHeap(), 0, wndproc_table.entries);
 
     HeapFree(GetProcessHeap(), 0, wined3d_settings.logo);
+    HeapFree(GetProcessHeap(), 0, cxgames_hacks.disabled_extensions);
     UnregisterClassA(WINED3D_OPENGL_WINDOW_CLASS_NAME, hInstDLL);
 
     DeleteCriticalSection(&wined3d_wndproc_cs);
diff -Naur a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/wined3d/wined3d_private.h	2013-11-07 21:40:10.000000000 +0000
@@ -31,6 +31,7 @@
 #define WINE_GLAPI
 #endif
 
+#include <assert.h>
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -64,6 +65,14 @@
 #define WINED3D_QUIRK_LIMITED_TEX_FILTERING     0x00000100
 #define WINED3D_QUIRK_BROKEN_ARB_FOG            0x00000200
 
+#define WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER    0x00010000
+#define WINED3D_CX_QUIRK_COMPRESSED_CUBE_MIP    0x00020000
+#define WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN       0x00040000
+#define WINED3D_CX_QUIRK_TEXCOORD_FOG           0x00080000
+#define WINED3D_CX_QUIRK_BROKEN_ARA             0x00100000
+#define WINED3D_CX_QUIRK_BLIT                   0x00200000
+#define WINED3D_CX_QUIRK_RENDER_TO_FBO          0x00800000
+
 /* Texture format fixups */
 
 enum fixup_channel_source
@@ -244,6 +253,13 @@
 #define PCI_VENDOR_NONE 0xffff /* e.g. 0x8086 for Intel and 0x10de for Nvidia */
 #define PCI_DEVICE_NONE 0xffff /* e.g. 0x14f for a Geforce6200 */
 
+enum glsl_mode
+{
+    GLSL_DISABLED,
+    GLSL_ENABLED,
+    GLSL_AUTO
+};
+
 /* NOTE: When adding fields to this structure, make sure to update the default
  * values in wined3d_main.c as well. */
 struct wined3d_settings
@@ -251,7 +267,7 @@
     /* Ideally, we don't want the user to have to request GLSL. If the
      * hardware supports GLSL, we should use it. However, until it's fully
      * implemented, we'll leave it as a registry setting for developers. */
-    BOOL glslRequested;
+    enum glsl_mode glslRequested;
     int offscreen_rendering_mode;
     unsigned short pci_vendor_id;
     unsigned short pci_device_id;
@@ -265,10 +281,41 @@
     unsigned int max_sm_gs;
     unsigned int max_sm_ps;
     BOOL no_3d;
+    BOOL cs_multithreaded;
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
 
+#define CLIENTSTORAGE_DISABLE 0
+#define CLIENTSTORAGE_DISABLE_NVIDIA_GF7 1
+#define CLIENTSTORAGE_ENABLE 2
+
+enum wined3d_map_buffer_mode
+{
+    WINED3D_MAPBUF_ALWAYS,
+    WINED3D_MAPBUF_STATIC,
+    WINED3D_MAPBUF_NEVER,
+    WINED3D_MAPBUF_STATIC_NV,
+    WINED3D_MAPBUF_NEVER_NV
+};
+
+struct cxgames_hacks
+{
+    BOOL enable_slow_blit;
+    int allow_apple_client_storage;
+    UINT max_vertex_blend_matrices;
+    BOOL safe_vs_consts;
+    /* CodeWeavers Hack bug 10104 - Allow registry to fix vs constants. */
+    UINT fixed_vs_constants_limit;
+    /* CodeWeavers Hack bug 5501 - Allow registry disabling of OpenGL extensions. */
+    char *disabled_extensions;
+    BOOL no_pow_abs;
+    BOOL no_intz;
+    enum wined3d_map_buffer_mode allow_glmapbuffer;
+};
+
+extern struct cxgames_hacks cxgames_hacks DECLSPEC_HIDDEN;
+
 enum wined3d_sampler_texture_type
 {
     WINED3DSTT_UNKNOWN = 0,
@@ -781,6 +828,8 @@
        D3D9 has a limit of 16 samplers and the fixup is superfluous
        in D3D10 (unconditional NP2 support mandatory). */
     WORD shadow; /* MAX_FRAGMENT_SAMPLERS, 16 */
+    /* Emulate clipping via KIL / discard. use a WORD for alignment */
+    WORD                        clip;
 };
 
 enum fog_src_type {
@@ -934,8 +983,9 @@
     WORD use_map; /* MAX_ATTRIBS, 16 */
 };
 
-void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed) DECLSPEC_HIDDEN;
 DWORD get_flexible_vertex_size(DWORD d3dvtVertexType) DECLSPEC_HIDDEN;
 
 #define eps 1e-8
@@ -1014,6 +1064,8 @@
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+    DWORD samples;
+    BOOL started;
 };
 
 union wined3d_gl_query_object
@@ -1044,6 +1096,36 @@
 void wined3d_event_query_issue(struct wined3d_event_query *query, const struct wined3d_device *device) DECLSPEC_HIDDEN;
 BOOL wined3d_event_query_supported(const struct wined3d_gl_info *gl_info) DECLSPEC_HIDDEN;
 
+struct wined3d_fb_state
+{
+    struct wined3d_surface **render_targets;
+    struct wined3d_surface *depth_stencil;
+    UINT rt_size;
+};
+
+static inline BOOL wined3d_fb_equal(const struct wined3d_fb_state *fb1, const struct wined3d_fb_state *fb2)
+{
+    UINT i;
+
+    if (fb1->depth_stencil != fb2->depth_stencil)
+        return FALSE;
+    if (fb1->rt_size != fb2->rt_size)
+        return FALSE;
+    for (i = 0; i < fb1->rt_size; i++)
+        if (fb1->render_targets[i] != fb2->render_targets[i])
+            return FALSE;
+    return TRUE;
+}
+
+static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wined3d_fb_state *src)
+{
+    UINT i;
+
+    dst->depth_stencil = src->depth_stencil;
+    for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
+        dst->render_targets[i] = src->render_targets[i];
+}
+
 struct wined3d_context
 {
     const struct wined3d_gl_info *gl_info;
@@ -1058,6 +1140,7 @@
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+    struct wined3d_fb_state current_fb;
 
     struct wined3d_swapchain *swapchain;
     struct wined3d_surface *current_rt;
@@ -1146,12 +1229,8 @@
     GLfloat                 fog_coord_value;
     GLfloat                 color[4], fogstart, fogend, fogcolor[4];
     GLuint                  dummy_arbfp_prog;
-};
 
-struct wined3d_fb_state
-{
-    struct wined3d_surface **render_targets;
-    struct wined3d_surface *depth_stencil;
+    GLenum                  offscreenBuffer;
 };
 
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
@@ -1279,7 +1358,8 @@
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_device *device,
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
-BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device) DECLSPEC_HIDDEN;
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state) DECLSPEC_HIDDEN;
 void context_apply_fbo_state_blit(struct wined3d_context *context, GLenum target,
         struct wined3d_surface *render_target, struct wined3d_surface *depth_stencil, DWORD location) DECLSPEC_HIDDEN;
 void context_active_texture(struct wined3d_context *context, const struct wined3d_gl_info *gl_info,
@@ -1806,7 +1886,7 @@
 struct wined3d_state
 {
     DWORD flags;
-    const struct wined3d_fb_state *fb;
+    struct wined3d_fb_state fb;
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -1848,6 +1928,14 @@
     DWORD render_states[WINEHIGHEST_RENDER_STATE + 1];
 };
 
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -1902,15 +1990,11 @@
 
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
+    struct wined3d_surface *auto_depth_stencil;
 
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
 
-    /* Render Target Support */
-    struct wined3d_fb_state fb;
-    struct wined3d_surface *onscreen_depth_stencil;
-    struct wined3d_surface *auto_depth_stencil;
-
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
 
@@ -1920,7 +2004,6 @@
     UINT                    xScreenSpace;
     UINT                    yScreenSpace;
     UINT                    cursorWidth, cursorHeight;
-    GLuint                  cursorTexture;
     HCURSOR                 hardwareCursor;
 
     /* The Wine logo surface */
@@ -1952,9 +2035,17 @@
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
-void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
-        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask) DECLSPEC_HIDDEN;
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_delete_opengl_contexts_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -1970,12 +2061,20 @@
         context_invalidate_state(context, STATE_SAMPLER(sampler));
 }
 
+static inline BOOL wined3d_use_csmt(const struct wined3d_device *device)
+{
+    return wined3d_settings.cs_multithreaded && !(device->wined3d->flags & WINED3D_NO_CSMT);
+}
+
 #define WINED3D_RESOURCE_ACCESS_GPU     0x1
 #define WINED3D_RESOURCE_ACCESS_CPU     0x2
 
 struct wined3d_resource_ops
 {
     void (*resource_unload)(struct wined3d_resource *resource);
+    void (*resource_load_location)(struct wined3d_resource *resource,
+            struct wined3d_context *context, DWORD location);
+    void (*resource_changed)(struct wined3d_resource *resource);
 };
 
 struct wined3d_resource
@@ -1997,9 +2096,17 @@
     UINT size;
     DWORD priority;
     BYTE *allocatedMemory; /* Pointer to the real data location */
-    void *heap_memory;
     struct list privateData;
     struct list resource_list_entry;
+    LONG access_fence;
+
+    DWORD locations, map_binding;
+    void *heap_memory, *map_heap_memory;
+    void *user_memory;
+    void *dib_memory;
+    BOOL unmap_dirtify;
+    struct wined3d_gl_bo *buffer, *map_buffer;
+    UINT custom_row_pitch, custom_slice_pitch;
 
     void *parent;
     const struct wined3d_parent_ops *parent_ops;
@@ -2017,11 +2124,52 @@
 DWORD resource_set_priority(struct wined3d_resource *resource, DWORD priority) DECLSPEC_HIDDEN;
 void resource_unload(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void *wined3d_resource_allocate_sysmem2(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_resource_free_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource,
         DWORD flags) DECLSPEC_HIDDEN;
 GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
-GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
+void wined3d_resource_validate_location(struct wined3d_resource *resource,
+        DWORD location) DECLSPEC_HIDDEN;
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource,
+        DWORD location) DECLSPEC_HIDDEN;
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+DWORD wined3d_resource_access_from_location(DWORD location) DECLSPEC_HIDDEN;
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_map(struct wined3d_resource *resource, struct wined3d_map_desc *map_desc,
+        const struct wined3d_box *box, DWORD flags) DECLSPEC_HIDDEN;
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_changed(struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+
+static inline void wined3d_resource_inc_fence(struct wined3d_resource *resource)
+{
+    InterlockedIncrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_dec_fence(struct wined3d_resource *resource)
+{
+    InterlockedDecrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_wait_fence(struct wined3d_resource *resource)
+{
+    while(InterlockedCompareExchange(&resource->access_fence, 0, 0));
+}
 
 /* Tests show that the start address of resources is 32 byte aligned */
 #define RESOURCE_ALIGNMENT 16
@@ -2105,17 +2253,22 @@
         const DWORD samplerStates[WINED3D_HIGHEST_SAMPLER_STATE + 1],
         const struct wined3d_gl_info *gl_info) DECLSPEC_HIDDEN;
 void wined3d_texture_set_dirty(struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 
-#define WINED3D_VFLAG_ALLOCATED         0x00000001
-#define WINED3D_VFLAG_SRGB_ALLOCATED    0x00000002
-#define WINED3D_VFLAG_PBO               0x00000004
-#define WINED3D_VFLAG_CLIENT_STORAGE    0x00000008
-
-#define WINED3D_LOCATION_DISCARDED      0x00000001
-#define WINED3D_LOCATION_SYSMEM         0x00000002
-#define WINED3D_LOCATION_BUFFER         0x00000004
-#define WINED3D_LOCATION_TEXTURE_RGB    0x00000008
-#define WINED3D_LOCATION_TEXTURE_SRGB   0x00000010
+#define WINED3D_VFLAG_ALLOCATED             0x00000001
+#define WINED3D_VFLAG_SRGB_ALLOCATED        0x00000002
+#define WINED3D_VFLAG_CLIENT_STORAGE        0x00000004
+
+#define WINED3D_LOCATION_DISCARDED          0x00000001
+#define WINED3D_LOCATION_SYSMEM             0x00000002
+#define WINED3D_LOCATION_BUFFER             0x00000004
+#define WINED3D_LOCATION_TEXTURE_RGB        0x00000008
+#define WINED3D_LOCATION_TEXTURE_SRGB       0x00000010
+#define WINED3D_LOCATION_DRAWABLE           0x00000020
+#define WINED3D_LOCATION_RB_MULTISAMPLE     0x00000040
+#define WINED3D_LOCATION_RB_RESOLVED        0x00000080
+#define WINED3D_LOCATION_USER               0x00000100
+#define WINED3D_LOCATION_DIB                0x00000200
 
 const char *wined3d_debug_location(DWORD location) DECLSPEC_HIDDEN;
 
@@ -2124,10 +2277,9 @@
     struct wined3d_resource resource;
     struct wined3d_texture *container;
 
-    DWORD flags, locations;
+    DWORD flags;
     GLint texture_level;
     DWORD download_count;
-    GLuint pbo;
 };
 
 static inline struct wined3d_volume *volume_from_resource(struct wined3d_resource *resource)
@@ -2137,14 +2289,13 @@
 
 void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context, BOOL srgb_mode) DECLSPEC_HIDDEN;
 void volume_set_container(struct wined3d_volume *volume, struct wined3d_texture *container) DECLSPEC_HIDDEN;
-void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wined3d_context *context,
         const struct wined3d_bo_address *data) DECLSPEC_HIDDEN;
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
 
 struct wined3d_surface_dib
 {
     HBITMAP DIBsection;
-    void *bitmap_data;
     UINT bitmap_size;
 };
 
@@ -2171,8 +2322,7 @@
 {
     HRESULT (*surface_private_setup)(struct wined3d_surface *surface);
     void (*surface_realize_palette)(struct wined3d_surface *surface);
-    void (*surface_map)(struct wined3d_surface *surface, const RECT *rect, DWORD flags);
-    void (*surface_unmap)(struct wined3d_surface *surface);
+    void (*surface_frontbuffer_updated)(struct wined3d_surface *surface);
 };
 
 struct wined3d_surface
@@ -2186,15 +2336,12 @@
 
     DWORD flags;
 
-    UINT pitch;
     UINT pow2Width;
     UINT pow2Height;
 
     /* A method to retrieve the drawable size. Not in the Vtable to make it changeable */
     void (*get_drawable_size)(const struct wined3d_context *context, UINT *width, UINT *height);
 
-    /* PBO */
-    GLuint                    pbo;
     GLuint rb_multisample;
     GLuint rb_resolved;
     GLuint texture_name;
@@ -2203,7 +2350,6 @@
     GLenum texture_target;
 
     RECT                      lockedRect;
-    RECT                      dirtyRect;
     int                       lockCount;
 
     /* For GetDC */
@@ -2249,13 +2395,11 @@
 GLenum surface_get_gl_buffer(const struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 void surface_internal_preload(struct wined3d_surface *surface,
         struct wined3d_context *context, enum WINED3DSRGB srgb) DECLSPEC_HIDDEN;
-void surface_invalidate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 BOOL surface_is_offscreen(const struct wined3d_surface *surface) DECLSPEC_HIDDEN;
-HRESULT surface_load(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
+HRESULT surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void surface_load_ds_location(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
-HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location, const RECT *rect) DECLSPEC_HIDDEN;
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void surface_prepare_rb(struct wined3d_surface *surface,
         const struct wined3d_gl_info *gl_info, BOOL multisample) DECLSPEC_HIDDEN;
@@ -2271,7 +2415,12 @@
 void surface_update_draw_binding(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
         struct wined3d_surface *src_surface, const RECT *src_rect) DECLSPEC_HIDDEN;
-void surface_validate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
+BOOL wined3d_surface_prepare_dib(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect) DECLSPEC_HIDDEN;
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 
 void get_drawable_size_swapchain(const struct wined3d_context *context, UINT *width, UINT *height) DECLSPEC_HIDDEN;
 void get_drawable_size_backbuffer(const struct wined3d_context *context, UINT *width, UINT *height) DECLSPEC_HIDDEN;
@@ -2279,7 +2428,7 @@
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
-void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
+void surface_flip(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
 
 /* Surface flags: */
 #define SFLAG_CONVERTED         0x00000001 /* Converted for color keying or palettized. */
@@ -2292,42 +2441,27 @@
 #define SFLAG_LOST              0x00000080 /* Surface lost flag for ddraw. */
 #define SFLAG_GLCKEY            0x00000100 /* The GL texture was created with a color key. */
 #define SFLAG_CLIENT            0x00000200 /* GL_APPLE_client_storage is used with this surface. */
-#define SFLAG_INOVERLAYDRAW     0x00000400 /* Overlay drawing is in progress. Recursion prevention. */
-#define SFLAG_DIBSECTION        0x00000800 /* Has a DIB section attached for GetDC. */
-#define SFLAG_USERPTR           0x00001000 /* The application allocated the memory for this surface. */
-#define SFLAG_ALLOCATED         0x00002000 /* A GL texture is allocated for this surface. */
-#define SFLAG_SRGBALLOCATED     0x00004000 /* A sRGB GL texture is allocated for this surface. */
-#define SFLAG_PBO               0x00008000 /* The surface has a PBO. */
-#define SFLAG_INSYSMEM          0x00010000 /* The system memory copy is current. */
-#define SFLAG_INTEXTURE         0x00020000 /* The GL texture is current. */
-#define SFLAG_INSRGBTEX         0x00040000 /* The GL sRGB texture is current. */
-#define SFLAG_INDRAWABLE        0x00080000 /* The GL drawable is current. */
-#define SFLAG_INRB_MULTISAMPLE  0x00100000 /* The multisample renderbuffer is current. */
-#define SFLAG_INRB_RESOLVED     0x00200000 /* The resolved renderbuffer is current. */
-#define SFLAG_DISCARDED         0x00400000 /* Surface was discarded, allocating new location is enough. */
+#define SFLAG_DIBSECTION        0x00000400 /* Has a DIB section attached for GetDC. */
+#define SFLAG_USERPTR           0x00000800 /* The application allocated the memory for this surface. */
+#define SFLAG_ALLOCATED         0x00001000 /* A GL texture is allocated for this surface. */
+#define SFLAG_SRGBALLOCATED     0x00002000 /* A sRGB GL texture is allocated for this surface. */
+#define SFLAG_CLIENT_SRGB       0x10000000 /* GL_APPLE_client_storage is used on that texture */
 
 /* In some conditions the surface memory must not be freed:
  * SFLAG_CONVERTED: Converting the data back would take too long
  * SFLAG_DIBSECTION: The dib code manages the memory
  * SFLAG_DYNLOCK: Avoid freeing the data for performance
  * SFLAG_PBO: PBOs don't use 'normal' memory. It is either allocated by the driver or must be NULL.
- * SFLAG_CLIENT: OpenGL uses our memory as backup
+ * SFLAG_CLIENT(_SRGB): OpenGL uses our memory as backup
  */
 #define SFLAG_DONOTFREE     (SFLAG_CONVERTED        | \
                              SFLAG_DYNLOCK          | \
                              SFLAG_CLIENT           | \
                              SFLAG_DIBSECTION       | \
                              SFLAG_USERPTR          | \
-                             SFLAG_PBO              | \
+                             SFLAG_CLIENT_SRGB      | \
                              SFLAG_PIN_SYSMEM)
 
-#define SFLAG_LOCATIONS     (SFLAG_INSYSMEM         | \
-                             SFLAG_INTEXTURE        | \
-                             SFLAG_INSRGBTEX        | \
-                             SFLAG_INDRAWABLE       | \
-                             SFLAG_INRB_MULTISAMPLE | \
-                             SFLAG_INRB_RESOLVED)
-
 enum wined3d_conversion_type
 {
     WINED3D_CT_NONE,
@@ -2374,6 +2508,8 @@
     BOOL half_float_conv_needed;
 };
 
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+
 struct wined3d_saved_states
 {
     DWORD transform[(HIGHEST_TRANSFORMSTATE >> 5) + 1];
@@ -2441,30 +2577,56 @@
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
-HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
-        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
-        DWORD flags) DECLSPEC_HIDDEN;
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
 void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
 
+struct wined3d_cs_list
+{
+    struct list blocks;
+};
+
+#define WINED3D_CS_QUEUE_SIZE 0x100000
+#define WINED3D_CS_SPIN_COUNT 10000000
+
+struct wined3d_cs_queue
+{
+    LONG head, tail;
+    BYTE data[WINED3D_CS_QUEUE_SIZE];
+};
+
 struct wined3d_cs_ops
 {
     void *(*require_space)(struct wined3d_cs *cs, size_t size);
-    void (*submit)(struct wined3d_cs *cs);
+    void *(*require_space_prio)(struct wined3d_cs *cs, size_t size);
+    void (*submit)(struct wined3d_cs *cs, size_t size);
+    void (*submit_prio)(struct wined3d_cs *cs, size_t size);
+    void (*finish)(struct wined3d_cs *cs);
+    void (*finish_prio)(struct wined3d_cs *cs);
 };
 
 struct wined3d_cs
 {
     const struct wined3d_cs_ops *ops;
     struct wined3d_device *device;
-    struct wined3d_fb_state fb;
     struct wined3d_state state;
+    HANDLE thread;
+    DWORD thread_id;
+    struct wined3d_surface *onscreen_depth_stencil;
 
-    size_t data_size;
-    void *data;
+    struct wined3d_cs_queue queue, prio_queue;
+
+    LONG pending_presents;
+    struct list query_poll_list;
+
+    HANDLE event;
+    BOOL waiting_for_event;
 };
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
@@ -2506,6 +2668,65 @@
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register, const float *constants,
+        UINT vector4f_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_reset_state(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs,
+        GLenum primitive_type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_color_fill(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        const RECT *rect, const struct wined3d_color *color) DECLSPEC_HIDDEN;
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        BYTE *mem) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_get_data(struct wined3d_cs *cs, struct wined3d_query *query, void *data,
+        UINT data_size, DWORD flags, HRESULT *ret) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src,
+        const RECT *src_rect, struct wined3d_surface *dst, const POINT *dst_point) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_flip(struct wined3d_cs *cs, struct wined3d_surface *surface,
+        struct wined3d_surface *override) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs,
+        struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 /* Direct3D terminology with little modifications. We do not have an issued state
  * because only the driver knows about it, but we have a created state because d3d
@@ -2520,7 +2741,8 @@
 struct wined3d_query_ops
 {
     HRESULT (*query_get_data)(struct wined3d_query *query, void *data, DWORD data_size, DWORD flags);
-    HRESULT (*query_issue)(struct wined3d_query *query, DWORD flags);
+    BOOL (*query_poll)(struct wined3d_query *query);
+    BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
 };
 
 struct wined3d_query
@@ -2532,8 +2754,13 @@
     enum wined3d_query_type type;
     DWORD data_size;
     void                     *extendedData;
+
+    LONG                     counter_main, counter_retrieved;
+    struct list              poll_list_entry;
 };
 
+void wined3d_query_destroy(struct wined3d_query *query) DECLSPEC_HIDDEN;
+
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
 enum wined3d_buffer_conversion_type
@@ -2552,6 +2779,7 @@
 struct wined3d_buffer
 {
     struct wined3d_resource resource;
+    BYTE *map_mem;
 
     struct wined3d_buffer_desc desc;
 
@@ -2583,6 +2811,11 @@
 BYTE *buffer_get_sysmem(struct wined3d_buffer *This, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_context *context,
         const struct wined3d_state *state) DECLSPEC_HIDDEN;
+void buffer_invalidate_bo_range(struct wined3d_buffer *This, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem) DECLSPEC_HIDDEN;
+void buffer_create_buffer_object(struct wined3d_buffer *This,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
 
 struct wined3d_rendertarget_view
 {
@@ -2595,7 +2828,8 @@
 struct wined3d_swapchain_ops
 {
     void (*swapchain_present)(struct wined3d_swapchain *swapchain, const RECT *src_rect,
-            const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags);
+            const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags,
+            struct wined3d_surface *depth_stencil);
 };
 
 struct wined3d_swapchain
@@ -2638,6 +2872,8 @@
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+HRESULT swapchain_create_context_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 /*****************************************************************************
  * Utility function prototypes
@@ -2663,7 +2899,6 @@
 const char *debug_glerror(GLenum error) DECLSPEC_HIDDEN;
 const char *debug_d3dtop(enum wined3d_texture_op d3dtop) DECLSPEC_HIDDEN;
 void dump_color_fixup_desc(struct color_fixup_desc fixup) DECLSPEC_HIDDEN;
-const char *debug_surflocation(DWORD flag) DECLSPEC_HIDDEN;
 
 BOOL is_invalid_op(const struct wined3d_state *state, int stage,
         enum wined3d_texture_op op, DWORD arg1, DWORD arg2, DWORD arg3) DECLSPEC_HIDDEN;
@@ -2741,6 +2976,8 @@
 UINT wined3d_log2i(UINT32 x) DECLSPEC_HIDDEN;
 unsigned int count_bits(unsigned int mask) DECLSPEC_HIDDEN;
 
+void wined3d_release_dc(HWND window, HDC dc) DECLSPEC_HIDDEN;
+
 struct wined3d_shader_lconst
 {
     struct list entry;
@@ -2855,6 +3092,7 @@
 void shader_generate_main(const struct wined3d_shader *shader, struct wined3d_shader_buffer *buffer,
         const struct wined3d_shader_reg_maps *reg_maps, const DWORD *byte_code, void *backend_ctx) DECLSPEC_HIDDEN;
 BOOL shader_match_semantic(const char *semantic_name, enum wined3d_decl_usage usage) DECLSPEC_HIDDEN;
+void shader_cleanup(struct wined3d_shader *shader) DECLSPEC_HIDDEN;
 
 static inline BOOL shader_is_scalar(const struct wined3d_shader_register *reg)
 {
@@ -2984,6 +3222,7 @@
 #define WINED3DFMT_FLAG_HEIGHT_SCALE                0x00040000
 #define WINED3DFMT_FLAG_TEXTURE                     0x00080000
 #define WINED3DFMT_FLAG_BLOCKS_NO_VERIFY            0x00100000
+#define WINED3DFMT_FLAG_PALETTE                     0x00200000
 
 struct wined3d_rational
 {
@@ -3063,4 +3302,28 @@
 
 #define MAKEDWORD_VERSION(maj, min) (((maj & 0xffff) << 16) | (min & 0xffff))
 
+static inline void wined3d_set_fpu_cw(WORD cw)
+{
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+    __asm__ volatile ("fnclex");
+    __asm__ volatile ("fldcw %0" : : "m" (cw));
+#elif defined(__i386__) && defined(_MSC_VER)
+    __asm fnclex;
+    __asm fldcw cw;
+#endif
+}
+
+static inline WORD wined3d_get_fpu_cw(void)
+{
+    WORD cw = 0;
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+    __asm__ volatile ("fnstcw %0" : "=m" (cw));
+#elif defined(__i386__) && defined(_MSC_VER)
+    __asm fnstcw cw;
+#endif
+    return cw;
+}
+
+#define WINED3D_DEFAULT_FPU_CW 0x037f
+
 #endif
diff -Naur a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
--- a/dlls/winex11.drv/opengl.c	2013-10-11 17:21:06.000000000 +0000
+++ b/dlls/winex11.drv/opengl.c	2013-11-14 16:15:12.906775214 +0000
@@ -1909,7 +1909,8 @@
 
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
-
+    
+        ERR("wglFinish\n");
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
@@ -1934,7 +1935,8 @@
 
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
-
+    
+        ERR("wglFlush\n");
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
diff -Naur a/include/wine/wined3d.h b/include/wine/wined3d.h
--- a/include/wine/wined3d.h	2013-10-11 17:21:06.000000000 +0000
+++ b/include/wine/wined3d.h	2013-11-07 21:40:10.000000000 +0000
@@ -1217,6 +1217,7 @@
 #define WINED3D_LEGACY_DEPTH_BIAS                               0x00000001
 #define WINED3D_NO3D                                            0x00000002
 #define WINED3D_VIDMEM_ACCOUNTING                               0x00000004
+#define WINED3D_NO_CSMT                                         0x00000008
 
 #define WINED3D_RESZ_CODE                                       0x7fa05000
 
@@ -2264,6 +2265,8 @@
         REFGUID guid, void *data, DWORD *data_size);
 HRESULT __cdecl wined3d_resource_set_private_data(struct wined3d_resource *resource,
         REFGUID guid, const void *data, DWORD data_size, DWORD flags);
+void __cdecl wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch);
 
 HRESULT __cdecl wined3d_rendertarget_view_create(struct wined3d_resource *resource,
         void *parent, struct wined3d_rendertarget_view **rendertarget_view);
@@ -2316,7 +2319,6 @@
 HRESULT __cdecl wined3d_surface_get_overlay_position(const struct wined3d_surface *surface, LONG *x, LONG *y);
 struct wined3d_palette * __cdecl wined3d_surface_get_palette(const struct wined3d_surface *surface);
 void * __cdecl wined3d_surface_get_parent(const struct wined3d_surface *surface);
-DWORD __cdecl wined3d_surface_get_pitch(const struct wined3d_surface *surface);
 DWORD __cdecl wined3d_surface_get_priority(const struct wined3d_surface *surface);
 HRESULT __cdecl wined3d_surface_get_render_target_data(struct wined3d_surface *surface,
         struct wined3d_surface *render_target);
