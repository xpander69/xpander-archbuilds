From 7095a3333dcf816e9c439243c462d0d882757872 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Stefan=20D=C3=B6singer?= <stefan@codeweavers.com>
Date: Thu, 20 Dec 2012 13:09:17 +0100
Subject: [PATCH 010/127] wined3d: Move the framebuffer into wined3d_state
Reply-To: wine-devel <wine-devel@winehq.org>

---
 dlls/wined3d/arb_program_shader.c |   4 +-
 dlls/wined3d/context.c            |  20 +++-
 dlls/wined3d/device.c             | 197 +++++++++++++++++++-------------------
 dlls/wined3d/drawprim.c           |  14 +--
 dlls/wined3d/glsl_shader.c        |   2 +-
 dlls/wined3d/shader.c             |   2 +-
 dlls/wined3d/state.c              |  18 ++--
 dlls/wined3d/stateblock.c         |  44 ++++++++-
 dlls/wined3d/surface.c            |  20 ++--
 dlls/wined3d/swapchain.c          |   2 +-
 dlls/wined3d/utils.c              |   2 +-
 dlls/wined3d/wined3d_private.h    |  43 +++++++--
 12 files changed, 222 insertions(+), 146 deletions(-)

diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
index fd7d3c6..abf9243 100644
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -711,7 +711,7 @@ static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
     {
         struct wined3d_shader *pshader = state->pixel_shader;
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
-        UINT rt_height = state->fb->render_targets[0]->resource.height;
+        UINT rt_height = state->fb.render_targets[0]->resource.height;
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constantsF(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -4689,7 +4689,7 @@ static void shader_arb_select(void *shader_priv, struct wined3d_context *context
         }
         else
         {
-            UINT rt_height = state->fb->render_targets[0]->resource.height;
+            UINT rt_height = state->fb.render_targets[0]->resource.height;
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 1ac2c47..11d86c5 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -1353,6 +1353,12 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+    ret->current_fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*ret->current_fb.render_targets) * gl_info->limits.buffers);
+    ret->current_fb.rt_size = gl_info->limits.buffers;
+    if (!ret->current_fb.render_targets)
+        goto out;
+
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -1663,6 +1669,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
 
 out:
     device->shader_backend->shader_free_context_data(ret);
+    HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->draw_buffers);
@@ -1696,6 +1703,7 @@ void context_destroy(struct wined3d_device *device, struct wined3d_context *cont
     }
 
     device->shader_backend->shader_free_context_data(context);
+    HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2205,7 +2213,7 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     UINT i;
     struct wined3d_surface **rts = fb->render_targets;
 
-    if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != &device->fb
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || !wined3d_fb_equal(fb, &context->current_fb)
             || rt_count != context->gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, fb->depth_stencil))
@@ -2246,6 +2254,8 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
         {
             rt_mask = context_generate_rt_mask_no_fbo(device, rt_count ? rts[0] : NULL);
         }
+
+        wined3d_fb_copy(&context->current_fb, fb);
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || surface_is_offscreen(rts[0])))
@@ -2294,7 +2304,7 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
 static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_device *device)
 {
     const struct wined3d_state *state = &device->state;
-    struct wined3d_surface **rts = state->fb->render_targets;
+    struct wined3d_surface **rts = state->fb.render_targets;
     struct wined3d_shader *ps = state->pixel_shader;
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
@@ -2322,7 +2332,7 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_device *device = context->swapchain->device;
-    const struct wined3d_fb_state *fb = state->fb;
+    const struct wined3d_fb_state *fb = &state->fb;
     DWORD rt_mask = find_draw_buffers_mask(context, device);
     DWORD *cur_mask;
 
@@ -2345,6 +2355,8 @@ void context_state_fb(struct wined3d_context *context, const struct wined3d_stat
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+
+    wined3d_fb_copy(&context->current_fb, &state->fb);
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -2841,7 +2853,7 @@ BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_de
 {
     const struct wined3d_state *state = &device->state;
     const struct StateEntry *state_table = context->state_table;
-    const struct wined3d_fb_state *fb = state->fb;
+    const struct wined3d_fb_state *fb = &state->fb;
     unsigned int i;
 
     if (!context_validate_rt_config(context->gl_info->limits.buffers,
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 900532f..5ab7b88 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -830,7 +830,6 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
     struct wined3d_context *context;
     HRESULT hr;
@@ -842,9 +841,6 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
-    device->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(*device->fb.render_targets) * gl_info->limits.buffers);
-
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -876,28 +872,28 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     }
     device->swapchains[0] = swapchain;
 
+    /* Setup all the devices defaults */
+    state_init_default(&device->state, device);
+
     if (swapchain->back_buffers && swapchain->back_buffers[0])
     {
         TRACE("Setting rendertarget to %p.\n", swapchain->back_buffers);
-        device->fb.render_targets[0] = swapchain->back_buffers[0];
+        device->state.fb.render_targets[0] = swapchain->back_buffers[0];
     }
     else
     {
         TRACE("Setting rendertarget to %p.\n", swapchain->front_buffer);
-        device->fb.render_targets[0] = swapchain->front_buffer;
+        device->state.fb.render_targets[0] = swapchain->front_buffer;
     }
-    wined3d_surface_incref(device->fb.render_targets[0]);
+    wined3d_surface_incref(device->state.fb.render_targets[0]);
 
     /* Depth Stencil support */
-    device->fb.depth_stencil = device->auto_depth_stencil;
-    if (device->fb.depth_stencil)
-        wined3d_surface_incref(device->fb.depth_stencil);
+    device->state.fb.depth_stencil = device->auto_depth_stencil;
+    if (device->state.fb.depth_stencil)
+        wined3d_surface_incref(device->state.fb.depth_stencil);
 
     /* Set up some starting GL setup */
 
-    /* Setup all the devices defaults */
-    state_init_default(&device->state, device);
-
     context = context_acquire(device, swapchain->front_buffer);
 
     create_dummy_textures(device, context);
@@ -941,7 +937,6 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     return WINED3D_OK;
 
 err_out:
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (swapchain)
@@ -1012,8 +1007,27 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (device->logo_surface)
         wined3d_surface_decref(device->logo_surface);
 
+    /* Release the buffers (with sanity checks).
+     * FIXME: Move this move into a separate patch. I think the idea
+     * behind this is that those surfaces should be freed before unloading
+     * remaining resources below. */
+    if (device->onscreen_depth_stencil)
+    {
+        surface = device->onscreen_depth_stencil;
+        device->onscreen_depth_stencil = NULL;
+        wined3d_surface_decref(surface);
+    }
+
     state_unbind_resources(&device->state);
 
+    if (device->auto_depth_stencil)
+    {
+        surface = device->auto_depth_stencil;
+        device->auto_depth_stencil = NULL;
+        if (wined3d_surface_decref(surface))
+            FIXME("Something's still holding the auto depth stencil buffer (%p).\n", surface);
+    }
+
     /* Unload resources */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
@@ -1043,43 +1057,6 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->shader_backend->shader_free_private(device);
     destroy_dummy_textures(device, gl_info);
 
-    /* Release the buffers (with sanity checks)*/
-    if (device->onscreen_depth_stencil)
-    {
-        surface = device->onscreen_depth_stencil;
-        device->onscreen_depth_stencil = NULL;
-        wined3d_surface_decref(surface);
-    }
-
-    if (device->fb.depth_stencil)
-    {
-        surface = device->fb.depth_stencil;
-
-        TRACE("Releasing depth/stencil buffer %p.\n", surface);
-
-        device->fb.depth_stencil = NULL;
-        wined3d_surface_decref(surface);
-    }
-
-    if (device->auto_depth_stencil)
-    {
-        surface = device->auto_depth_stencil;
-        device->auto_depth_stencil = NULL;
-        if (wined3d_surface_decref(surface))
-            FIXME("Something's still holding the auto depth stencil buffer (%p).\n", surface);
-    }
-
-    for (i = 1; i < gl_info->limits.buffers; ++i)
-    {
-        wined3d_device_set_render_target(device, i, NULL, FALSE);
-    }
-
-    surface = device->fb.render_targets[0];
-    TRACE("Setting rendertarget 0 to NULL\n");
-    device->fb.render_targets[0] = NULL;
-    TRACE("Releasing the render target at %p\n", surface);
-    wined3d_surface_decref(surface);
-
     context_release(context);
 
     for (i = 0; i < device->swapchain_count; ++i)
@@ -1093,9 +1070,6 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
-    device->fb.render_targets = NULL;
-
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1942,7 +1916,7 @@ static void resolve_depth_buffer(struct wined3d_state *state)
             || !(texture->resource.format->flags & WINED3DFMT_FLAG_DEPTH))
         return;
     surface = surface_from_resource(texture->sub_resources[0]);
-    depth_stencil = state->fb->depth_stencil;
+    depth_stencil = state->fb.depth_stencil;
     if (!depth_stencil)
         return;
 
@@ -3471,6 +3445,7 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
     RECT draw_rect;
+    const struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color {%.8e, %.8e, %.8e, %.8e}, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, color->r, color->g, color->b, color->a, depth, stencil);
@@ -3483,7 +3458,7 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
+        struct wined3d_surface *ds = fb->depth_stencil;
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3492,8 +3467,8 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
-            if (ds->resource.width < device->fb.render_targets[0]->resource.width
-                    || ds->resource.height < device->fb.render_targets[0]->resource.height)
+            if (ds->resource.width < fb->render_targets[0]->resource.width
+                    || ds->resource.height < fb->render_targets[0]->resource.height)
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3503,7 +3478,7 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
 
     wined3d_get_draw_rect(&device->state, &draw_rect);
     device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
-            &device->fb, rect_count, rects, &draw_rect, flags, color, depth, stencil);
+            fb, rect_count, rects, &draw_rect, flags, color, depth, stencil);
 
     return WINED3D_OK;
 }
@@ -3814,8 +3789,8 @@ HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
-        struct wined3d_surface *target = device->fb.render_targets[0];
+        struct wined3d_surface *ds = state->fb.depth_stencil;
+        struct wined3d_surface *target = state->fb.render_targets[0];
 
         if(ds && target
                 && (ds->resource.width < target->resource.width || ds->resource.height < target->resource.height))
@@ -3983,20 +3958,21 @@ struct wined3d_surface * CDECL wined3d_device_get_render_target(const struct win
         return NULL;
     }
 
-    return device->fb.render_targets[render_target_idx];
+    return device->state.fb.render_targets[render_target_idx];
 }
 
 struct wined3d_surface * CDECL wined3d_device_get_depth_stencil(const struct wined3d_device *device)
 {
     TRACE("device %p.\n", device);
 
-    return device->fb.depth_stencil;
+    return device->state.fb.depth_stencil;
 }
 
 HRESULT CDECL wined3d_device_set_render_target(struct wined3d_device *device,
         UINT render_target_idx, struct wined3d_surface *render_target, BOOL set_viewport)
 {
     struct wined3d_surface *prev;
+    struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("device %p, render_target_idx %u, render_target %p, set_viewport %#x.\n",
             device, render_target_idx, render_target, set_viewport);
@@ -4043,13 +4019,13 @@ HRESULT CDECL wined3d_device_set_render_target(struct wined3d_device *device,
     }
 
 
-    prev = device->fb.render_targets[render_target_idx];
+    prev = fb->render_targets[render_target_idx];
     if (render_target == prev)
         return WINED3D_OK;
 
     if (render_target)
         wined3d_surface_incref(render_target);
-    device->fb.render_targets[render_target_idx] = render_target;
+    fb->render_targets[render_target_idx] = render_target;
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
     if (prev)
@@ -4062,7 +4038,8 @@ HRESULT CDECL wined3d_device_set_render_target(struct wined3d_device *device,
 
 void CDECL wined3d_device_set_depth_stencil(struct wined3d_device *device, struct wined3d_surface *depth_stencil)
 {
-    struct wined3d_surface *prev = device->fb.depth_stencil;
+    struct wined3d_fb_state *fb = &device->state.fb;
+    struct wined3d_surface *prev = fb->depth_stencil;
 
     TRACE("device %p, depth_stencil %p, old depth_stencil %p.\n",
             device, depth_stencil, prev);
@@ -4088,7 +4065,7 @@ void CDECL wined3d_device_set_depth_stencil(struct wined3d_device *device, struc
         }
     }
 
-    device->fb.depth_stencil = depth_stencil;
+    fb->depth_stencil = depth_stencil;
     if (depth_stencil)
         wined3d_surface_incref(depth_stencil);
 
@@ -4442,6 +4419,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     UINT backbuffer_height = swapchain_desc->backbuffer_height;
     HRESULT hr = WINED3D_OK;
     unsigned int i;
+    struct wined3d_surface *new_rt = NULL;
 
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p.\n", device, swapchain_desc, mode, callback);
 
@@ -4451,21 +4429,31 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (reset_state)
-        state_unbind_resources(&device->state);
-
-    if (device->fb.render_targets)
+    /* Make sure the render target survives the resource reset,
+     * state_unbind_resources() will set it to NULL and release
+     * the old one - which might be the same as the new one. */
+    if (device->state.fb.render_targets)
     {
         if (swapchain->back_buffers && swapchain->back_buffers[0])
-            wined3d_device_set_render_target(device, 0, swapchain->back_buffers[0], FALSE);
+            new_rt = swapchain->back_buffers[0];
         else
-            wined3d_device_set_render_target(device, 0, swapchain->front_buffer, FALSE);
-        for (i = 1; i < device->adapter->gl_info.limits.buffers; ++i)
-        {
-            wined3d_device_set_render_target(device, i, NULL, FALSE);
-        }
+            new_rt = swapchain->front_buffer;
+        wined3d_surface_incref(new_rt);
     }
+
     wined3d_device_set_depth_stencil(device, NULL);
+    for (i = 1; i < device->adapter->gl_info.limits.buffers; ++i)
+        wined3d_device_set_render_target(device, i, NULL, FALSE);
+
+    if (reset_state)
+    {
+        state_unbind_resources(&device->state);
+    }
+    else
+    {
+        wined3d_surface_decref(device->state.fb.render_targets[0]);
+        device->state.fb.render_targets[0] = NULL;
+    }
 
     if (device->onscreen_depth_stencil)
     {
@@ -4479,7 +4467,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         {
             TRACE("Enumerating resource %p.\n", resource);
             if (FAILED(hr = callback(resource)))
-                return hr;
+                goto err_out;
         }
     }
 
@@ -4550,14 +4538,11 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
                 device->device_parent, &surface_desc, &device->auto_depth_stencil)))
         {
             ERR("Failed to create the depth stencil buffer, hr %#x.\n", hr);
-            return WINED3DERR_INVALIDCALL;
+            hr = WINED3DERR_INVALIDCALL;
+            goto err_out;
         }
     }
 
-    /* Reset the depth stencil */
-    if (swapchain_desc->enable_auto_depth_stencil)
-        wined3d_device_set_depth_stencil(device, device->auto_depth_stencil);
-
     if (mode)
     {
         DisplayModeChanged = TRUE;
@@ -4633,21 +4618,21 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         if (FAILED(hr = wined3d_surface_update_desc(swapchain->front_buffer, swapchain->desc.backbuffer_width,
                 swapchain->desc.backbuffer_height, swapchain->desc.backbuffer_format,
                 swapchain->desc.multisample_type, swapchain->desc.multisample_quality)))
-            return hr;
+            goto err_out;
 
         for (i = 0; i < swapchain->desc.backbuffer_count; ++i)
         {
             if (FAILED(hr = wined3d_surface_update_desc(swapchain->back_buffers[i], swapchain->desc.backbuffer_width,
                     swapchain->desc.backbuffer_height, swapchain->desc.backbuffer_format,
                     swapchain->desc.multisample_type, swapchain->desc.multisample_quality)))
-                return hr;
+                goto err_out;
         }
         if (device->auto_depth_stencil)
         {
             if (FAILED(hr = wined3d_surface_update_desc(device->auto_depth_stencil, swapchain->desc.backbuffer_width,
                     swapchain->desc.backbuffer_height, device->auto_depth_stencil->resource.format->id,
                     swapchain->desc.multisample_type, swapchain->desc.multisample_quality)))
-                return hr;
+                goto err_out;
         }
     }
 
@@ -4657,7 +4642,8 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         if (FAILED(hr = wined3d_set_adapter_display_mode(device->wined3d, device->adapter->ordinal, &m)))
         {
             WARN("Failed to set display mode, hr %#x.\n", hr);
-            return WINED3DERR_INVALIDCALL;
+            hr = WINED3DERR_INVALIDCALL;
+            goto err_out;
         }
 
         if (!swapchain_desc->windowed)
@@ -4670,7 +4656,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
                 if (FAILED(hr = wined3d_device_acquire_focus_window(device, focus_window)))
                 {
                     ERR("Failed to acquire focus window, hr %#x.\n", hr);
-                    return hr;
+                    goto err_out;
                 }
 
                 /* switch from windowed to fs */
@@ -4725,30 +4711,37 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
-        if (FAILED(hr = state_init(&device->state, &device->adapter->d3d_info)))
+        hr = state_init(&device->state, &device->adapter->d3d_info, &device->adapter->gl_info);
+        if (FAILED(hr))
             ERR("Failed to initialize device state, hr %#x.\n", hr);
         state_init_default(&device->state, device);
         device->update_state = &device->state;
     }
     else
     {
-        struct wined3d_surface *rt = device->fb.render_targets[0];
         struct wined3d_state *state = &device->state;
 
         /* Note the min_z / max_z is not reset. */
         state->viewport.x = 0;
         state->viewport.y = 0;
-        state->viewport.width = rt->resource.width;
-        state->viewport.height = rt->resource.height;
+        state->viewport.width = new_rt->resource.width;
+        state->viewport.height = new_rt->resource.height;
         device_invalidate_state(device, STATE_VIEWPORT);
 
         state->scissor_rect.top = 0;
         state->scissor_rect.left = 0;
-        state->scissor_rect.right = rt->resource.width;
-        state->scissor_rect.bottom = rt->resource.height;
+        state->scissor_rect.right = new_rt->resource.width;
+        state->scissor_rect.bottom = new_rt->resource.height;
         device_invalidate_state(device, STATE_SCISSORRECT);
     }
 
+    wined3d_device_set_render_target(device, 0, new_rt, FALSE);
+    wined3d_surface_decref(new_rt);
+
+    /* Reset the depth stencil */
+    if (swapchain_desc->enable_auto_depth_stencil)
+        wined3d_device_set_depth_stencil(device, device->auto_depth_stencil);
+
     swapchain_update_render_to_fbo(swapchain);
     swapchain_update_draw_bindings(swapchain);
 
@@ -4759,6 +4752,11 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
      * first use
      */
     return hr;
+
+err_out:
+    wined3d_device_set_render_target(device, 0, new_rt, FALSE);
+    wined3d_surface_decref(new_rt);
+    return hr;
 }
 
 HRESULT CDECL wined3d_device_set_dialog_box_mode(struct wined3d_device *device, BOOL enable_dialogs)
@@ -4836,17 +4834,17 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
                 for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
                 {
-                    if (device->fb.render_targets[i] == surface)
+                    if (device->state.fb.render_targets[i] == surface)
                     {
                         ERR("Surface %p is still in use as render target %u.\n", surface, i);
-                        device->fb.render_targets[i] = NULL;
+                        device->state.fb.render_targets[i] = NULL;
                     }
                 }
 
-                if (device->fb.depth_stencil == surface)
+                if (device->state.fb.depth_stencil == surface)
                 {
                     ERR("Surface %p is still in use as depth/stencil buffer.\n", surface);
-                    device->fb.depth_stencil = NULL;
+                    device->state.fb.depth_stencil = NULL;
                 }
             }
             break;
@@ -4987,7 +4985,8 @@ HRESULT device_init(struct wined3d_device *device, struct wined3d *wined3d,
 
     device->blitter = adapter->blitter;
 
-    if (FAILED(hr = state_init(&device->state, &adapter->d3d_info)))
+    hr = state_init(&device->state, &adapter->d3d_info, &adapter->gl_info);
+    if (FAILED(hr))
     {
         ERR("Failed to initialize device state, hr %#x.\n", hr);
         for (i = 0; i < sizeof(device->multistate_funcs) / sizeof(device->multistate_funcs[0]); ++i)
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
index 804172e..1627e8e 100644
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -604,7 +604,7 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
         /* Invalidate the back buffer memory so LockRect will read it the next time */
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
-            struct wined3d_surface *target = device->fb.render_targets[i];
+            struct wined3d_surface *target = state->fb.render_targets[i];
             if (target)
             {
                 surface_load_location(target, target->draw_binding, NULL);
@@ -613,7 +613,7 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
         }
     }
 
-    context = context_acquire(device, device->fb.render_targets[0]);
+    context = context_acquire(device, state->fb.render_targets[0]);
     if (!context->valid)
     {
         context_release(context);
@@ -622,17 +622,17 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
     }
     gl_info = context->gl_info;
 
-    if (device->fb.depth_stencil)
+    if (state->fb.depth_stencil)
     {
         /* Note that this depends on the context_acquire() call above to set
          * context->render_offscreen properly. We don't currently take the
          * Z-compare function into account, but we could skip loading the
          * depthstencil for D3DCMP_NEVER and D3DCMP_ALWAYS as well. Also note
          * that we never copy the stencil data.*/
-        DWORD location = context->render_offscreen ? device->fb.depth_stencil->draw_binding : SFLAG_INDRAWABLE;
+        DWORD location = context->render_offscreen ? state->fb.depth_stencil->draw_binding : SFLAG_INDRAWABLE;
         if (state->render_states[WINED3D_RS_ZWRITEENABLE] || state->render_states[WINED3D_RS_ZENABLE])
         {
-            struct wined3d_surface *ds = device->fb.depth_stencil;
+            struct wined3d_surface *ds = state->fb.depth_stencil;
             RECT current_rect, draw_rect, r;
 
             if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
@@ -658,9 +658,9 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
         return;
     }
 
-    if (device->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
+    if (state->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
     {
-        struct wined3d_surface *ds = device->fb.depth_stencil;
+        struct wined3d_surface *ds = state->fb.depth_stencil;
         DWORD location = context->render_offscreen ? ds->draw_binding : SFLAG_INDRAWABLE;
 
         surface_modify_ds_location(ds, location, ds->ds_current_size.cx, ds->ds_current_size.cy);
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 72dbef8..84a7ffb 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1019,7 +1019,7 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
     const struct wined3d_state *state = &shader->device->state;
     const struct ps_compile_args *ps_args = ctx_priv->cur_ps_args;
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_fb_state *fb = &shader->device->fb;
+    const struct wined3d_fb_state *fb = &state->fb;
     unsigned int i, extra_constants_needed = 0;
     const struct wined3d_shader_lconst *lconst;
     const char *prefix;
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index b61076e..8e1c245 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -2032,7 +2032,7 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && state->render_states[WINED3D_RS_SRGBWRITEENABLE])
     {
-        const struct wined3d_surface *rt = state->fb->render_targets[0];
+        const struct wined3d_surface *rt = state->fb.render_targets[0];
         if (rt->resource.format->flags & WINED3DFMT_FLAG_SRGB_WRITE)
         {
             static unsigned int warned = 0;
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index 5683310..e49a315 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -106,7 +106,7 @@ static void state_zenable(struct wined3d_context *context, const struct wined3d_
     static UINT once;
 
     /* No z test without depth stencil buffers */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -381,7 +381,7 @@ static GLenum gl_blend_factor(enum wined3d_blend factor, const struct wined3d_fo
 
 static void state_blend(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_surface *target = state->fb->render_targets[0];
+    const struct wined3d_surface *target = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     GLenum srcBlend, dstBlend;
     enum wined3d_blend d3d_blend;
@@ -833,7 +833,7 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
     GLint stencilPass_ccw = GL_KEEP;
 
     /* No stencil test without a stencil buffer. */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -919,7 +919,7 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -933,7 +933,7 @@ static void state_stencilwrite2s(struct wined3d_context *context, const struct w
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1772,7 +1772,7 @@ static void state_depthbias(struct wined3d_context *context, const struct wined3
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
-        const struct wined3d_surface *depth = state->fb->depth_stencil;
+        const struct wined3d_surface *depth = state->fb.depth_stencil;
         float scale;
 
         union
@@ -4646,7 +4646,7 @@ void vertexdeclaration(struct wined3d_context *context, const struct wined3d_sta
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_surface *target = state->fb->render_targets[0];
+    const struct wined3d_surface *target = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
 
@@ -4826,7 +4826,7 @@ static void scissorrect(struct wined3d_context *context, const struct wined3d_st
     }
     else
     {
-        const struct wined3d_surface *target = state->fb->render_targets[0];
+        const struct wined3d_surface *target = state->fb.render_targets[0];
         UINT height;
         UINT width;
 
@@ -4894,7 +4894,7 @@ static void psorigin(struct wined3d_context *context, const struct wined3d_state
 void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_surface *rt = state->fb->render_targets[0];
+    const struct wined3d_surface *rt = state->fb.render_targets[0];
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
 
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index 00ab69a..2e7215a 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -463,6 +463,7 @@ void state_unbind_resources(struct wined3d_state *state)
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+    struct wined3d_surface *surface;
     unsigned int i;
 
     if ((decl = state->vertex_declaration))
@@ -575,6 +576,31 @@ void state_unbind_resources(struct wined3d_state *state)
             wined3d_buffer_decref(buffer);
         }
     }
+
+    if (state->fb.depth_stencil)
+    {
+        surface = state->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil buffer %p.\n", surface);
+
+        state->fb.depth_stencil = NULL;
+        wined3d_surface_decref(surface);
+    }
+
+    if (state->fb.render_targets)
+    {
+        for (i = 0; i < state->fb.rt_size; i++)
+        {
+            surface = state->fb.render_targets[i];
+            TRACE("Setting rendertarget %u to NULL\n", i);
+            state->fb.render_targets[i] = NULL;
+            if (surface)
+            {
+                TRACE("Releasing the render target at %p\n", surface);
+                wined3d_surface_decref(surface);
+            }
+        }
+    }
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -596,9 +622,11 @@ void state_cleanup(struct wined3d_state *state)
 
     HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
     HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+    HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
 }
 
-HRESULT state_init(struct wined3d_state *state, const struct wined3d_d3d_info *d3d_info)
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_d3d_info *d3d_info,
+        const struct wined3d_gl_info *gl_info)
 {
     unsigned int i;
 
@@ -618,6 +646,15 @@ HRESULT state_init(struct wined3d_state *state, const struct wined3d_d3d_info *d
         return E_OUTOFMEMORY;
     }
 
+    if (!(state->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*state->fb.render_targets) * gl_info->limits.buffers)))
+    {
+        HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+        HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
+        return E_OUTOFMEMORY;
+    }
+    state->fb.rt_size = gl_info->limits.buffers;
+
     return WINED3D_OK;
 }
 
@@ -1201,8 +1238,6 @@ void state_init_default(struct wined3d_state *state, struct wined3d_device *devi
         state->transforms[WINED3D_TS_WORLD_MATRIX(i)] = identity;
     }
 
-    state->fb = &device->fb;
-
     TRACE("Render states\n");
     /* Render states: */
     if (device->auto_depth_stencil)
@@ -1418,12 +1453,13 @@ static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
         struct wined3d_device *device, enum wined3d_stateblock_type type)
 {
     HRESULT hr;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
 
     stateblock->ref = 1;
     stateblock->device = device;
 
-    if (FAILED(hr = state_init(&stateblock->state, d3d_info)))
+    if (FAILED(hr = state_init(&stateblock->state, d3d_info, gl_info)))
         return hr;
 
     if (FAILED(hr = stateblock_allocate_shader_constants(stateblock)))
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index ceae687..c178ee6 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -1295,9 +1295,11 @@ static BOOL fbo_blit_supported(const struct wined3d_gl_info *gl_info, enum wined
 /* This function checks if the primary render target uses the 8bit paletted format. */
 static BOOL primary_render_target_is_p8(const struct wined3d_device *device)
 {
-    if (device->fb.render_targets && device->fb.render_targets[0])
+    const struct wined3d_fb_state *fb = &device->state.fb;
+
+    if (fb->render_targets && fb->render_targets[0])
     {
-        const struct wined3d_surface *render_target = device->fb.render_targets[0];
+        const struct wined3d_surface *render_target = fb->render_targets[0];
         if ((render_target->resource.usage & WINED3DUSAGE_RENDERTARGET)
                 && (render_target->resource.format->id == WINED3DFMT_P8_UINT))
             return TRUE;
@@ -2357,6 +2359,7 @@ static HRESULT d3dfmt_get_conv(const struct wined3d_surface *surface, BOOL need_
     const struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     BOOL blit_supported = FALSE;
+    const struct wined3d_fb_state *fb = &device->state.fb;
 
     /* Copy the default values from the surface. Below we might perform fixups */
     /* TODO: get rid of color keying desc fixups by using e.g. a table. */
@@ -2388,7 +2391,7 @@ static HRESULT d3dfmt_get_conv(const struct wined3d_surface *surface, BOOL need_
              * in which the main render target uses p8. Some games like GTA Vice City use P8 for texturing which
              * conflicts with this.
              */
-            if (!((blit_supported && device->fb.render_targets && surface == device->fb.render_targets[0]))
+            if (!((blit_supported && fb->render_targets && surface == fb->render_targets[0]))
                     || colorkey_active || !use_texturing)
             {
                 format->glFormat = GL_RGBA;
@@ -5240,6 +5243,7 @@ static HRESULT IWineD3DSurfaceImpl_BltOverride(struct wined3d_surface *dst_surfa
     struct wined3d_device *device = dst_surface->resource.device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+    const struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, blt_fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
@@ -5271,8 +5275,8 @@ static HRESULT IWineD3DSurfaceImpl_BltOverride(struct wined3d_surface *dst_surfa
 
     /* Early sort out of cases where no render target is used */
     if (!dst_swapchain && !src_swapchain
-            && src_surface != device->fb.render_targets[0]
-            && dst_surface != device->fb.render_targets[0])
+            && src_surface != fb->render_targets[0]
+            && dst_surface != fb->render_targets[0])
     {
         TRACE("No surface is render target, not using hardware blit.\n");
         return WINED3DERR_INVALIDCALL;
@@ -5301,16 +5305,16 @@ static HRESULT IWineD3DSurfaceImpl_BltOverride(struct wined3d_surface *dst_surfa
     if (dst_swapchain)
     {
         /* Handled with regular texture -> swapchain blit */
-        if (src_surface == device->fb.render_targets[0])
+        if (src_surface == fb->render_targets[0])
             TRACE("Blit from active render target to a swapchain\n");
     }
-    else if (src_swapchain && dst_surface == device->fb.render_targets[0])
+    else if (src_swapchain && dst_surface == fb->render_targets[0])
     {
         FIXME("Implement blit from a swapchain to the active render target\n");
         return WINED3DERR_INVALIDCALL;
     }
 
-    if ((src_swapchain || src_surface == device->fb.render_targets[0]) && !dst_swapchain)
+    if ((src_swapchain || src_surface == fb->render_targets[0]) && !dst_swapchain)
     {
         /* Blit from render target to texture */
         BOOL stretchx;
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index 970dcdb..5a86351 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -412,7 +412,7 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
         const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
 {
     struct wined3d_surface *back_buffer = swapchain->back_buffers[0];
-    const struct wined3d_fb_state *fb = &swapchain->device->fb;
+    const struct wined3d_fb_state *fb = &swapchain->device->state.fb;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     RECT src_rect, dst_rect;
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index 93c358a..88b96ea 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -3146,7 +3146,7 @@ void gen_ffp_frag_op(const struct wined3d_context *context, const struct wined3d
     unsigned int i;
     DWORD ttff;
     DWORD cop, aop, carg0, carg1, carg2, aarg0, aarg1, aarg2;
-    const struct wined3d_surface *rt = state->fb->render_targets[0];
+    const struct wined3d_surface *rt = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct wined3d_d3d_info *d3d_info = context->d3d_info;
 
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index ad292fc..89b5328 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -1049,6 +1049,36 @@ enum wined3d_event_query_result wined3d_event_query_finish(const struct wined3d_
 void wined3d_event_query_issue(struct wined3d_event_query *query, const struct wined3d_device *device) DECLSPEC_HIDDEN;
 BOOL wined3d_event_query_supported(const struct wined3d_gl_info *gl_info) DECLSPEC_HIDDEN;
 
+struct wined3d_fb_state
+{
+    struct wined3d_surface **render_targets;
+    struct wined3d_surface *depth_stencil;
+    UINT rt_size;
+};
+
+static inline BOOL wined3d_fb_equal(const struct wined3d_fb_state *fb1, const struct wined3d_fb_state *fb2)
+{
+    UINT i;
+
+    if (fb1->depth_stencil != fb2->depth_stencil)
+        return FALSE;
+    if (fb1->rt_size != fb2->rt_size)
+        return FALSE;
+    for (i = 0; i < fb1->rt_size; i++)
+        if (fb1->render_targets[i] != fb2->render_targets[i])
+            return FALSE;
+    return TRUE;
+}
+
+static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wined3d_fb_state *src)
+{
+    UINT i;
+
+    dst->depth_stencil = src->depth_stencil;
+    for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
+        dst->render_targets[i] = src->render_targets[i];
+}
+
 struct wined3d_context
 {
     const struct wined3d_gl_info *gl_info;
@@ -1063,6 +1093,7 @@ struct wined3d_context
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+    struct wined3d_fb_state current_fb;
 
     struct wined3d_swapchain *swapchain;
     struct wined3d_surface *current_rt;
@@ -1151,12 +1182,6 @@ struct wined3d_context
     GLuint                  dummy_arbfp_prog;
 };
 
-struct wined3d_fb_state
-{
-    struct wined3d_surface **render_targets;
-    struct wined3d_surface *depth_stencil;
-};
-
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
 
 struct StateEntry
@@ -1801,7 +1826,7 @@ struct wined3d_stream_state
 
 struct wined3d_state
 {
-    const struct wined3d_fb_state *fb;
+    struct wined3d_fb_state fb;
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -1910,7 +1935,6 @@ struct wined3d_device
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
 
     /* Render Target Support */
-    struct wined3d_fb_state fb;
     struct wined3d_surface *onscreen_depth_stencil;
     struct wined3d_surface *auto_depth_stencil;
 
@@ -2442,7 +2466,8 @@ struct wined3d_stateblock
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
-HRESULT state_init(struct wined3d_state *state, const struct wined3d_d3d_info *d3d_info) DECLSPEC_HIDDEN;
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_d3d_info *d3d_info,
+        const struct wined3d_gl_info *gl_info) DECLSPEC_HIDDEN;
 void state_init_default(struct wined3d_state *state, struct wined3d_device *device) DECLSPEC_HIDDEN;
 void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
 
-- 
1.8.1.5

